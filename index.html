<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Combat de Creatures</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        
/* Container pour les toasts */
.toastContainer {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: none;
}

/* Style de base d'un toast */
.toast {
    min-width: 300px;
    max-width: 400px;
    padding: 16px 20px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: auto;
    cursor: pointer;
    animation: slideIn 0.3s ease;
    transition: all 0.3s ease;
}

.toast:hover {
    transform: translateX(-5px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}

/* Animation d'entr√©e */
@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Animation de sortie */
@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

.toast.removing {
    animation: slideOut 0.3s ease;
}

/* Ic√¥ne du toast */
.toast-icon {
    font-size: 28px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 50%;
}

/* Contenu du toast */
.toast-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.toast-title {
    font-weight: bold;
    font-size: 15px;
    color: #333;
}

.toast-message {
    font-size: 13px;
    color: #666;
    line-height: 1.4;
}

/* Bouton de fermeture */
.toast-close {
    font-size: 20px;
    color: #999;
    cursor: pointer;
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
}

.toast-close:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #333;
}

/* Types de toasts */
.toast-success {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    border-left: 4px solid #28a745;
}

.toast-success .toast-icon {
    background: rgba(40, 167, 69, 0.1);
    color: #28a745;
}

.toast-info {
    background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
    border-left: 4px solid #17a2b8;
}

.toast-info .toast-icon {
    background: rgba(23, 162, 184, 0.1);
    color: #17a2b8;
}

.toast-warning {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    border-left: 4px solid #ffc107;
}

.toast-warning .toast-icon {
    background: rgba(255, 193, 7, 0.1);
    color: #ffc107;
}

.toast-error {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    border-left: 4px solid #dc3545;
}

.toast-error .toast-icon {
    background: rgba(220, 53, 69, 0.1);
    color: #dc3545;
}

.toast-shiny {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
    border-left: 4px solid #ffd700;
    box-shadow: 0 8px 32px rgba(255, 215, 0, 0.3);
}

.toast-shiny .toast-icon {
    background: rgba(255, 215, 0, 0.2);
    color: #ff8c00;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.toast-legendary {
    background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
    border-left: 4px solid #6c3483;
    color: white;
}

.toast-legendary .toast-icon {
    background: rgba(255, 255, 255, 0.2);
    color: white;
}

.toast-legendary .toast-title,
.toast-legendary .toast-message {
    color: white;
}

.toast-legendary .toast-close {
    color: rgba(255, 255, 255, 0.8);
}

.toast-legendary .toast-close:hover {
    background: rgba(255, 255, 255, 0.2);
    color: white;
}
        

        
        
		
		.battle-sprite {
    width: 96px;
    height: 96px;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
    animation: sprite-float 2s ease-in-out infinite;
}

@keyframes sprite-float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-8px); }
}

.battle-sprite-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

        
/* --- LAYOUT DASHBOARD PC (3 COLONNES) --- */

.game-container {
    display: grid;
    /* 1. GAUCHE (320px) | 2. CENTRE (Flexible) | 3. DROITE (400px) */
    grid-template-columns: 520px 1fr 520px;
    
    /* Ligne 1 : Header | Ligne 2 : Contenu Principal */
    grid-template-rows: auto 1fr;
    
    /* Prend toute la hauteur de la fen√™tre, sans scrollbar sur le body */
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    
    gap: 20px;
    padding: 20px;
    background: #2c3e50; /* Fond global plus sombre pour faire ressortir les panneaux */
}

/* --- HEADER FINAL : DASHBOARD BLANC UNIFI√â --- */

.header {
    /* TON STYLE VISUEL EXACT */
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 0 0 20px 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    
    /* POSITIONNEMENT */
    grid-column: 1 / -1;
    position: sticky;
    top: 0;
    z-index: 100;
    padding: 10px 20px;
}

/* LE CONTENEUR QUI ALIGNE TOUT SUR UNE LIGNE */
.header-unified-row {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap; /* Important pour le responsive */
    gap: 20px;
}

/* GROUPES INTERNES */
.combat-stats-group, .resources-group, .header-buttons {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
}

/* --- 1. LES STATS (Ton style Chip avec barre couleur) --- */
.stat-chip {
    background: white;
    border: 1px solid #e2e8f0;
    border-bottom-width: 3px; /* TA BARRE COLOR√âE */
    border-radius: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: transform 0.2s, box-shadow 0.2s;
    
    display: flex;
    flex-direction: row;
    align-items: baseline;
    gap: 6px;
    
    padding: 8px 14px;
    min-width: 120px;
}

.stat-chip:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

/* TES COULEURS */
#headerStatHP { border-bottom-color: #ef4444; }
#headerStatAtk { border-bottom-color: #f59e0b; }
#headerStatDef { border-bottom-color: #3b82f6; }
#headerStatSpd { border-bottom-color: #8b5cf6; }

.stat-label {
    font-size: 14px; font-weight: 700; color: #64748b; text-transform: uppercase;
}
.stat-value {
    font-size: 15px; font-weight: 700; color: #1e293b;
}
.stat-sub-info {
    font-size: 11px; color: #94a3b8; font-weight: 600; margin-left: 2px;
}
.stat-sub-info span {
    color: #16a34a !important; font-weight: 700; /* Le vert demand√© */
}

/* --- 2. LES RESSOURCES (Ton style propre) --- */
.resource-chip {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: transform 0.2s;
    
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 6px 14px;
    height: 42px; /* Hauteur fixe pour alignement */
}

.resource-chip:hover {
    transform: translateY(-2px);
    border-color: #cbd5e1;
}

.resource-icon { font-size: 18px; }
.resource-val { font-size: 15px; font-weight: 700; color: #1e293b; }
.resource-name { font-size: 10px; font-weight: 600; color: #64748b; text-transform: uppercase; }

/* --- 3. LES BOUTONS (Ton style sys-btn adapt√©) --- */
.header-buttons .btn {
    background: #f3f4f6;
    border: 1px solid #e5e7eb;
    color: #4b5563;
    padding: 0 16px; /* Padding lat√©ral */
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    
    display: flex;
    align-items: center;
    gap: 6px;
    height: 42px; /* M√äME HAUTEUR QUE LES RESSOURCES POUR ALIGNEMENT PARFAIT */
}

.header-buttons .btn:hover {
    background: #e0e7ff;
    color: #4f46e5;
    border-color: #c7d2fe;
    transform: translateY(-2px);
}

/* --- 2. COLONNE GAUCHE : GESTION (√âquipe, Pension, Stockage) --- */
.team-area {
    grid-column: 1;
    grid-row: 2;
    
    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    
    /* Scroll ind√©pendant pour cette colonne */
    overflow-y: auto;
    height: 100%;
    
    /* Style des scrollbars (Fines et discr√®tes) */
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 transparent;
}

/* --- 3. COLONNE CENTRALE : COMBAT (Action) --- */
.combat-area {
    grid-column: 2;
    grid-row: 2;
    
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15); /* Ombre plus forte pour l'emphase */
    
    /* Centrage du contenu */
    display: flex;
    flex-direction: column;
    /* justify-content: center; */ /* Optionnel : pour centrer verticalement si l'√©cran est grand */
    
    overflow-y: auto;
    height: 100%;
}

/* --- 4. COLONNE DROITE : EXTRAS (Boutique, Qu√™tes, etc.) --- */
.secondary-content {
    grid-column: 3;
    grid-row: 2;
    
    /* On force l'affichage (√©crase le display:none du JS initial) */
    display: flex !important; 
    flex-direction: column;
    
    background: rgba(255, 255, 255, 0.9);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    
    overflow-y: auto;
    height: 100%;
}

/* --- NETTOYAGE --- */

/* On cache d√©finitivement le bouton flottant "Extras" car tout est visible */
button[onclick="toggleSecondaryContent()"], 
#toggleIcon {
    display: none !important;
}

/* Ajustement des onglets pour la colonne de droite */
.tabs-container {
    flex-wrap: wrap; /* Permet aux boutons de passer √† la ligne si besoin */
    justify-content: center;
}
.tab-btn {
    flex: 1; /* Boutons d'onglets √©quitables */
    font-size: 12px; /* Un peu plus petit pour tenir */
    padding: 8px 5px;
    white-space: nowrap;
}
        

        .tabs-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: #667eea;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .tab-btn.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            height: 400px;
            overflow-y: auto;
        }
/* 2. Styles pour les nouveaux sous-onglets (dans la Boutique) */
.sub-tabs-container {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    border-bottom: 2px solid #ddd;
}

.sub-tab-btn {
    padding: 8px 16px;
    background: none;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    font-weight: bold;
    color: #666;
    transition: all 0.2s ease;
}

.sub-tab-btn:hover {
    background: rgba(0,0,0,0.05);
}

.sub-tab-btn.active {
    color: #667eea;
    border-bottom-color: #667eea;
}

.sub-tab-content {
    display: none; /* Cach√© par d√©faut */
}

.sub-tab-content.active {
    display: block; /* Affich√© si actif */
}
        .tab-content.active {
            display: block;
        }

  

        .creature-name {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 10px;

    /* --- AJOUTS --- */
    display: flex; /* Permet d'aligner le nom et l'ic√¥ne */
    align-items: center;
    justify-content: center; /* Centre le nom et l'ic√¥ne ensemble */
    gap: 8px; /* Espace entre le nom et l'ic√¥ne */
}
/* Style pour la nouvelle ic√¥ne de statut (dans le nom) */
.status-icon {
    font-size: 16px; /* L√©g√®rement plus petit que le texte */
    line-height: 1; /* Emp√™che de d√©former la hauteur de ligne */
}

        .creature-level {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .health-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        
/* OPTIMISATION : Performance GPU Maximale */
.health-fill {
    height: 100%;
    width: 100%; 
    background: linear-gradient(90deg, #4ade80, #22c55e);
    transform-origin: left; 
    transform: scaleX(1); 
    transition: transform 0.3s ease-out, background-color 0.3s;
    
    /* ‚¨áÔ∏è AJOUT CRITIQUE ‚¨áÔ∏è */
    will-change: transform; 
    /* Force le navigateur √† cr√©er un calque Composite (GPU) pour cet √©l√©ment. 
       R√©sultat : Z√©ro recalcul de layout quand la barre bouge. */
}

        .health-text {
            font-size: 12px;
            color: #666;
        }

        .vs-text {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 0 20px;
        }

        

        .team-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .creature-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            position: relative;
        }

        .creature-card:hover {
            transform: translateY(-2px);
        }

        .creature-card h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .creature-stats {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            margin-bottom: 5px;
        }

/* ... (Ajoutez ceci n'importe o√π dans votre balise <style>) ... */
.ultimate-btn {
    position: absolute;
    bottom: 5px;
    left: 5px;
    width: calc(100% - 10px);
    padding: 8px;
    border: none;
    border-radius: 8px;
    background: linear-gradient(135deg, #666, #444);
    color: white;
    font-weight: bold;
    cursor: not-allowed;
    opacity: 1;
    transition: all 0.2s ease;
    z-index: 10;
    font-size: 12px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.ultimate-btn:not(:disabled) {
    background: linear-gradient(135deg, #f39c12, #e67e22);
    opacity: 1;
    cursor: pointer;
    animation: pulse-reward 2s infinite;
    box-shadow: 0 0 15px rgba(243, 156, 18, 1);
}

.ultimate-btn:not(:disabled):hover {
    transform: scale(1.05);
}



        .type-fire { background: #ff6b35; }
        .type-water { background: #4dabf7; }
        .type-grass { background: #51cf66; }
        .type-electric { background: #ffd43b; color: #333; }
        .type-normal { background: #868e96; }
		.type-rock { background: #b8860b; color: white; }
.type-flying { background: #87ceeb; color: #333; }
.type-psychic { background: #ff1493; color: white; }
.type-dark { background: #2c1e3f; color: white; }
.type-steel { background: #b0b0b0; color: #333; }
.type-dragon { background: #7038f8; color: white; }
.type-fighting { background: #c03028; color: white; }
.type-poison { background: #a040a0; color: white; }
.type-ground { background: #e0c068; color: #333; }
.type-bug { background: #a8b820; color: #333; }
.type-ghost { background: #705898; color: white; }
.type-ice { background: #98d8d8; color: #333; }

        .rarity-common { 
            border: 1px solid #b0bec5; /* Gris */
            background: linear-gradient(135deg, #f5f5f5 0%, #eceff1 100%);
        }
        .rarity-rare { 
            border: 1px solid #4caf50; /* Vert */
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            
        }
        .rarity-epic { 
            border: 1px solid #9b59b6; /* Violet (coh√©rent avec le recycleur) */
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            
        }
        .rarity-legendary { 
            border: 1px solid #fbc02d; /* Or */
            background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%);
            
            animation: legendary-glow 2s ease-in-out infinite alternate;
        }
		
		.creature-card.shiny {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 25%, #ffd700 50%, #ffed4e 75%, #ffd700 100%);
            background-size: 200% 200%;
            animation: shiny-sparkle 2s ease-in-out infinite, gradient-shift 3s ease infinite;
            border: 1px solid #ffd700;
        }

        

        @keyframes shiny-sparkle {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 
                            0 0 40px rgba(255, 215, 0, 0.4),
                            inset 0 0 20px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 
                            0 0 60px rgba(255, 215, 0, 0.6),
                            inset 0 0 30px rgba(255, 255, 255, 0.5);
            }
        }

        

        .creature-card.shiny::before {
            content: '‚ú®';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 24px;
            animation: sparkle-rotate 4s linear infinite;
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes sparkle-rotate {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.2); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.2); }
        }

        .shiny-label {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 3px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .rarity-label {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 5px;
            display: inline-block;
        }

        .rarity-label.common { background: #6c757d; color: white; }
        .rarity-label.rare { background: #28a745; color: white; }
        .rarity-label.epic { background: #007bff; color: white; }
        .rarity-label.legendary { background: #ffc107; color: #333; }

        .exp-bar {
            width: 100%;
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #845ec2, #b39bc8);
            transition: width 0.3s ease;
        }

        .balls-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
        }

        .ball-item {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .ball-item:hover {
            transform: translateY(-2px);
        }

        

        .save-load-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-save:hover {
            background: #218838;
        }

        .btn-load {
            background: #007bff;
            color: white;
        }

        .btn-load:hover {
            background: #0056b3;
        }

        .btn-reset {
            background: #dc3545;
            color: white;
        }

        .btn-reset:hover {
            background: #c82333;
        }
.btn-buffs {
    background: #17a2b8;
    color: white;
}

.btn-buffs:hover {
    background: #138496;
}
        .btn-stats {
            background: #6f42c1;
            color: white;
        }

        .btn-stats:hover {
            background: #5a32a3;
        }

        .stats-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 1);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .stats-modal.show {
            display: flex;
        }

        .stats-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
	

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }

        .stats-header h2 {
            margin: 0;
            color: #667eea;
        }

        .stats-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .stats-close:hover {
            background: #c82333;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .stat-box.highlight {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-left-color: #ffc107;
        }

        .stat-title {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-number {
            font-size: 28px;
            font-weight: bold;
            color: #333;
        }

        .stat-subtitle {
            font-size: 11px;
            color: #999;
            margin-top: 3px;
        }

        .auto-save-indicator {
            font-size: 12px;
            color: #666;
            margin-left: auto;
            align-self: center;
        }

        h2, h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .damage-fire { color: #ff6b35; font-weight: bold; }
        .damage-water { color: #4dabf7; font-weight: bold; }
        .damage-grass { color: #51cf66; font-weight: bold; }
        .damage-electric { color: #ffd43b; font-weight: bold; }
        .damage-normal { color: #868e96; font-weight: bold; }
		.damage-rock { color: #b8860b; font-weight: bold; }
.damage-flying { color: #87ceeb; font-weight: bold; }
.damage-psychic { color: #ff1493; font-weight: bold; }
.damage-dark { color: #2c1e3f; font-weight: bold; }
.damage-steel { color: #b0b0b0; font-weight: bold; }
.damage-dragon { color: #7038f8; font-weight: bold; }
.damage-fighting { color: #c03028; font-weight: bold; }
.damage-poison { color: #a040a0; font-weight: bold; }
.damage-ground { color: #e0c068; font-weight: bold; }
.damage-bug { color: #a8b820; font-weight: bold; }
.damage-ghost { color: #705898; font-weight: bold; }
.damage-ice { color: #98d8d8; font-weight: bold; }

        .sort-btn {
            padding: 8px 12px;
            border: 1px solid #666;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .sort-btn:hover {
            background: #f0f0f0;
        }

        .sort-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .sort-btn.active::after {
            content: " ‚Üì";
        }

        .sort-btn.active.asc::after {
            content: " ‚Üë";
        }

/* --- Conteneur Nom + Badge (Fixe le nom au centre) --- */
.hud-name-row {
    position: relative;       /* Important : sert de rep√®re au badge */
    display: flex;
    justify-content: center;  /* Centre le nom horizontalement */
    align-items: center;      /* Centre verticalement */
    margin-bottom: 5px;
    height: 24px;             /* Hauteur fixe pour √©viter les sauts */
}

/* Le Nom de l'ennemi */
.hud-enemy .creature-name {
    margin: 0 !important;
    text-align: center;
    z-index: 1;
}

/* --- Indicateur d'efficacit√© (Badge flottant √† droite) --- */
.effectiveness-indicator {
    position: absolute;       /* Sort du flux pour ne pas pousser le nom */
    right: 0;                 /* Coll√© √† droite */
    top: 50%;                 /* Centr√© verticalement */
    transform: translateY(-50%);
    
    font-size: 9px;
    font-weight: 800;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 6px;
    line-height: 1;
    white-space: nowrap;
    display: none;            /* Cach√© par d√©faut */
    opacity: 0.9;
    transition: all 0.3s ease;
}

/* Animation d'apparition */
.effectiveness-indicator.show {
    display: inline-block;
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popIn {
    from { transform: translateY(-50%) scale(0); opacity: 0; }
    to { transform: translateY(-50%) scale(1); opacity: 0.9; }
}

/* Couleurs */
.super-effective {
    background: #dcfce7; color: #166534; border: 1px solid #86efac;
}
.not-effective {
    background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5;
}
.normal-effective {
    display: none !important;
}

       .auto-select-btn {
    padding: 10px 20px;
    background: linear-gradient(135deg, #ffd700, #ffed4e);
    color: #333;
    border: 1px solid #ffd700;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 14px;
    height: 44px;
    flex-shrink: 0;
    /* Supprimez les propri√©t√©s display/margin pour utiliser flex */
}

.auto-select-btn:disabled {
    cursor: not-allowed;
    opacity: 0.5;
}

.auto-select-btn.hidden {
    display: none !important;
}

.auto-select-btn.active {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    border-color: #22c55e;
    color: white;
    box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
}

/* ‚úÖ NOUVEAU : Conteneur pour aligner les boutons horizontalement */
.combat-buttons-container {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    margin-top: 10px;
    flex-shrink: 0;
}

        .upgrades-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #2196f3;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .upgrade-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.3);
        }

        .upgrade-title {
            font-size: 18px;
            font-weight: bold;
            color: #1565c0;
            margin-bottom: 8px;
        }

        .upgrade-description {
            font-size: 14px;
            color: #424242;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .upgrade-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 1);
            border-radius: 8px;
        }

        .upgrade-level {
            font-weight: bold;
            color: #1976d2;
        }

        .upgrade-effect {
            font-size: 12px;
            color: #4caf50;
            font-weight: bold;
        }

        .upgrade-cost {
            font-size: 16px;
            font-weight: bold;
            color: #f57c00;
        }

        .upgrade-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #2196f3, #1976d2);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .upgrade-btn:hover {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            transform: translateY(-1px);
        }

        .upgrade-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .upgrade-btn:disabled:hover {
            background: #ccc;
        }
		

		/* =========================================
   SYST√àME DE QU√äTES (Design Dashboard)
   [TAILLE COMPACTE - AJUSTEMENT TYPO & BOUTON]
   ========================================= */

/* --- 1. CONTENEUR & STATS --- */
.quest-container {
    display: grid;
    grid-template-columns: 1fr; 
    gap: 10px; 
}

.quest-stats {
    display: flex;
    justify-content: space-around;
    padding: 10px; 
    background: white; 
    border-radius: 8px; 
    border: 1px solid #e2e8f0;
    margin-bottom: 12px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.quest-stat {
    text-align: center;
}

.quest-stat-value {
    font-size: 19px; /* Augment√© de 18px */
    font-weight: 800;
    color: #f59e0b;
}

.quest-stat-label {
    font-size: 10px; /* Augment√© de 9px */
    color: #64748b;
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.4px; 
}

/* --- 2. CARTES DE QU√äTES --- */
.quest-card {
    background: white;
    border-radius: 8px; 
    padding: 10px; 
    border: 1px solid #e2e8f0;
    border-left: 3px solid #cbd5e1;
    box-shadow: 0 1px 3px rgba(0,0,0,0.03);
    transition: all 0.1s ease;
    position: relative;
}

.quest-card:hover {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
}

/* √âtats des qu√™tes */
.quest-card.accepted { border-left-color: #3b82f6; background: #f8fafc; } 
.quest-card.completed { 
    border-left-color: #22c55e; 
    background: #f0fdf4; 
    border-color: #bbf7d0; 
    animation: none; 
}

/* En-t√™te de la carte */
.quest-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.quest-title {
    font-weight: 700;
    color: #1e293b;
    justify-content: space-between;
    font-size: 13px; /* Augment√© de 12px */
}

.quest-badge {
    font-size: 9px; /* Augment√© de 8px */
    padding: 1px 6px; 
    border-radius: 8px;
    font-weight: bold;
    text-transform: uppercase;
}
.badge-easy { background: #dcfce7; color: #166534; }
.badge-medium { background: #dbeafe; color: #1e40af; }
.badge-hard { background: #fae8ff; color: #86198f; }
.badge-extreme { background: #ffe4e6; color: #9f1239; }

.quest-description {
    font-size: 11px; /* Augment√© de 10px */
    color: #64748b;
    margin-bottom: 8px;
    line-height: 1.3;
}


/* Barre de progression */
.quest-progress-container {
    display: flex; /* ‚¨ÖÔ∏è Essentiel */
    align-items: center; /* Alignement vertical au centre */
    gap: 6px;
    margin-bottom: 8px;
}

/* Barre de progression */
.quest-progress-bar {
    flex-grow: 1; /* Permet √† la barre de s'√©tendre et de se compresser si besoin */
    height: 6px; 
    background: #e2e8f0;
    border-radius: 3px;
    overflow: hidden;
}

.quest-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #2563eb);
    border-radius: 3px;
    transition: width 0.3s ease;
}
.quest-card.completed .quest-progress-fill {
    background: linear-gradient(90deg, #22c55e, #16a34a);
}

/* Texte de progression */
.quest-progress-text {
    font-size: 10px; 
    font-weight: bold;
    color: #475569;
    min-width: 50px; 
    text-align: right;
    
    /* üõë CORRECTION CL√â üõë */
    white-space: nowrap; /* EMP√äCHE le texte "X / Y" de passer √† la ligne */
    flex-shrink: 0;      /* Emp√™che le navigateur de compresser le texte pour la place */
}

/* Zone de r√©compenses */
.quest-rewards {
    background: rgba(0,0,0,0.03);
    padding: 5px 8px; 
    border-radius: 5px;
    margin-bottom: 8px; 
    font-size: 10px; /* Augment√© de 9px */
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.quest-reward-item {
    font-weight: 600;
    color: #334155;
    display: flex;
    align-items: center;
    gap: 2px;
}

/* Actions (Boutons) */
.quest-actions {
    display: flex;
    gap: 6px;
}

.quest-btn {
    flex: 1;
    padding: 6px; 
    border-radius: 5px; 
    border: none;
    font-weight: 600;
    font-size: 11px; /* Augment√© de 10px (sauf Refuse) */
    cursor: pointer;
    transition: all 0.1s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 3px;
}

.btn-accept { background: #3b82f6; color: white; }
.btn-accept:hover { background: #2563eb; }

/* BOUTON REFUSER / ABANDONNER (Plus petit et plus discret) */
.btn-refuse { 
    background: transparent; 
    color: #ef4444; 
    border: 1px solid #fca5a5; 
    padding: 5px; /* R√©duit le padding de 6px */
    font-size: 9px; /* R√©duit √† 9px (plus petit que le reste) */
}
.btn-refuse:hover { background: #fef2f2; border-color: #ef4444; }

.btn-claim { 
    background: linear-gradient(135deg, #f59e0b, #d97706); 
    color: white; 
    width: 100%;
    box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
    animation: pulse-reward 1.5s infinite;
}
.btn-claim:hover { box-shadow: 0 4px 6px rgba(245, 158, 11, 0.4); } 

@keyframes pulse-reward {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.01); } 
}

/* --- 3. MODALE DE COMPL√âTION --- */
.quest-completion-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 23, 42, 0.8); /* Fond sombre bleut√© */
    z-index: 2000;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
}

.quest-completion-modal.show {
    display: flex;
}

.quest-completion-content {
    background: white;
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 500px;
    width: 90%;
    animation: modal-appear 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

@keyframes modal-appear {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.quest-completion-title {
    font-size: 24px;
    color: #16a34a; /* Vert succ√®s */
    margin-bottom: 10px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.quest-completion-rewards {
    background: #f8fafc;
    padding: 20px;
    border-radius: 12px;
    margin: 20px 0;
    border: 1px solid #e2e8f0;
}

.quest-completion-reward {
    font-size: 16px;
    margin: 8px 0;
    font-weight: 700;
    color: #334155;
}

/* --- 4. TIMER DE QU√äTE --- */
.quest-timer {
    text-align: center;
    /* Le style est g√©r√© inline dans le HTML pour le flex, mais voici la base */
    font-weight: 600;
    color: #64748b;
}

.shop-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 15px;
}

.shop-item {
    background: linear-gradient(135deg, #f3e5f5 0%, #ce93d8 100%);
    padding: 20px;
    border-radius: 12px;
    border: 1px solid #ab47bc;
    box-shadow: 0 4px 15px rgba(171, 71, 188, 0.3);
}

.shop-item-name {
    font-size: 18px;
    font-weight: bold;
    color: #6a1b9a;
    margin-bottom: 10px;
}

.shop-item-description {
    font-size: 13px;
    color: #555;
    margin-bottom: 15px;
    line-height: 1.4;
}

.shop-item-cost {
    font-size: 20px;
    font-weight: bold;
    color: #ffd700;
    margin-bottom: 15px;
}

.shop-buy-btn {
    width: 100%;
    padding: 12px;
    background: linear-gradient(135deg, #ab47bc, #8e24aa);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}

.shop-buy-btn:hover {
    background: linear-gradient(135deg, #8e24aa, #7b1fa2);
}

.shop-buy-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
}

.active-boosts {
    background: rgba(255,255,255,0.9);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
}

.boost-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background: linear-gradient(135deg, #e1f5fe 0%, #81d4fa 100%);
    border-radius: 8px;
    margin-bottom: 10px;
}

.boost-name {
    font-weight: bold;
    color: #0277bd;
}

.boost-timer {
    font-size: 12px;
    color: #666;
}
/* --- INVENTAIRE STYLE "QU√äTES" --- */

.inventory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 12px;
    padding: 5px;
}

/* La Carte (Slot) */
.inventory-slot {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    aspect-ratio: 1 / 1.1;
    position: relative;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.03);
    
    /* Indicateur de Raret√© (Bordure basse) */
    border-bottom-width: 4px;
    border-bottom-style: solid;
}

.inventory-slot:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    z-index: 5;
}

/* Couleurs */
.inventory-slot.rarity-common { border-bottom-color: #94a3b8; }
.inventory-slot.rarity-rare { border-bottom-color: #3b82f6; }
.inventory-slot.rarity-epic { border-bottom-color: #a855f7; }
.inventory-slot.rarity-legendary { border-bottom-color: #f59e0b; }

/* Ic√¥ne */
.item-icon {
    font-size: 36px;
    margin: 8px 0;
    filter: drop-shadow(0 2px 2px rgba(0,0,0,0.05));
    transition: transform 0.2s;
}
.inventory-slot:hover .item-icon { transform: scale(1.15); }

/* Compteur */
.item-count {
    position: absolute;
    top: 6px;
    right: 6px;
    background: #f1f5f9;
    color: #475569;
    border: 1px solid #e2e8f0;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 12px;
}

/* Nom */
.item-name {
    font-size: 11px;
    color: #334155;
    font-weight: 700;
    text-align: center;
    line-height: 1.2;
    width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Badge √âquipement */
.item-type-badge {
    position: absolute;
    top: 6px;
    left: 6px;
    background: #e0e7ff;
    color: #4338ca;
    font-size: 8px;
    font-weight: 800;
    padding: 2px 5px;
    border-radius: 4px;
    text-transform: uppercase;
}

.inventory-slot.is-held-item {
    background-color: #f8fafc;
}

        .stat-boosts-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-boost-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #e1f5fe 0%, #81d4fa 100%);
            border: 1px solid #0277bd;
            border-radius: 8px;
            padding: 10px 15px;
        }

        .stat-boost-name {
            font-weight: bold;
            color: #0277bd;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-boost-timer {
            font-size: 12px;
            color: #666;
            background: rgba(255, 255, 255, 1);
            padding: 4px 8px;
            border-radius: 12px;
        }
        
		/* ‚úÖ STYLES POUR LE MODAL D'√âCLOSION */
#eggHatchContent.shiny {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 25%, #ffd700 50%, #ffed4e 75%, #ffd700 100%);
    background-size: 200% 200%;
    animation: shiny-sparkle 2s ease-in-out infinite, gradient-shift 3s ease infinite;
    border: 2px solid #ffd700;
}

#eggHatchContent.legendary {
    background: linear-gradient(135deg, #fff3cd 0%, #ffd60a 100%);
    box-shadow: 0 0 40px rgba(255, 193, 7, 0.8);
    animation: legendary-glow 2s ease-in-out infinite alternate;
}

.egg-hatch-title {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 15px;
}

.egg-hatch-sprite {
    width: 128px;
    height: 128px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    margin: 10px auto;
    display: block;
    animation: sprite-float 2s ease-in-out infinite;
}

.egg-hatch-stats {
    background: rgba(0,0,0,0.05);
    padding: 15px;
    border-radius: 10px;
    margin: 20px 0;
    text-align: left;
}

.egg-hatch-stats .creature-stats {
    font-size: 14px;
    color: #333;
    line-height: 1.6;
}
/* ‚úÖ FIN DES STYLES D'√âCLOSION */

/* ‚úÖ STYLES POUR LE MODAL DE GESTION */
.creature-modal-grid {
    display: grid;
    grid-template-columns: 200px 1fr;
    gap: 25px;
}

.creature-modal-sprite {
    width: 100%;
    max-width: 192px;
    height: auto;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: rgba(0,0,0,0.05);
    border-radius: 10px;
    border: 1px solid #ddd;
}

.creature-modal-header {
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}

.creature-modal-stats,
.creature-modal-info {
    font-size: 14px;
    line-height: 1.7;
}

.creature-modal-stats strong {
    display: inline-block;
    width: 60px;
}

.creature-modal-info div {
    background: #f4f4f5;
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 8px;
}

.creature-modal-actions {
    grid-column: 1 / -1; /* Prend toute la largeur */
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding-top: 20px;
    border-top: 1px solid #eee;
    margin-top: 20px;
}

.creature-modal-actions .btn {
    flex-grow: 1;
    font-size: 13px;
    padding: 12px 10px;
}
/* ‚úÖ FIN DES STYLES DE GESTION */
/* ‚úÖ S√âLECTEURS MODIFI√âS pour inclure Stockage et Pension */
#teamList, #storageList, #pensionList {
    /* auto-fill est mieux pour le stockage/pension */
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 8px; 
    margin-bottom: 15px;
}

/* On force la grille de l'√©quipe √† 3 colonnes fixes */
#teamList {
    grid-template-columns: repeat(3, 1fr);
}

/* On applique le style de carte aux trois sections */
#teamList .creature-card,
#storageList .creature-card,
#pensionList .creature-card {
    padding: 8px;
    text-align: center;
    cursor: pointer;
    min-height: 110px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease;
}

#teamList .creature-card:hover,
#storageList .creature-card:hover,
#pensionList .creature-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

/* Styles sp√©cifiques (actifs, KO) - s'appliquent surtout √† teamList */
#teamList .creature-card.active {
    border-color: #22c55e;
    background: #e0f8e9;
    box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
}

#teamList .creature-card.fainted {
    filter: grayscale(100%);
    opacity: 0.6;
    background: #f0f0f0;
}

/* Le reste des styles de slot est inchang√© */
.team-slot-sprite {
    width: 64px;
    height: 64px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    margin-bottom: 3px;
}

.team-slot-name {
    font-size: 14px; 
    font-weight: bold;
    color: #333;
    white-space: nowrap; /* Emp√™che le nom de passer √† la ligne */
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

.team-slot-level {
    font-size: 12px;
    color: #666;
}
.team-slot-info {
    font-size: 11px;
    font-weight: bold;
    color: #444;
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-top: 5px;
    padding: 0 5px;
}

/* C'est le "bouton vide" */
.team-slot-empty {
    padding: 10px;
    background: rgba(0, 0, 0, 0.05);
    border: 1px dashed #ccc;
    border-radius: 10px;
    min-height: 120px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    color: #ccc;
    font-weight: bold;
    cursor: default;
}
/* ‚úÖ FIN DES NOUVEAUX STYLES */

/* ‚úÖ NOUVEAUX STYLES POUR LE R√âSUM√â DES TALENTS */

/* Conteneur principal */
#activeTalentsDisplay {
    background: rgba(255, 255, 255, 0.9); /* Fond blanc coh√©rent */
    border-radius: 15px;
    padding: 15px;
    margin-bottom: 20px; /* Espace avant la grille de l'√©quipe */
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

#activeTalentsDisplay h3 {
    margin: 0 0 10px 0;
    color: #333; /* Couleur de titre standard */
    font-size: 18px;
}

/* La nouvelle grille pour les talents */
.talent-summary-grid {
    display: grid;
    /* S'adapte au nombre de talents, avec une taille min/max */
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 8px;
}

/* La "carte" individuelle pour chaque talent */
.talent-chip {
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid;
    background: #fff;
    transition: all 0.2s ease;
}

.talent-chip:hover {
    transform: scale(1.03);
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.talent-chip-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    font-size: 13px;
}

.talent-chip-effect {
    font-size: 12px;
    font-weight: bold;
    color: #22c55e; /* Bonus en vert */
    margin-top: 5px;
}

/* Couleurs bas√©es sur la raret√© du talent */
.talent-chip.epic {
    border-color: #9333ea;
    color: #9333ea;
}

.talent-chip.legendary {
    border-color: #ffd700;
    color: #b45309; /* Couleur fonc√©e pour le texte sur fond clair */
}
/* ‚úÖ FIN DES NOUVEAUX STYLES */




/* Le nouveau HUD */
.battle-hud {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    margin-bottom: 10px;
}

.hud-player, .hud-enemy {
    position: relative; /* Pour le bouton ultime */
}

/* On r√©-applique le style du bouton ultime pour le HUD */
.hud-player .ultimate-btn {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
}

.hud-stats {
    font-size: 14px;
    font-weight: bold;
    color: #333;
    margin-top: 10px;
}



/* On cache l'ancien bouton ultime (qui est maintenant dans le HUD) */
.main-fighter-display #ultimateButton {
    display: none;
}
/* ‚úÖ FIN DES MODIFICATIONS DE SC√àNE */

/* --- COLONNE DROITE (EXTRAS) --- */

.secondary-content {
    /* On s'assure que le conteneur g√®re le flex pour s√©parer Tabs et Contenu */
    display: flex !important;
    flex-direction: column;
    background: #f8fafc; /* Fond tr√®s clair (gris bleut√©) */
    border-left: 1px solid #e2e8f0;
    padding: 0 !important; /* On g√®re le padding √† l'int√©rieur */
    overflow: hidden; /* Emp√™che le scroll global du conteneur */
}

/* Barre des Onglets (Fixe en haut) */
.tabs-container {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    padding: 10px;
    background: white;
    border-bottom: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.02);
    z-index: 5;
    flex-shrink: 0; /* Emp√™che la barre de r√©tr√©cir */
}

/* Boutons d'onglets */
.tab-btn {
    flex: 1 1 auto; /* S'adapte √† la largeur mais peut grandir */
    text-align: center;
    padding: 8px 12px;
    font-size: 12px;
    font-weight: 600;
    color: #64748b;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative; /* Pour le badge */
}

.tab-btn:hover {
    background: #f1f5f9;
    color: #334155;
}

/* Onglet Actif */
.tab-btn.active {
    background: #e0e7ff; /* Bleu tr√®s p√¢le */
    color: #4f46e5; /* Bleu indigo */
    border: 1px solid #c7d2fe;
}

/* Le Badge de notification (petit point rouge) */
.notification-badge {
    top: 2px;
    right: 2px;
    border: 2px solid white; /* Petit contour blanc pour d√©tacher */
}

/* Zone de contenu des onglets */
.tab-content {
    display: none; /* Cach√© par d√©faut */
    padding: 15px;
    overflow-y: auto; /* Scroll vertical UNIQUEMENT ici */
    height: 100%; /* Prend toute la hauteur restante */
    
    /* Animation douce √† l'apparition */
    animation: fadeIn 0.3s ease;
}

.tab-content.active {
    display: block;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Sous-onglets de la boutique (√âpicerie, Jetons...) */
.sub-tabs-container {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid #e2e8f0;
    overflow-x: auto; /* Permet de scroller horizontalement si trop de sous-menus */
    white-space: nowrap;
}

.sub-tab-btn {
    padding: 6px 12px;
    border-radius: 20px; /* Forme de pilule */
    font-size: 11px;
    background: #f1f5f9;
    color: #64748b;
    border: none;
}

.sub-tab-btn.active {
    background: #4f46e5;
    color: white;
    box-shadow: 0 2px 5px rgba(79, 70, 229, 0.3);
}

/* Grille des Upgrades et Objets */
.upgrades-container, .shop-container, .items-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); /* Cartes plus petites et adaptatives */
    gap: 12px;
}

/* Style de la Carte (G√©n√©rique) */
.upgrade-card, .shop-item, .item-card {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}

.upgrade-card:hover, .shop-item:hover, .item-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    border-color: #cbd5e1;
}

/* Titres et Textes dans les cartes */
.upgrade-title, .shop-item-name {
    font-size: 13px;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 5px;
    line-height: 1.3;
}

.upgrade-description, .shop-item-description {
    font-size: 11px;
    color: #64748b;
    margin-bottom: 8px;
    flex-grow: 1; /* Pousse le bouton vers le bas */
}

/* Prix et Boutons */
.upgrade-cost, .shop-item-cost {
    font-size: 12px;
    font-weight: bold;
    color: #d97706; /* Orange/Or */
    margin-bottom: 8px;
}

.upgrade-btn, .shop-buy-btn {
    width: 100%;
    padding: 8px;
    font-size: 11px;
    border-radius: 6px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}


/* Classe pour les images d'objets */
.item-sprite-img {
    width: 32px;
    height: 32px;
    image-rendering: pixelated; /* Garde le look r√©tro net */
    filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.2));
    vertical-align: middle;
}

/* Ajustement pour l'inventaire */
.inventory-slot .item-icon img {
    width: 48px; /* Un peu plus grand dans l'inventaire */
    height: 48px;
}


/* ‚úÖ STYLES POUR LE S√âLECTEUR DE ZONE */
/* ‚úÖ S√âLECTEUR DE ZONE (Une seule ligne forc√©e) */
.zone-selector {
    display: flex;
    flex-direction: row;    /* Force l'alignement horizontal */
    flex-wrap: nowrap;      /* ‚õî INTERDIT le retour √† la ligne */
    align-items: center;    /* Centre verticalement */
    gap: 15px;              /* Espace entre les √©l√©ments */
    
    /* Style "Clean UI" */
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 12px;
    padding: 12px 20px;
    margin-bottom: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    
           
    white-space: nowrap;    
}

.zone-selector label {
    font-weight: 700;
    color: #1e293b;
    font-size: 13px;
    text-transform: uppercase;
    flex-shrink: 0; /* Emp√™che le label d'√™tre √©cras√© */
}

.zone-selector select {
    padding: 6px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-weight: 600;
    color: #1e293b;
    background-color: #f8fafc;
    cursor: pointer;
    
    /* Gestion de la largeur */
    flex-grow: 1;        /* Prend la place disponible */
    min-width: 150px;    /* Largeur minimum */
    max-width: 300px;    /* Largeur maximum pour ne pas √™tre √©norme */
}

.zone-info {
    margin: 0;
    font-size: 13px;
    color: #64748b;
    font-weight: 500;
    
    /* Style de s√©paration */
    border-left: 2px solid #e2e8f0;
    padding-left: 15px;
    flex-shrink: 0; /* Emp√™che les infos d'√™tre √©cras√©es */
}

.zone-progress-bar {
    width: 100%;
    height: 12px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
    margin-top: 8px;
    overflow: hidden;
    border: 1px solid rgba(0,0,0,0.2);
}

.zone-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #ffd700, #f59e0b);
    transition: width 0.5s ease;
}

.zone-progress-text {
    font-size: 12px;
    font-weight: bold;
    margin-top: 4px;
}
/* ‚úÖ FIN DES STYLES DE ZONE */

/* ‚úÖ AJOUTER CE CSS POUR LE "JUICE" DE COMBAT */
@keyframes attack-lunge {
    0% { transform: translateX(0); }
    50% { transform: translateX(20px); }
    100% { transform: translateX(0); }
}

/* Le sprite du joueur (√† gauche) "fonce" vers la droite */
#playerSprite.attack-lunge {
    animation: attack-lunge 0.3s ease-out;
}

/* L'ennemi (√† droite) "fonce" vers la gauche */
#enemySprite.attack-lunge {
    /* On utilise 'reverse' pour qu'il aille dans l'autre sens */
    animation: attack-lunge 0.3s ease-out reverse;
}

@keyframes take-hit {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

.battle-sprite.take-hit {
    animation: take-hit 0.2s ease-in-out;
}

/* ‚úÖ AJOUTER CE STYLE */
.tab-btn, #toggleIcon {
    position: relative; /* N√©cessaire pour positionner le badge */
}
.notification-badge {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 12px;
    height: 12px;
    background-color: #ef4444;
    border-radius: 50%;
    border: 1px solid white;
    animation: pulse-reward 1.5s infinite;
}

/* Style pour le modal des tiers de zone */
#zoneTierModalGrid .creature-card {
    padding: 10px;
    text-align: center;
    background: rgba(0,0,0,0.05);
    border: 1px solid #ddd;
    border-radius: 10px;
}
/* On r√©duit la taille des sprites pour ce modal */
#zoneTierModalGrid .team-slot-sprite {
    width: 64px;
    height: 64px;
    margin-bottom: 5px;
}
#zoneTierModalGrid .team-slot-name {
    font-size: 12px;
    font-weight: bold;
    color: #333;
}

/* 1. La Grille : On serre les colonnes (85px de large au minimum) */
#storageList {
    grid-template-columns: repeat(auto-fill, minmax(85px, 1fr)) !important;
    gap: 6px !important;
}

/* 2. La Carte : On r√©duit les marges internes */
#storageList .creature-card {
    padding: 4px !important;
    min-height: 80px !important; /* Hauteur r√©duite */
}

/* 3. L'Image (Sprite) : On passe de 48px √† 32px */
#storageList .team-slot-sprite {
    width: 36px !important;
    height: 36px !important;
    margin-bottom: 2px !important;
}

/* 4. Les Textes : On r√©duit la police pour que √ßa rentre */
#storageList .team-slot-name {
    font-size: 10px !important;
    margin-bottom: 1px !important;
    width: 100%; /* Assure que l'ellipse fonctionne */
}

#storageList .team-slot-level {
    font-size: 9px !important;
    margin-bottom: 2px !important;
}

#storageList .team-slot-info {
    font-size: 9px !important;
    letter-spacing: -0.5px; /* Resserre un peu les caract√®res */
}

/* Cacher la barre d'XP dans le stockage pour gagner de la place (Optionnel) */
#storageList .exp-bar {
    height: 4px !important;
    margin-top: 2px !important;
}
/* --- AJUSTEMENT SP√âCIFIQUE PENSION --- */

/* Force les sprites de la pension √† 48px */
#pensionList .team-slot-sprite {
    width: 48px !important;
    height: 48px !important;
    margin-bottom: 3px !important;
}

/* Optionnel : Ajuste la grille de la pension pour qu'elle soit adapt√©e √† cette taille */
/* (Un peu plus large que le stockage compact pour a√©rer) */
#pensionList {
    grid-template-columns: repeat(auto-fill, minmax(95px, 1fr)) !important;
}
/* La nouvelle barre de progression pour les tiers */
.tier-progress-bar {
    width: 100%;
    height: 8px;
    background: #ddd;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 5px;
}
.tier-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #22c55e, #16a34a);
    transition: width 0.3s ease;
}
.zone-objective {
    background: rgba(0,0,0,0.1);
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
}
.zone-objective-label {
    font-weight: bold;
    color: #333;
}
.zone-objective-progress {
    font-weight: bold;
    color: #16a34a;
}
.zone-objective-progress.incomplete {
    color: #ef4444;
}
.zone-details-btn {
    font-size: 11px;
    padding: 3px 8px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
.zone-details-btn:hover {
    background: #5a67d8;
}

/* ======================================== */
/* == CSS POUR FEEDBACK DE COMBAT (AJOUT√â) == */
/* ======================================== */


/* --- SC√àNE DE COMBAT (Unifi√©) --- */

/* Le conteneur global */
.battle-display {
    height: 180px; /* Assez haut pour les sprites agrandis */
    background: none; /* Transparent (pas de fond color√©) */
    margin-bottom: 10px;
    padding: 0 20px;
    
    /* Flexbox pour aligner Joueur (Gauche) et Ennemi (Droite) */
    display: flex;
    justify-content: space-between;
    align-items: flex-end; /* Aligne les sprites sur le sol */
}

/* Le conteneur d'une cr√©ature (Joueur ou Ennemi) */
.creature-display {
    position: relative; /* Ancrage pour les Textes Flottants et Boutons */
    /* overflow: hidden;  <-- RETIR√â car cela couperait le bouton Ultime s'il d√©passe */
    text-align: center;
    flex: 1;
    
    /* On s'assure que le sprite est bien cal√© en bas */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
}

/* L'image du Pok√©mon */
.battle-sprite {
    width: 144px; /* Sprites agrandis */
    height: 144px;
    image-rendering: pixelated; /* Rendu net */
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.15)); /* Belle ombre au sol */
    transition: transform 0.1s; /* Pour les animations de coups */
}


/* OPTIMISATION : Style de base plus lisible et centr√© */
/* OPTIMISATION : Style "Clean RPG" (Lisible et Fluide) */
.floating-text {
    position: absolute;
    left: 50%;
    /* Centr√© horizontalement, pas de scale */
    transform: translateX(-50%);
    
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 20px; /* Taille raisonnable */
    font-weight: 700;
    pointer-events: none;
    
    /* Ombre port√©e simple pour le contraste */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    
    z-index: 100;
    will-change: transform, opacity;
    
    /* Animation fluide vers le haut */
    animation: float-fade 1s ease-out forwards;
}

/* NOUVELLE ANIMATION : Mont√©e simple et fondu */
@keyframes float-fade {
    0% {
        opacity: 1;
        transform: translate(-50%, 0);
    }
    20% {
        opacity: 1; /* Reste visible un moment */
        transform: translate(-50%, -15px);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -60px); /* Finit plus haut */
    }
}

/* Couleurs (Plus douces) */
.ft-damage-enemy { color: #ff8a80; }
.ft-damage-player { color: #ff8a80; } /* Rouge clair */
.ft-heal { color: #69f0ae; } /* Vert menthe */
.ft-status { color: #e040fb; } /* Violet */

/* Critique : Juste un peu plus gros, pas de rotation folle */
.ft-crit {
    font-size: 24px;
    color: #ffca28; /* Or */
    text-shadow: 0 0 3px #e65100, 1px 1px 2px black;
    z-index: 101;
}

/* --- CSS pour le Recycleur --- */
.recycler-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    /* On s'assure qu'il utilise bien la hauteur de l'onglet */
    height: 100%; 
    max-height: 330px; /* Hauteur max avant scroll */
}

.recycler-list, .recycler-shop {
    padding: 15px;
    background: rgba(0,0,0,0.05);
    border-radius: 8px;
    overflow-y: auto;
}

.recycler-header {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 2px solid #ddd;
}

.recycler-header .essence-count {
    font-size: 20px;
    color: #a855f7;
}

.recycler-item, .dust-shop-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background: #fff;
    border-radius: 6px;
    margin-bottom: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.recycler-item-name {
    font-weight: bold;
    font-size: 13px;
}
.recycler-item-name .rarity-label {
    font-size: 9px;
    padding: 2px 5px;
    margin-left: 5px;
}

.recycler-btn {
    padding: 5px 10px;
    font-size: 11px;
    background: #a855f7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
}
.recycler-btn:hover {
    background: #9333ea;
}

.dust-shop-item .shop-buy-btn {
    background: #a855f7;
    padding: 8px 12px;
    font-size: 12px;
}
.dust-shop-item .shop-buy-btn:hover {
    background: #9333ea;
}

/* --- NOUVEAU : Animation pour Prestige Pr√™t --- */
@keyframes prestige-glow {
    from { 
        /* Une lueur dor√©e/jaune pour correspondre √† l'√©toile de prestige */
        box-shadow: 0 0 5px rgba(128, 208, 208, 0.2); 
        border-color: #c1e3e3;
    }
    to { 
        box-shadow: 0 0 30px rgba(128, 208, 208, 1.2), 
                    inset 0 0 15px rgba(255, 255, 255, 1); 
        border-color: #8ec2c2;
    }
}

.creature-card.prestige-ready {
    border: 3px solid #80d0d0;
    /* Applique l'animation en boucle */
    animation: prestige-glow 1s ease-in-out infinite alternate;
}

/* Nouveau style pour le conteneur de synergies dans l'en-t√™te */
.synergy-container-header {
    display: flex;
    gap: 8px;
    /* On enl√®ve le fond gris et les bordures de l'ancien style */
    background: transparent;
    padding: 0;
    border: none;
}

/* Modification des badges pour qu'ils soient cliquables */
.synergy-badge {
    cursor: pointer; /* Curseur main */
    transition: transform 0.2s, box-shadow 0.2s;
    user-select: none; /* Emp√™che la s√©lection de texte */
}

.synergy-badge:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    background-color: #f0f9ff; /* L√©g√®re teinte au survol */
}

.synergy-badge:active {
    transform: scale(0.95);
}

/* --- Styles pour le Slot d'Objet --- */
.held-item-slot {
    margin-top: 15px;
    padding: 10px;
    background: #f8f9fa;
    border: 2px dashed #ccc;
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
}

.held-item-slot:hover {
    border-color: #667eea;
    background: #eef2ff;
}

.held-item-slot.equipped {
    border: 2px solid #667eea;
    background: #fff;
}

.item-select-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 10px;
}

.item-select-card {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    text-align: center;
    cursor: pointer;
    font-size: 12px;
}
.item-select-card:hover {
    background: #f0f0f0;
}

/* Grille pour la liste des synergies */
.synergy-list-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
    max-height: 60vh;
    overflow-y: auto;
    padding-right: 5px;
}

/* Carte individuelle de synergie */
.synergy-list-card {
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 15px;
    display: flex;
    align-items: center;
    gap: 15px;
    opacity: 1; /* Gris√© par d√©faut */
    transition: all 0.3s ease;
}

/* Style quand la synergie est active */
.synergy-list-card.active {
    opacity: 1;
    background: linear-gradient(135deg, #e0f2fe 0%, #f0f9ff 100%);
    border: 2px solid #0ea5e9;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.2);
    transform: translateY(-2px);
}

.synergy-list-icon {
    font-size: 32px;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.5);
    border-radius: 50%;
}

.synergy-list-info {
    flex: 1;
}

.synergy-list-title {
    font-weight: bold;
    font-size: 16px;
    color: #333;
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
}

.synergy-list-desc {
    font-size: 12px;
    color: #666;
    line-height: 1.4;
}

.synergy-progress {
    font-size: 11px;
    font-weight: bold;
    color: #888;
    margin-top: 6px;
    text-transform: uppercase;
}

.synergy-list-card.active .synergy-progress {
    color: #0284c7;
}

/* Styles pour le choix du Starter */
.starter-card {
    background: white;
    border-radius: 15px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    border: 3px solid transparent;
}

.starter-card:hover {
    transform: translateY(-10px) scale(1.05);
    box-shadow: 0 20px 40px rgba(0,0,0,0.2);
}

.starter-card:hover h2 {
    transform: scale(1.1);
}

.starter-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100px;
    opacity: 0.2;
    z-index: 0;
}

.starter-bg.grass { background: #4caf50; }
.starter-bg.fire { background: #f44336; }
.starter-bg.water { background: #2196f3; }

.starter-sprite {
    width: 144px;
    height: 144px;
    image-rendering: pixelated;
    position: relative;
    z-index: 1;
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.2));
    transition: transform 0.3s;
}

.starter-card:hover .starter-sprite {
    transform: scale(1.2);
    animation: sprite-float 1s infinite ease-in-out;
}

.starter-card p {
    margin-top: 15px;
    font-size: 13px;
    color: #666;
    line-height: 1.4;
}

/* Styles pour les Buffs de Tour */
.tower-buffs-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin-bottom: 15px;
    padding: 8px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    border: 1px dashed #667eea;
    animation: slideIn 0.3s ease;
}

.tower-buff-chip {
    font-size: 11px;
    padding: 4px 10px;
    border-radius: 15px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    gap: 5px;
}

.buff-atk { background: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
.buff-def { background: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }
.buff-crit { background: #fff8e1; color: #f57f17; border: 1px solid #ffecb3; }
.buff-life { background: #f3e5f5; color: #7b1fa2; border: 1px solid #e1bee7; }
.buff-special { background: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }

/* Raret√© des Reliques */
.relic-card { 
    padding: 15px; border-radius: 10px; background: white; 
    text-align: center; cursor: pointer; position: relative;
    border: 3px solid transparent; transition: transform 0.2s;
}
.relic-card:hover { transform: translateY(-5px); }

.relic-common { border-color: #bdc3c7; background: linear-gradient(to bottom right, #ffffff, #f0f0f0); }
.relic-rare { border-color: #3498db; background: linear-gradient(to bottom right, #ffffff, #e1f5fe); }
.relic-epic { border-color: #9b59b6; background: linear-gradient(to bottom right, #ffffff, #f3e5f5); }
.relic-legendary { 
    border-color: #f1c40f; 
    background: linear-gradient(to bottom right, #fffde7, #fff9c4);
    box-shadow: 0 0 15px rgba(241, 196, 15, 0.4);
}

.relic-badge {
    position: absolute; top: -10px; right: -10px;
    padding: 3px 8px; border-radius: 10px; color: white;
    font-size: 10px; font-weight: bold; text-transform: uppercase;
}
.badge-common { background: #95a5a6; }
.badge-rare { background: #3498db; }
.badge-epic { background: #9b59b6; }
.badge-legendary { background: #f39c12; }

/* --- STYLE DU MODE TOUR (AM√âLIOR√â) --- */

/* --- STYLE DU MODE TOUR (SOBRE & √âPUR√â) --- */

.zone-selector.tower-mode {
    /* Fond : Un gris-bleu nuit profond et mat (Style "Slate") */
    background: #1e293b !important;
    
    /* Bordure : Tr√®s fine et subtile, juste pour d√©finir la forme */
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 10px !important;
    
    /* Ombre : Douce et diffuse pour d√©tacher l'√©l√©ment du fond */
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
    
    /* Mise en page */
    display: flex !important;
    justify-content: center;
    align-items: center;
    padding: 15px !important;
    min-height: 60px;
    
    /* Pas d'animation qui clignote */
    transition: all 0.3s ease;
}

/* On cache proprement les √©l√©ments inutiles */
.zone-selector.tower-mode label,
.zone-selector.tower-mode select,
.zone-selector.tower-mode .zone-progress-bar {
    display: none !important;
}

/* Le Texte : Propre, lisible, moderne */
.zone-selector.tower-mode .zone-info {
    color: #f8fafc !important; /* Blanc cass√© (plus doux que #FFF) */
    
    /* Police syst√®me moderne (sans-serif) */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
    
    font-size: 16px !important;
    font-weight: 600 !important; /* Semi-bold */
    letter-spacing: 1.5px; /* Espacement des lettres pour l'√©l√©gance */
    text-transform: uppercase;
    margin: 0 !important;
    
    /* Pas d'ombres de texte agressives */
    text-shadow: none !important;
}


.squad-selected {
    border: 2px solid #22c55e !important;
    background-color: #dcfce7 !important;
    transform: scale(0.98);
}
.squad-counter {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 10px 20px;
    border-radius: 30px;
    z-index: 10002;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    display: flex;
    gap: 10px;
    align-items: center;
}

/* --- STYLE DES ≈íUFS --- */

.egg-sprite {
    width: 64px;
    height: 64px;
    image-rendering: pixelated; /* Garde le look r√©tro net */
    margin: 0 auto 5px auto;
    display: block;
    transition: transform 0.3s ease;
    animation: egg-float 3s ease-in-out infinite;
}

/* Animation de flottement */
@keyframes egg-float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
}

.ball-item:hover .egg-sprite {
    transform: scale(1.2) rotate(5deg);
    animation: none; /* Pause l'animation au survol */
}

/* --- FILTRES DE COULEUR --- */

/* Common (Vert/Beige de base) : Pas de filtre */

/* Rare (Bleu) */
.egg-filter-rare { 
    filter: hue-rotate(180deg) brightness(1.1); 
}

/* Epic (Violet/Rose) */
.egg-filter-epic { 
    filter: hue-rotate(280deg) saturate(1.2); 
}

/* Legendary (Dor√© Brillant) */
.egg-filter-legendary { 
    filter: sepia(1) saturate(3) hue-rotate(10deg) brightness(1.1) drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
}

/* --- STYLE DE LA CARTE (Rappel) --- */
.ball-item {
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    padding: 15px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    border: 1px solid #e2e8f0;
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative;
    overflow: hidden;
}

.ball-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

/* Bordures color√©es selon la raret√© (optionnel si vous voulez renforcer l'effet) */
.ball-item.rarity-common { border-bottom: 3px solid #b0bec5; }
.ball-item.rarity-rare { border-bottom: 3px solid #3b82f6; }
.ball-item.rarity-epic { border-bottom: 3px solid #a855f7; }
.ball-item.rarity-legendary { border-bottom: 3px solid #f59e0b; }


.custom-tooltip {
    display: none; /* Cach√© par d√©faut */
    position: fixed;
    z-index: 10000; /* Au-dessus de tout */
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #667eea;
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 12px;
    max-width: 250px;
    pointer-events: none; /* La souris passe au travers (tr√®s important) */
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    white-space: pre-line; /* Permet les sauts de ligne avec \n */
}

/* Titre en gras dans l'infobulle */
.tooltip-title {
    font-weight: bold;
    color: #ffd700;
    margin-bottom: 4px;
    font-size: 14px;
    display: block;
}

/* --- STYLE COMPACT POUR LE POK√âDEX --- */
#pokedexList {
    /* Des colonnes plus √©troites pour en mettre plus par ligne */
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)) !important;
    gap: 8px !important;
}

#pokedexList .creature-card {
    padding: 8px !important; /* Moins de marge int√©rieure */
    min-height: auto !important; /* Hauteur flexible */
}

/* Nouvelle classe pour les petites ic√¥nes (remplace les √©mojis) */
.icon-img {
    width: 16px;
    height: 16px;
    vertical-align: middle;
    object-fit: contain;
    display: inline-block;
    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2));
}

/* Pour les types, on les veut un peu plus gros parfois */
.type-icon-img {
    width: 20px;
    height: 20px;
    vertical-align: bottom;
}

/* Ajustement pour le Header (Stats) */
.stat-chip .icon-img {
    width: 24px;
    height: 24px;
}

/* --- CONTENEUR DES TALENTS (Style "Clean UI") --- */
#activeTalentsDisplay {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    padding: 8px 10px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.03);
}

/* Le Titre (tout petit et discret) */
.talents-header-title {
    font-size: 10px;
    font-weight: 700;
    color: #94a3b8; /* Gris clair */
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* La Grille (Flex pour que les tags se suivent) */
.talent-summary-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

/* --- LE BADGE (TAG) --- */
.talent-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    border-radius: 7px; 
    font-size: 11px;
    font-weight: 500;
    transition: all 0.2s ease;
    cursor: help; /* Curseur ? pour indiquer le tooltip */
    
    /* Style par d√©faut (Neutre) */
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    color: #475569;
}

.talent-chip:hover {
    background: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

/* --- VARIANTES SELON RARET√â (Subtiles) --- */
.talent-chip.epic {
    background: #f3e8ff; /* Violet tr√®s p√¢le */
    border-color: #d8b4fe;
    color: #7e22ce;
}

.talent-chip.legendary {
    background: #fef9c3; /* Jaune tr√®s p√¢le */
    border-color: #fde047;
    color: #b45309;
}

/* Le texte du bonus (+50% XP) */
.talent-bonus-text {
    font-size: 10px;
    opacity: 1;
    margin-left: 4px;
    padding-left: 4px;
    border-left: 1px solid rgba(0,0,0,0.1); /* Petite s√©paration */
}




/* Style des barres ATB */
.atb-bar-container {
    width: 100%;
    height: 8px; /* On augmente un peu la hauteur pour √™tre s√ªr de la voir */
    background: #1e293b; 
    margin-top: 4px;
    border-radius: 3px;
    overflow: visible !important;
    border: 1px solid #000; /* Petit bord pour bien d√©limiter */
    position: relative; /* Important */
    z-index: 1;
}

/* Barre ATB (Bleue) */
.atb-fill {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #3b82f6, #60a5fa);
    transform-origin: left;
    transform: scaleX(0); /* Commence vide */
    transition: transform 0.1s linear;
    will-change: transform;
    display: block;
    position: relative;
    z-index: 2;
    min-height: 8px;
}

/* --- BOUTON ULTIME : STYLE BOUTIQUE (UPGRADE) --- */
.ult-rect-btn {
    position: absolute;
    top: 3px;
    right: 0;
    width: 80px;
    height: 16px; /* Un peu plus haut, comme un petit bouton */
    
    /* Fond "Vide" : Clair, comme le fond des cartes d'am√©lioration (#e3f2fd en version orange) */
    background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
    border: 1px solid #ffb300; /* Bordure nette */
    border-radius: 8px;        /* Arrondi "Bouton" (comme la boutique) */
    
    padding: 0;
    overflow: hidden;
    cursor: not-allowed;
    z-index: 10;
    
    /* Ombre color√©e douce */
    box-shadow: 0 2px 5px rgba(255, 179, 0, 0.2);
    transition: all 0.2s ease;
}

/* La barre de remplissage (D√©grad√© vif, comme les boutons d'achat) */
/* Barre Ultime (Orange) */
.ult-rect-fill {
    height: 100%;
    width: 100%; 
    background: linear-gradient(135deg, #ffca28, #ff8f00);
    transform-origin: left;
    transform: scaleX(0); /* Commence vide */
    transition: transform 0.2s ease-out;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    will-change: transform;
}

/* Le texte */
.ult-rect-content {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* Texte fonc√© pour contraste sur fond clair/orange */
    color: #e65100; 
    font-size: 5px;
    font-weight: 300;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    z-index: 2;
    text-shadow: none; /* Pas d'ombre noire, pour un look "flat" propre */
}

/* --- √âTAT PR√äT (READY) --- */
.ult-rect-btn.ready {
    cursor: pointer;
    border-color: #ff6f00;
    /* Lueur externe style "Carte rare" */
    box-shadow: 0 2px 6px rgba(255, 160, 0, 0.4); 
    transform: translateY(0);
}

.ult-rect-btn.ready .ult-rect-fill {
    /* Devient dor√© brillant */
    background: linear-gradient(135deg, #ffd700, #ffb300);
}

.ult-rect-btn.ready .ult-rect-content {
    color: #fff; /* Texte blanc sur fond dor√© */
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.ult-rect-btn.ready:hover {
    transform: translateY(-2px); /* Effet "Lev√©e" au survol */
    box-shadow: 0 4px 8px rgba(255, 160, 0, 0.5);
}

/* --- √âTAT ACTIF (ACTIVE) --- */
.ult-rect-btn.active {
    border-color: #ef4444;
}
.ult-rect-btn.active .ult-rect-fill {
    background: linear-gradient(135deg, #ff5252, #d32f2f); /* Rouge style "Reset" */
    width: 100% !important;
}
.ult-rect-btn.active .ult-rect-content {
    color: white;
}

/* FIX : Emp√™cher le HUD de sauter quand un statut appara√Æt */
.status-icons-container {
    /* 1. On r√©serve une hauteur fixe (taille d'un √©moji + un peu de marge) */
    height: 28px; 
    min-height: 28px;
    
    /* 2. On s'assure que √ßa ne d√©borde pas */
    overflow: hidden; 
    
    /* 3. On centre proprement les ic√¥nes */
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    
    /* 4. Petits ajustements visuels */
    margin-top: 4px;
    font-size: 18px; /* Taille des √©mojis de statut */
}

/* --- UI MODE CAPTURE MANUEL --- */
.capture-layout {
    display: grid;
    grid-template-columns: 1fr 1.2fr; /* Gauche: Cible, Droite: Balles */
    gap: 20px;
}

.capture-target-card {
    background: #f8fafc;
    border-radius: 15px;
    padding: 15px;
    text-align: center;
    border: 2px solid #e2e8f0;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.capture-sprite {
    width: 128px;
    height: 128px;
    image-rendering: pixelated;
    animation: float-capture 3s ease-in-out infinite;
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.2));
}

@keyframes float-capture {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.capture-chance-bar {
    width: 100%;
    height: 6px;
    background: #e2e8f0;
    border-radius: 3px;
    margin-top: 5px;
    overflow: hidden;
}
.capture-chance-fill {
    height: 100%;
    transition: width 0.3s ease;
}

.balls-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}

.ball-select-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
    border-radius: 12px;
    border: 2px solid transparent;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    position: relative;
    overflow: hidden;
}

.ball-select-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    border-color: #cbd5e1;
}

.ball-select-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(1);
}

.ball-icon-large {
    font-size: 28px;
    margin-bottom: 5px;
}

.ball-count-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    background: #1e293b;
    color: white;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: bold;
}

/* --- UI MODULE AUTO-CATCHER (Style Porygon) --- */
.porygon-panel {
    background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
    border: 1px solid #6366f1;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 20px;
    color: white;
    box-shadow: 0 4px 15px rgba(49, 46, 129, 0.4);
    position: relative;
    overflow: hidden;
}

.porygon-panel::before {
    content: '';
    position: absolute;
    top: -50%; left: -50%; width: 200%; height: 200%;
    background: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.03) 10px, rgba(255,255,255,0.03) 20px);
    pointer-events: none;
}

.porygon-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    position: relative;
    z-index: 1;
}

.porygon-status {
    font-size: 10px;
    font-weight: 800;
    text-transform: uppercase;
    background: #10b981;
    color: #064e3b;
    padding: 4px 8px;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);
    animation: blink-status 2s infinite;
}

@keyframes blink-status {
    0%, 100% { opacity: 1; }
    50% { opacity: 1; }
}

/* --- BARRE DE COMMANDEMENT PREMIUM (VERSION FINALE) --- */
.combat-controls-wrapper {
    display: grid;
    grid-template-columns: 80px 1fr 80px; /* Gauche fixe, Centre fluide, Droite fixe */
    gap: 12px;
    margin-top: 15px;
    padding: 8px;
    background: white;
    border-radius: 16px;
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
    border: 1px solid #e2e8f0;
    align-items: stretch;
}

/* Style de base des boutons */
.cmd-btn {
    border: none;
    border-radius: 12px;
    font-weight: 700;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #475569;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    position: relative;
    overflow: hidden;
    height: 100%;
    min-height: 56px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.cmd-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.cmd-btn:active:not(:disabled) {
    transform: translateY(0);
}

.cmd-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(1);
}

.cmd-icon {
    font-size: 20px;
    margin-bottom: 4px;
    filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
}

/* --- VARIANTES DE COULEURS --- */
.cmd-btn.auto-active {
    background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
    color: #15803d;
    border-color: #86efac;
}

.cmd-btn.capture-off {
    background: #f1f5f9;
    color: #94a3b8;
}
.cmd-btn.capture-all {
    background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
    color: #b91c1c;
    border-color: #fca5a5;
}
.cmd-btn.capture-target {
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    color: #1d4ed8;
    border-color: #93c5fd;
}

.cmd-btn.forfeit {
    background: white;
    border: 2px solid #fee2e2;
    color: #ef4444;
}
.cmd-btn.forfeit:hover {
    background: #fef2f2;
    border-color: #ef4444;
}

/* --- NOUVEAU S√âLECTEUR DE CIBLE (GRID) --- */

/* Le Conteneur principal (Cach√© par d√©faut) */
.target-grid-wrapper {
    display: none; 
    background: #f8fafc;
    padding: 8px;
    border-radius: 12px;
    border: 1px solid #cbd5e1;
    margin-top: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    position: relative;
    z-index: 1000;
    
    /* Animation fluide */
    transform-origin: top;
    transition: all 0.3s ease;
}

/* Classe ajout√©e par JS pour afficher */
.target-grid-wrapper.show {
    display: block !important;
    animation: slideOpen 0.3s ease-out;
}

@keyframes slideOpen {
    from { opacity: 0; transform: translateY(-10px) scaleY(0.9); }
    to { opacity: 1; transform: translateY(0) scaleY(1); }
}

/* La Grille elle-m√™me */
.target-grid {
    display: grid;
    /* Magie CSS : Remplit la ligne avec autant de cases de 42px que possible */
    grid-template-columns: repeat(auto-fill, minmax(42px, 1fr));
    gap: 6px;
    max-height: 160px; /* Scroll vertical si trop de pok√©mons */
    overflow-y: auto;
    padding-right: 2px; /* Pour la scrollbar */
}

/* LE SLOT (Le bouton carr√© avec l'image) */
.target-slot {
    width: 100%;
    aspect-ratio: 1; /* Force le carr√© parfait */
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer; /* Main au survol */
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

/* Survol */
.target-slot:hover {
    transform: scale(1.1);
    border-color: #94a3b8;
    z-index: 10;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* √âtat S√âLECTIONN√â (Bleu) */
.target-slot.selected {
    border-color: #3b82f6;
    background: #eff6ff;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Aura bleue */
}

/* L'image du Pok√©mon */
.target-slot img {
    width: 32px;
    height: 32px;
    image-rendering: pixelated; /* Pixel art net */
    pointer-events: none; /* Le clic traverse l'image pour atteindre le bouton */
}

/* Tooltip (Nom au survol) */
.target-slot:hover::after {
    content: attr(data-name);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(15, 23, 42, 0.9);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: bold;
    white-space: nowrap;
    pointer-events: none;
    margin-bottom: 6px;
    z-index: 20;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}



/* Petit badge de token dans le modal */
.prestige-token-badge {
    background: linear-gradient(135deg, #ffd700, #f59e0b);
    color: #fff;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
    margin-left: 5px;
    text-shadow: 0 1px 1px rgba(0,0,0,0.3);
}

/* UI Floating Text (Ressources) */
.ui-floating-text {
    position: fixed; /* Fixe par rapport √† l'√©cran, pas au parent */
    font-weight: 800;
    font-size: 14px;
    pointer-events: none; /* La souris passe √† travers */
    z-index: 10000; /* Au-dessus de tout (Header inclus) */
    animation: ui-float-up 1.5s ease-out forwards;
    text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff; /* Contour blanc pour lisibilit√© */
}

/* Couleurs sp√©cifiques */
.ft-money { color: #16a34a; } /* Vert Dollar */
.ft-token { color: #d97706; } /* Or Jeton */
.ft-shard { color: #a855f7; } /* Violet Shard */

@keyframes ui-float-up {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    20% { transform: translateY(-5px) scale(1.2); } /* Petit pop */
    100% { opacity: 0; transform: translateY(-30px) scale(1); }
}

/* 2. Le Badge lui-m√™me (Rappel pour √™tre s√ªr) */
.atb-stack-badge {
    position: absolute;
    right: 0px;        /* Coll√© √† droite */
    top: -12px;        /* Remont√© au dessus de la barre */
    background: #ef4444;
    color: white;
    font-size: 10px;
    font-weight: 800;
    padding: 2px 5px;
    border-radius: 10px;
    z-index: 999;      /* Au dessus de tout */
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    pointer-events: none; /* Pour ne pas g√™ner les clics */
}
@keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-3px); } }


/* --- MODAL LOGS : STYLE RPG CLAIR --- */

/* 1. La Bo√Æte Principale */
.log-modal-content {
    background: #1e293b; /* Gris-Bleu "Slate 800" (Standard UI) */
    border: 1px solid #475569; /* Bordure plus claire */
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
    width: 90%;
    max-width: 600px;
    border-radius: 12px; /* Coins plus arrondis */
    overflow: hidden; /* Pour que le header ne d√©passe pas */
    display: flex;
    flex-direction: column;
}

/* 2. En-t√™te (Header) */
.modal-header-logs {
    background: #334155; /* Un peu plus clair que le fond */
    padding: 15px 20px;
    border-bottom: 1px solid #475569;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header-logs h2 {
    margin: 0;
    font-size: 18px;
    color: #f1f5f9; /* Blanc cass√© (tr√®s lisible) */
    font-weight: 700;
}

/* 3. Zone de texte (Le Journal) */
.log-console-scroll {
    height: 350px;
    overflow-y: auto;
    
    /* FOND : Beaucoup plus clair que le noir pur */
    background: #0f172a; /* Slate 900 (Fond sombre mais color√©) */
    
    margin: 0;
    padding: 15px 20px;
    
    /* POLICE : On arr√™te le "monospace", on met du texte normal */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: 13px; /* Un peu plus gros pour le confort */
    line-height: 1.6; /* Lignes a√©r√©es */
}

/* 4. Les Lignes de texte */
.log-entry {
    padding: 6px 0;
    border-bottom: 1px solid #1e293b; /* S√©parateur subtil */
    color: #cbd5e1; /* Gris clair (Slate 300) - Tr√®s lisible */
    transition: background 0.2s;
}

.log-entry:hover {
    background: rgba(255,255,255,0.03); /* Petit effet au survol */
}

/* 5. L'heure */
.log-time {
    color: #60a5fa; /* Bleu clair pour l'heure (se distingue bien) */
    font-weight: 600;
    font-size: 0.9em;
    margin-right: 8px;
    display: inline-block;
    min-width: 60px; /* Aligne le texte proprement */
}

/* 6. Footer (Bouton Vider) */
.modal-footer-logs {
    padding: 10px 20px;
    background: #1e293b;
    border-top: 1px solid #334155;
    text-align: right;
}
/* CORRECTIF VISIBILIT√â : On cible l'ID pr√©cis pour √™tre prioritaire */
#logModal {
    display: none; /* Cach√© par d√©faut */
    position: fixed;
    top: 0; 
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85); /* Fond sombre */
    z-index: 10000; /* Au-dessus de ABSOLUMENT TOUT */
    align-items: center;
    justify-content: center;
}

/* Quand la classe 'show' est ajout√©e via JS, on force l'affichage */
#logModal.show {
    display: flex !important; 
}


/* --- ANIMATIONS DE CAPTURE "JUICY" --- */

/* Le conteneur de l'animation (se superpose au sprite) */
.capture-scene {
    position: relative;
    height: 150px;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    overflow: visible;
}


/* L'effet "Aspiration" (Version Prioritaire) */
.capture-sprite.absorbed {
    /* 1. On coupe l'animation de flottement de force */
    animation: none !important; 

    /* 2. L'effet visuel (Silhouette) */
    filter: sepia(1) saturate(5) hue-rotate(-50deg) brightness(1.2) contrast(1.2) !important;
    
    /* 3. La r√©duction physique */
    transform: translateY(50px) scale(0) !important;
    
    /* 4. L'opacit√© finale */
    opacity: 0 !important;
    
    /* 5. LA CL√â DU SUCC√àS : On force la r√®gle de transition */
    /* Cela emp√™che toute autre r√®gle 'transition: all' de casser notre d√©lai */
    transition: 
        transform 0.45s ease-in,       /* Mouvement fluide */
        filter 0.1s linear,            /* Changement couleur imm√©diat */
        opacity 0.1s linear 0.35s !important; /* Disparition retard√©e (FORCE) */
}

/* 1. √âtat par d√©faut (En l'air) : Pivot au CENTRE pour tourner rond */
.flying-ball {
    position: absolute;
    width: 48px;
    height: 48px;
    z-index: 10000;
    transform-origin: center center; /* Rotation propre pendant le lancer */
}

/* 2. √âtat au sol : Pivot en BAS pour les secousses r√©alistes */
.flying-ball.grounded {
    transform-origin: 50% 90%; 
    transform: scale(1);
}

/* Lancer en cloche "Pr√©cision Chirurgicale" (0-20-40-60-80-100) */
@keyframes ball-throw-arc {
    /* 0% : D√âPART (Main du dresseur, bas-gauche) */
    0% {
        transform: translate(-100px, 180px) scale(1.5) rotate(-360deg);
        opacity: 1;
    }
    
    /* 20% : MONT√âE INITIALE (Rapide) */
    20% {
        transform: translate(-70px, 50px) scale(1.4) rotate(-280deg);
    }
    
    /* 40% : APPROCHE DU SOMMET (Ralentissement vertical) */
    40% {
        transform: translate(-30px, -35px) scale(1.3) rotate(-200deg);
    }
    
    /* 60% : APOG√âE (Le point le plus haut, la balle "plane") */
    60% {
        transform: translate(-10px, -50px) scale(1.2) rotate(-120deg);
    }
    
    /* 80% : CHUTE (Acc√©l√©ration vers la cible) */
    80% {
        transform: translate(-5px, -25px) scale(1.1) rotate(-60deg);
    }
    
    /* 100% : IMPACT (Centre de la cible) */
    100% {
        transform: translate(0, 0) scale(1) rotate(0deg);
    }
}

/* On garde ta dur√©e de 15s et on utilise 'linear' car les points cl√©s font d√©j√† la courbe */
.anim-throw { 
    animation: ball-throw-arc 15s linear forwards; 
}

/* Le Rebond (Ajust√© pour le nouveau pivot) */
@keyframes ball-bounce {
    0% { transform: translateY(0) scaleY(1); }
    40% { transform: translateY(-40px) scaleY(0.9); } /* S'√©tire en montant */
    100% { transform: translateY(0) scaleY(1); } /* S'√©crase un peu en atterrissant */
}

@keyframes ball-shake-left {
    0% { transform: rotate(0) scale(1); filter: brightness(1); }
    
    25% { 
        transform: rotate(-35deg) scale(1); 
        filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.8)) sepia(0.5) hue-rotate(-50deg);
    }
    
    50% { transform: rotate(0) scale(1); filter: brightness(1); }
    100% { transform: rotate(0) scale(1); }
}

@keyframes ball-shake-right {
    0% { transform: rotate(0) scale(1); filter: brightness(1); }
    
    25% { 
        transform: rotate(35deg) scale(1); 
        filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.8)) sepia(0.5) hue-rotate(-50deg);
    }
    
    50% { transform: rotate(0) scale(1); filter: brightness(1); }
    100% { transform: rotate(0) scale(1); }
}

/* 3. Succ√®s (Lock) */
@keyframes catch-success-dim {
    0% { filter: brightness(1); transform: scale(1); }
    50% { filter: brightness(0.5); transform: scale(1); }
    100% { filter: brightness(0.5); transform: scale(1); }
}
@keyframes catch-stars {
    0% { transform: scale(0); opacity: 0; }
    50% { transform: scale(1.5); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
}

/* 4. √âchec (Break) */
@keyframes catch-break {
    0% { transform: scale(1); }
    50% { transform: scale(0.4); opacity: 0.5; filter: grayscale(1); }
    100% { transform: scale(0); opacity: 0; }
}

/* Classes utilitaires JS */
.anim-throw { animation: ball-throw-arc 0.6s ease-in forwards; }
.anim-bounce { animation: ball-bounce 0.4s ease-out; }
.anim-shake-1 { animation: ball-shake-left 0.8s ease-in-out; }
.anim-shake-2 { animation: ball-shake-right 0.8s ease-in-out; }
.anim-shake-3 { animation: ball-shake-left 0.8s ease-in-out; }
.anim-lock { animation: catch-success-dim 0.5s forwards; }
.anim-break { animation: catch-break 0.4s ease-out forwards; }

/* --- MODAL HORS-LIGNE (V2) --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(15, 23, 42, 0.85); /* Plus sombre */
    z-index: 2000; display: none;
    justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
}

.modal-content {
    background: #fff; width: 95%; max-width: 450px;
    border-radius: 16px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.3);
    overflow: hidden;
    font-family: 'Segoe UI', sans-serif;
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

/* Header */
.modal-header {
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    padding: 10px 10px; color: white;
    display: flex; justify-content: space-between; align-items: center;
}
.modal-header h2 { margin: 0; font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 8px; }

/* Body */
.modal-body { padding: 0; background: #f8fafc; max-height: 80vh; overflow-y: auto; }

/* R√©sum√© Temps */
.offline-summary {
    background: white; padding: 10px; text-align: center;
    border-bottom: 1px solid #e2e8f0;
}
.offline-time { font-size: 20px; font-weight: 700; color: #1e293b; margin-bottom: 2px; }
.offline-subtitle { color: #64748b; font-size: 13px; }

/* Grille Stats Globales */
.stats-row {
    display: flex; gap: 10px; padding: 15px;
    justify-content: center; background: white;
    border-bottom: 1px solid #e2e8f0;
}
.mini-stat {
    display: flex; flex-direction: column; align-items: center;
    min-width: 70px;
}
.mini-stat .val { font-weight: 700; color: #0f172a; font-size: 16px; }
.mini-stat .lbl { font-size: 10px; color: #94a3b8; text-transform: uppercase; font-weight: 600; }

/* Section Titres */
.section-title {
    padding: 12px 20px 5px; font-size: 12px; font-weight: 700;
    text-transform: uppercase; color: #64748b; letter-spacing: 0.5px;
}

/* Liste des Objets (Scrollable) */
.loot-scroll-area {
    padding: 0 15px; margin-bottom: 15px;
}
.loot-item {
    display: flex; align-items: center;
    background: white; padding: 8px; margin-bottom: 6px;
    border-radius: 8px; border: 1px solid #e2e8f0;
    transition: transform 0.1s;
}
.loot-item:hover { transform: translateX(2px); border-color: #cbd5e1; }




/* Grille Pok√©mon Captur√©s */
.pokemon-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 8px; padding: 0 15px 15px;
}
.poke-capture {
    background: white; border-radius: 8px; border: 1px solid #e2e8f0;
    aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
    position: relative;
}
.poke-capture img { width: 40px; height: 40px; image-rendering: pixelated; }
.shiny-sparkle { position: absolute; top: 2px; right: 2px; font-size: 10px; }

/* Bouton */
.modal-footer { padding: 15px; background: white; border-top: 1px solid #e2e8f0; }
.claim-btn {
    width: 100%; padding: 14px; border: none; border-radius: 10px;
    background: #10b981; color: white; font-weight: 700; font-size: 16px;
    cursor: pointer; transition: background 0.2s;
    box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.2);
}
.claim-btn:hover { background: #059669; transform: translateY(-1px); }

    </style>
	
	<!-- Scripts JavaScript du jeu -->
<script src="constants.js"></script>
<script src="formatters.js"></script>
<script src="pokemonStats.js"></script>
<script src="creature.js"></script>
<script src="gameManager.js"></script>


</head>


<body>
    <div class="game-container">
        <div class="header">
    <div class="header-unified-row">
        
        <div class="combat-stats-group">
            <div class="stat-chip" id="headerStatHP">
                <span class="stat-label">HP :</span>
                <span class="stat-value">0</span>
                <span class="stat-sub-info">(<span id="playerHPGain">+0/s</span>)</span>
            </div>
            <div class="stat-chip" id="headerStatAtk">
                <span class="stat-label">ATK :</span>
                <span class="stat-value">0</span>
                <span class="stat-sub-info">(<span id="playerAttackGain">+0/s</span>)</span>
            </div>
            <div class="stat-chip" id="headerStatDef">
                <span class="stat-label">DEF :</span>
                <span class="stat-value">0</span>
                <span class="stat-sub-info">(<span id="playerDefenseGain">+0/s</span>)</span>
            </div>
            <div class="stat-chip" id="headerStatSpd">
                <span class="stat-label">SPD :</span>
                <span class="stat-value">0</span>
                <span class="stat-sub-info">(<span id="playerSpeedGain">+0/s</span>)</span>
            </div>
        </div>

        <div class="header-separator"></div>

        <div class="resources-group">
            <div class="resource-chip" id="headerStatMoney">
                <span class="resource-icon">üí∞</span>
                <div>
                    <div class="resource-val">0</div>
                    <div class="resource-name">Dollars</div>
                </div>
            </div>
            <div class="resource-chip" id="headerStatTokens">
                <span class="resource-icon">üé´</span>
                <div>
                    <div class="resource-val">0</div>
                    <div class="resource-name">Jetons</div>
                </div>
            </div>
            <div class="resource-chip" id="headerStatMarques">
                <span class="resource-icon">‚ìÇÔ∏è</span>
                <div>
                    <div class="resource-val">0</div>
                    <div class="resource-name">Marques</div>
                </div>
            </div>
        </div>

        <div class="header-separator"></div>

        <div class="header-buttons">
    <button class="btn" onclick="game.openSaveManager()" style="background: #334155; color: white; padding: 0 20px;">
        ‚ò∞ MENU
    </button>
</div>

    </div>
</div>

       <div class="combat-area">
            
            <div class="zone-selector">
                <label for="zoneSelect">Zone de combat :</label>
                <select id="zoneSelect" onchange="game.changeZone(this.value)">
                    </select>
                <div class="zone-info" id="zoneInfo">...</div>
            </div>

            <div id="towerBuffsContainer" class="tower-buffs-container" style="display: none;">
                </div>
            
            
            
            <div class="battle-display" id="battleDisplay">
                <div class="creature-display" id="playerSpriteContainer">
                    <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/25.png" 
                         class="battle-sprite" 
                         id="playerSprite">
                </div>
                
                <div class="creature-display" id="enemySpriteContainer">
                    <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png" 
                         class="battle-sprite" 
                         id="enemySprite">
                </div>
            </div>
            
            <div class="battle-hud" id="battleHud">
  <div class="hud-player" style="position: relative;">
    
    <button id="ultimateButton" class="ult-rect-btn" onclick="game.activateUltimate()" disabled>
        <div class="ult-rect-fill" id="ultFill"></div>
        <div class="ult-rect-content">
            <span id="ultText" style="font-weight:800; font-size:10px;">0%</span>
        </div>
    </button>

    <div class="creature-name" id="playerCreatureName">-</div>
    <div class="creature-level" id="playerCreatureLevel">Niveau -</div>
    
    <div class="health-bar">
        <div class="health-fill" id="playerHealthFill" style="width: 100%"></div>
    </div>

    <div class="atb-bar-container" style="position: relative;">
        
        <div id="playerATB" class="atb-fill"></div>

        <div id="playerATBStack" class="atb-stack-badge" style="display:none;">x2</div>

    </div>

    <div class="health-text" id="playerHealthText">- / -</div>
    <div class="status-icons-container" id="playerStatusIcons"></div>
    <div class="hud-stats" id="playerHudStats"></div>
</div>
    
    <div class="hud-enemy">
        <div class="hud-name-row">
            <div class="creature-name" id="enemyCreatureName">-</div>
            <div id="effectivenessIndicator" class="effectiveness-indicator"></div>
        </div>

        <div class="creature-level" id="enemyCreatureLevel">Niveau -</div>
        
        <div class="health-bar">
            <div class="health-fill" id="enemyHealthFill" style="width: 100%"></div>
        </div>

        <div class="atb-bar-container">
            <div id="enemyATB" class="atb-fill"></div>
        </div>

        <div class="health-text" id="enemyHealthText">- / -</div>
        
        <div class="status-icons-container" id="enemyStatusIcons"></div>
        
        <div class="hud-stats" id="enemyHudStats"></div>
    </div>
</div>
            
           <div class="combat-controls-wrapper">
                
                <button id="autoSelectBtn" class="cmd-btn" onclick="game.toggleAutoSelect()">
                    <span class="cmd-icon">üéØ</span>
                    <span>Auto</span>
                </button>

                <div class="capture-wrapper" style="display:flex; flex-direction:column; width:100%; gap:5px;">
                    
                    <button id="captureModeBtn" class="cmd-btn capture-off" style="width:100%; flex:1;" onclick="game.cycleCaptureMode()">
                        <span id="captureIcon" class="cmd-icon" style="font-size:16px;">üï∏Ô∏è</span>
                        <span id="captureText">Capture : OFF</span>
                    </button>
                    
                    <div id="captureTargetWrapper" class="target-grid-wrapper">
    <div id="captureTargetGrid" class="target-grid">
        </div>
</div>

                </div>

                <button id="forfeitBtn" class="cmd-btn forfeit" onclick="game.forfeitCombat()">
                    <span class="cmd-icon">üè≥Ô∏è</span>
                    <span>Fuir</span>
                </button>
            </div>

            
        </div>

<div class="team-area">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
    <div style="display: flex; align-items: center; gap: 10px;">
        <h2 style="margin: 0;">Equipe Principale (<span id="teamCount">0</span>)</h2>
        
        <button id="synergyBtn" 
                class="zone-details-btn" 
                style="font-size: 12px; background: #8b5cf6; transition: all 0.3s;" 
                onclick="game.openSynergyListModal()">
            ‚ú® Synergies
        </button>
    </div>
    </div>

    <div class="team-list" id="teamList"></div>
            <div id="activeTalentsDisplay"></div>
            
            <h3 style="margin-top: 20px; cursor: pointer;" onclick="togglePension()">
    Pension (<span id="pensionCount">0/0</span>) <span id="pensionToggleIcon">‚ñº</span>
</h3>

<div id="pensionContainer">
    <div style="font-size: 12px; color: #ff69b4; margin-bottom: 10px; font-weight: bold;">
        Les cr√©atures en pension contribuent √† vos stats principales !
    </div>
    <div class="team-list" id="pensionList"></div>
</div>
            
            <h3 style="margin-top: 30px;">Stockage (<span id="storageCount">0</span>)</h3>
            <div class="storage-controls" style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; padding: 15px; background: rgba(0,0,0,0.05); border-radius: 12px; border: 1px solid rgba(0,0,0,0.1);">
    
    <div style="display: flex; gap: 10px;">
        <input type="text" id="storageSearchInput" 
               placeholder="üîç Rechercher par nom..." 
               oninput="game.updateStorageDisplay()" 
               style="flex: 2; padding: 10px; border-radius: 8px; border: 1px solid #ccc;">
        
        <select id="storageTypeFilter" onchange="game.updateStorageDisplay()" 
                style="flex: 1; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-weight: bold; cursor: pointer; background-color: white;">
            <option value="all">Tous les types</option>
            <option value="fire">Feu</option>
            <option value="water">Eau</option>
            <option value="grass">Plante</option>
            <option value="electric">√âlectrik</option>
            <option value="normal">Normal</option>
            <option value="flying">Vol</option>
            <option value="bug">Insecte</option>
            <option value="poison">Poison</option>
            <option value="ground">Sol</option>
            <option value="rock">Roche</option>
            <option value="fighting">Combat</option>
            <option value="psychic">Psy</option>
            <option value="ghost">Spectre</option>
            <option value="ice">Glace</option>
            <option value="dragon">Dragon</option>
            <option value="steel">Acier</option>
            <option value="dark">T√©n√®bres</option>
            <option value="fairy">F√©e</option>
        </select>
    </div>

    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
        <button onclick="game.sortStorage('pokedex')" class="sort-btn" id="sort-pokedex">Pok√©dex</button>
        <button onclick="game.sortStorage('level')" class="sort-btn" id="sort-level">Niveau</button>
        <button onclick="game.sortStorage('rarity')" class="sort-btn" id="sort-rarity">Raret√©</button>
        <button onclick="game.sortStorage('hp')" class="sort-btn" id="sort-hp">HP</button>
        <button onclick="game.sortStorage('attack')" class="sort-btn" id="sort-attack">ATK</button>
        <button onclick="game.sortStorage('defense')" class="sort-btn" id="sort-defense">DEF</button>
        <button onclick="game.sortStorage('speed')" class="sort-btn" id="sort-speed">VIT</button>
        <button onclick="game.sortStorage('total')" class="sort-btn" id="sort-total">Total</button>
        <button onclick="game.sortStorage('shards')" class="sort-btn" id="sort-shards">Shards</button>
    </div>

</div>
            <div class="team-list" id="storageList"></div>
        </div>

       <div class="secondary-content" id="secondaryContent">
    <div class="tabs-container">
        <button class="tab-btn active" onclick="switchTab('boutique')">Boutique</button>
        
        <button class="tab-btn" onclick="switchTab('sacados')">Sac √† dos</button>
        
        <button class="tab-btn" onclick="switchTab('pokedex')">Pok√©dex</button>
        <button class="tab-btn" onclick="switchTab('arenas')">Ar√®nes</button>
        <button class="tab-btn" onclick="switchTab('quests')">Qu√™tes<span id="questsTabBadge"></span></button>
        <button class="tab-btn" onclick="switchTab('tower')">Tour de Combat</button>
        <button class="tab-btn" onclick="switchTab('expeditions')">üó∫Ô∏è Exp√©ditions<span id="expeditionsTabBadge"></span></button>

        </div>

    <div class="tab-content" id="sacadosTab">
    
    <div id="autoCatcherPanel" class="porygon-panel" style="display:none;">
        <div class="porygon-header">
            <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:20px;">ü§ñ</span>
                <div>
                    <div style="font-weight:800; letter-spacing:0.5px;">MODULE PORYGON-Z</div>
                    <div style="font-size:10px; color:#c7d2fe;">Syst√®me de capture automatis√© v3.0</div>
                </div>
            </div>
            <div class="porygon-status">ACTIF</div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
            <div class="switch-container">
                <span style="font-size:11px; font-weight:600;">‚ú® Shinies</span>
                <label class="switch">
                    <input type="checkbox" id="ac-shiny" onchange="game.toggleAutoCatch('shiny')">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span style="font-size:11px; font-weight:600;">üìñ Nouveaux</span>
                <label class="switch">
                    <input type="checkbox" id="ac-new" onchange="game.toggleAutoCatch('new')">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span style="font-size:11px; font-weight:600;">‚ôªÔ∏è Farm (Tout)</span>
                <label class="switch">
                    <input type="checkbox" id="ac-dupe" onchange="game.toggleAutoCatch('dupe')">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>
    <h3>Inventaire d'oeufs (<span id="ballCount">0</span>)</h3>
    <div class="balls-container" id="ballsContainer"></div>

    <hr style="margin: 20px 0;">

    <div id="activeStatBoosts"></div>
    <div id="itemsContainer"></div>
</div>

<div class="tab-content active" id="boutiqueTab">

<div class="sub-tabs-container">
        <button class="sub-tab-btn" onclick="switchShopSubTab('epicerie')">üè™ √âpicerie</button>
        
        <button class="sub-tab-btn active" onclick="switchShopSubTab('pokedollars')">üí∞ Am√©liorations</button>
        <button class="sub-tab-btn" onclick="switchShopSubTab('jetons')">üé´ Boutique Jetons</button>
        <button class="sub-tab-btn" onclick="switchShopSubTab('marques')">‚ìÇÔ∏è Boutique Tour</button>
        <button class="sub-tab-btn" onclick="switchShopSubTab('recycleur')">‚ôªÔ∏è Recycleur</button>
    </div>

<div class="sub-tab-content" id="shop-epicerie">
        <h3>Pok√©Mart</h3>
        <div style="text-align: center; margin-bottom: 20px;">
            <span style="font-size: 24px; font-weight: bold; color: #333;">
                Porte-monnaie : üí∞ <span id="martMoney">0</span>
            </span>
        </div>
        <div class="shop-container" id="martContainer">
            </div>
    </div>
	
    <div class="sub-tab-content active" id="shop-pokedollars">
        <h3>Am√©liorations</h3>
        <div class="upgrades-container" id="upgradesContainer">
            </div>
    </div>

    <div class="sub-tab-content" id="shop-jetons">
        <h3>Boutique Sp√©ciale</h3>
        <div style="text-align: center; margin-bottom: 20px;">
            <span style="font-size: 24px; font-weight: bold; color: #ffd700;">
                üí∞ <span id="shopTokens">0</span> Jetons
            </span>
        </div>
        <div class="shop-container" id="shopContainer">
            </div>
    </div>

    <div class="sub-tab-content" id="shop-marques">
        <h4 style="margin-top: 0;">Boutique de la Tour</h4>
        <p style="color: #666; margin-bottom: 15px;">Utilisez vos Marques du Triomphe pour acheter des am√©liorations uniques !</p>
        <div class="shop-container" id="towerShopContainer">
            </div>
    </div>
<div class="sub-tab-content" id="shop-recycleur">
        <div class="recycler-header">
            Total : <span class="essence-count" id="essenceDustCount">0</span> üí† Poussi√®re d'Essence
        </div>

        <div class="recycler-container">
            <div class="recycler-list" id="recyclerShardList">
                <div class="recycler-header">Vos Shards</div>
                </div>
            <div class="recycler-shop" id="recyclerDustShop">
                <div class="recycler-header">Boutique de Poussi√®re</div>
                </div>
        </div>
    </div>
</div> 
 

    <div class="tab-content" id="pokedexTab">
    <h3>Pok√©dex (<span id="pokedexCount">0</span>/<span id="pokedexTotal">0</span> d√©couverts)</h3>
    
    <div style="margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 10px;">
        <button onclick="game.sortPokedex('id')" class="sort-btn" id="sort-pokedex-id">Num√©ro</button>
        <button onclick="game.sortPokedex('name')" class="sort-btn" id="sort-pokedex-name">Nom</button>
        <button onclick="game.sortPokedex('rarity')" class="sort-btn" id="sort-pokedex-rarity">Raret√©</button>
        <button onclick="game.sortPokedex('count')" class="sort-btn active" id="sort-pokedex-count">Obtenus</button>
        <button onclick="game.sortPokedex('type')" class="sort-btn" id="sort-pokedex-type">Type</button>
    </div>

    <div class="team-list" id="pokedexList"></div>
</div>

    <div class="tab-content" id="questsTab">
        <div class="quest-stats">
            <div class="quest-stat">
                <div class="quest-stat-value" id="questTokens">0</div>
                <div class="quest-stat-label">Jetons</div>
            </div>
            <div class="quest-stat">
                <div class="quest-stat-value" id="questCompleted">0</div>
                <div class="quest-stat-label">Termin√©es</div>
            </div>
        </div>

        <div class="active-boosts" id="activeBoosts" style="display: none;">
            <h4 style="margin-bottom: 10px; color: #d97706;">‚ö° Boosts Actifs</h4>
            <div id="boostsList"></div>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; margin-top: 20px;">
            <h3>Qu√™tes du Jour (<span id="questCount">0</span>/10)</h3>
            <div class="quest-timer" id="questTimer" style="font-size: 12px; background: #e2e8f0; padding: 5px 10px; border-radius: 15px;">
                Prochaine : <strong id="nextQuestTime">--:--</strong>
            </div>
        </div>
        
        <div class="quest-container" id="questContainer">
            </div>

        <h3 style="margin-top: 40px; border-top: 2px solid #e2e8f0; padding-top: 20px;">
            üèÜ Succ√®s Permanents (<span id="achievementsCount">0</span>/<span id="achievementsTotal">0</span>)
        </h3>
        <div class="quest-container" id="achievementsContainer">
            </div>
    </div>

    <div class="tab-content" id="towerTab">
    <h3>Tour de Combat</h3>
    <div style="text-align: center; margin-bottom: 20px;">
        <p>Affrontez des dresseurs de plus en plus forts sans vous soigner pour gagner des r√©compenses exclusives !</p>
        <div style="margin: 15px 0; font-size: 18px;">
            <div>Record Personnel : √âtage <strong id="towerRecord">0</strong></div>
            <div>üéüÔ∏è Tickets de Combat : <strong id="combatTickets">0</strong></div>
            <div>‚ìÇÔ∏è Marques du Triomphe : <strong id="marquesDuTriomphe">0</strong></div>
        </div>
        <button class="btn btn-save" onclick="game.startTowerRun()">Lancer l'ascension (co√ªte 1 ticket)</button>
    </div>
    </div>


    <div class="tab-content" id="expeditionsTab">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin:0;">Carte des Exp√©ditions</h3>
        <div style="display:flex; gap:10px; align-items:center;">
            <button class="zone-details-btn" style="background: #8b5cf6; font-size:12px; padding:5px 10px;" onclick="game.showMasteryModal()">
                üìú Ma√Ætrises
            </button>
            
            <span style="font-size: 12px; background: #e2e8f0; padding: 5px 10px; border-radius: 15px;">
                Slots : <strong id="expeditionSlots">1/1</strong>
            </span>
        </div>
    </div>

    <h4 style="color: #666; margin-bottom: 10px;">Missions Disponibles</h4>
    <div class="quest-container" id="availableExpeditionsList">
        </div>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h4 style="color: #666; margin-bottom: 10px;">En cours</h4>
    <div class="quest-container" id="activeExpeditionsContainer">
        <p style="color: #666;">Aucune exp√©dition en cours...</p>
    </div>
</div>

    
<div class="tab-content" id="arenasTab">
    <h3>Ar√®nes de Combat</h3>
    <div style="margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #ffd700, #ffed4e); border-radius: 10px;">
        <h4 style="margin: 0 0 10px 0;">Talents de Compte D√©bloqu√©s</h4>
        <div id="badgesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
    </div>
    <div class="upgrades-container" id="arenasContainer"></div>
</div>



</div> <!-- ‚úÖ FERMETURE DE secondaryContent -->

<!-- ‚úÖ BOUTON EXTRAS (EN DEHORS DE secondaryContent) -->
<button style="position: fixed; bottom: 20px; right: 20px; padding: 15px 25px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 50px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 100;" onclick="toggleSecondaryContent()">
    <span id="toggleIcon">‚ñ≤<span id="extrasBadge"></span></span> Extras
</button>

</div> <!-- ‚úÖ FERMETURE DE game-container -->

<!-- ‚úÖ MODALS -->
<div class="quest-completion-modal" id="questCompletionModal">
    <div class="quest-completion-content">
        <div class="quest-completion-title">üéâ QU√äTE TERMIN√âE ! üéâ</div>
        <div id="questCompletionInfo"></div>
        <div class="quest-completion-rewards" id="questCompletionRewards"></div>
        <button id="claimQuestBtn" class="btn btn-save" style="font-size: 18px; padding: 15px 30px;">
            R√©cup√©rer les R√©compenses
        </button>
    </div>
</div>

<div class="quest-completion-modal" id="towerCompletionModal">
    <div class="quest-completion-content">
        <div class="quest-completion-title">üèÜ FIN DE L'ASCENSION üèÜ</div>
        <div id="towerCompletionInfo"></div>
        <div class="quest-completion-rewards" id="towerCompletionRewards"></div>
        <button id="closeTowerBtn" class="btn btn-save" style="font-size: 18px; padding: 15px 30px;">
            Fermer
        </button>
    </div>
</div>



<script>
       
                
   

class ToastManager {
    constructor() {
        // ‚úÖ AJOUTER : Cr√©er le container s'il n'existe pas
        this.container = document.getElementById('toastContainer');
        if (!this.container) {
            this.container = document.createElement('div');
            this.container.id = 'toastContainer';
            this.container.className = 'toastContainer';
            document.body.appendChild(this.container);
        }
        
        this.toasts = [];
        this.maxToasts = 5; // Maximum de toasts affich√©s simultan√©ment
    }
    
    show(options) {
        const {
            title = '',
            message = '',
            type = 'info', // success, info, warning, error, shiny, legendary
            icon = this.getDefaultIcon(type),
            duration = 3000,
            closable = true
        } = options;
        
        // Limiter le nombre de toasts
        if (this.toasts.length >= this.maxToasts) {
            this.removeOldest();
        }
        
        // Cr√©er le toast
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        
        toast.innerHTML = `
            <div class="toast-icon">${icon}</div>
            <div class="toast-content">
                ${title ? `<div class="toast-title">${title}</div>` : ''}
                ${message ? `<div class="toast-message">${message}</div>` : ''}
            </div>
            ${closable ? '<div class="toast-close">√ó</div>' : ''}
        `;
        
        // Ajouter au container
        this.container.appendChild(toast);
        this.toasts.push(toast);
        
        // √âv√©nement de fermeture
        if (closable) {
            const closeBtn = toast.querySelector('.toast-close');
            closeBtn.addEventListener('click', () => this.remove(toast));
        }
        
        // Fermer au clic sur le toast
        toast.addEventListener('click', (e) => {
            if (!e.target.classList.contains('toast-close')) {
                this.remove(toast);
            }
        });
        
        // Auto-fermeture apr√®s dur√©e
        if (duration > 0) {
            setTimeout(() => this.remove(toast), duration);
        }
        
        return toast;
    }
    
    remove(toast) {
        if (!toast || !toast.parentElement) return;
        
        toast.classList.add('removing');
        
        setTimeout(() => {
            if (toast.parentElement) {
                toast.parentElement.removeChild(toast);
            }
            this.toasts = this.toasts.filter(t => t !== toast);
        }, 300);
    }
    
    removeOldest() {
        if (this.toasts.length > 0) {
            this.remove(this.toasts[0]);
        }
    }
    
    removeAll() {
        this.toasts.forEach(toast => this.remove(toast));
    }
    
    getDefaultIcon(type) {
        const icons = {
            success: '‚úì',
            info: '‚Ñπ',
            warning: '‚ö†',
            error: '‚úï',
            shiny: '‚ú®',
            legendary: 'üëë'
        };
        return icons[type] || '‚Ñπ';
    }
    
    // M√©thodes raccourcies
    success(title, message, duration) {
        return this.show({ title, message, type: 'success', duration });
    }
    
    info(title, message, duration) {
        return this.show({ title, message, type: 'info', duration });
    }
    
    warning(title, message, duration) {
        return this.show({ title, message, type: 'warning', duration });
    }
    
    error(title, message, duration) {
        return this.show({ title, message, type: 'error', duration });
    }
    
    shiny(title, message, duration = 5000) {
        return this.show({ title, message, type: 'shiny', duration });
    }
    
    legendary(title, message, duration = 5000) {
        return this.show({ title, message, type: 'legendary', duration });
    }
}

// Cr√©er l'instance globale
const toast = new ToastManager();




         
			
			

       
		

/**
 * G√©n√®re une cl√© de shard (bas√©e sur la famille UNIQUEMENT)
 */
function getShardKey(creatureName, rarity) {
    
    const familyName = EVOLUTION_FAMILIES[creatureName] || creatureName;
      
    return familyName;
} 
class Quest {
    constructor(template, multiplier = 1, difficulty = 'EASY') {
        this.id = Date.now() + Math.random();
        this.title = template.title;
        this.description = template.desc;
        this.target = Array.isArray(template.target) 
            ? template.target[Math.floor(Math.random() * template.target.length)] 
            : template.target;
        this.progress = 0;
        this.current = 0;
        this.completed = false;
        this.claimed = false;
        this.accepted = false;
        this.trackingKey = template.trackingKey;
        this.difficulty = difficulty;
        this.special = template.special || null;
        this.startTime = Date.now();
        this.startValue = 0;
        this.questType = null; // Sera d√©fini lors de la g√©n√©ration
        
        // Param√®tres sp√©ciaux
        this.specialParams = {};
        
        // Remplacer les variables dans la description
        if (template.special === 'monotype') {
            const types = Object.values(TYPES);
            this.specialParams.requiredType = types[Math.floor(Math.random() * types.length)];
            this.description = this.description.replace('{type}', this.specialParams.requiredType);
        }
        
        if (template.time) {
            this.specialParams.timeLimit = Array.isArray(template.time) 
                ? template.time[Math.floor(Math.random() * template.time.length)]
                : template.time;
            this.description = this.description.replace('{time}', this.specialParams.timeLimit);
        }
        
        if (template.special === 'zone_unlock') {
            this.specialParams.targetZone = Math.floor(Math.random() * 5) + 2; // Zones 2-6
            this.description = this.description.replace('{zone}', this.specialParams.targetZone);
        }
        
        this.description = this.description.replace('{target}', this.target);
        
        // Calculer les r√©compenses
        const diffMultiplier = QUEST_DIFFICULTIES[difficulty].multiplier;
        this.rewards = this.calculateRewards(diffMultiplier * multiplier);
    }
    
 calculateRewards(multiplier) {
    const base = {
        pokedollars: Math.floor(100 * multiplier),
        tokens: Math.floor(1 * multiplier),
        eggs: {}
    };
    
    // ‚úÖ CORRECTION : Utiliser les constantes RARITY au lieu de strings
    // R√©compenses bonus selon difficult√©
    if (this.difficulty === 'MEDIUM') {
        base.eggs[RARITY.RARE] = 1;  // Au lieu de base.eggs.RARE = 1
    } else if (this.difficulty === 'HARD') {
        base.eggs[RARITY.EPIC] = 1;  // Au lieu de base.eggs.EPIC = 1
        base.tokens += 2;
    } else if (this.difficulty === 'EXTREME') {
        base.eggs[RARITY.LEGENDARY] = 1;  // Au lieu de base.eggs.LEGENDARY = 1
        base.tokens += 5;
        base.pokedollars *= 2;
    }
    
    return base;
}
    updateProgress(value) {
        this.current = Math.min(value, this.target);
        this.progress = this.current;
        
        if (this.current >= this.target && !this.completed) {
            this.completed = true;
            return true;
        }
        return false;
    }
    
    getProgressPercent() {
        return Math.min(100, (this.current / this.target) * 100);
    }
}

/**
 * R√©cup√®re l'URL du sprite (Blind√© contre les crashs)
 */
function getPokemonSpriteUrl(name, shiny, back = false) {
    // S√âCURIT√â : Si le nom est vide ou undefined, on renvoie une image "Bug" ou un oeuf
    if (!name) {
        // Image de "Substitute" (le petit monstre vert) ou un point d'interrogation
        return "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/substitute.png";
    }

    // Nettoyage du nom pour l'API (minuscule, pas d'espaces, cas sp√©ciaux)
    let cleanName = name.toLowerCase()
        .replace(" ", "-")
        .replace("‚ôÄ", "-f")
        .replace("‚ôÇ", "-m")
        .replace(".", "")
        .replace("'", "");

    // Cas sp√©ciaux pour les sprites API
    if (cleanName === "nidoran") cleanName = "nidoran-m"; // Par d√©faut
    if (cleanName === "mr-mime") cleanName = "mr-mime";
    if (cleanName === "mime-jr") cleanName = "mime-jr";
    if (cleanName === "farfetchd") cleanName = "farfetchd"; // Parfois sans tiret

    // Construction URL
    const baseUrl = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon";
    const shinyPath = shiny ? "/shiny" : "";
    const backPath = back ? "/back" : "";
    
    // Il faut l'ID pour √™tre s√ªr, mais si on n'a que le nom, on essaie de mapper
    // Si tu as POKEMON_SPRITE_IDS, utilise-le ici :
    if (typeof POKEMON_SPRITE_IDS !== 'undefined' && POKEMON_SPRITE_IDS[name]) {
        return `${baseUrl}${backPath}${shinyPath}/${POKEMON_SPRITE_IDS[name]}.png`;
    }

    // Fallback : On esp√®re que le nom correspond (souvent le cas)
    // Note : Pour une s√©curit√© totale, il faudrait un mapping ID complet.
    return `${baseUrl}${backPath}${shinyPath}/${cleanName}.png`; // Risqu√© si cleanName n'est pas un ID, mais l'API g√®re mal les noms directs parfois.
}



        
		class Game {
    constructor() {
        this.playerTeam = [];
        this.storage = [];
        this.pension = [];
        this.playerMainStats = { hp: 0, attack: 0, defense: 0, speed: 0 };
        this.playerTeamStats = { hp: 0, attack: 0, defense: 0, speed: 0 };
        this.eggs = {
            [RARITY.COMMON]: 0,
            [RARITY.RARE]: 0,
            [RARITY.EPIC]: 0,
            [RARITY.LEGENDARY]: 0
        };
        this.shards = {};
        this.pokedollars = 0;
        this.talentRerolls = 0; // Cristaux de R√©initialisation (al√©atoire)
        this.talentChoices = 0; // Orbes de Ma√Ætrise (au choix)
		this.essenceDust = 0;
        this.pokedex = {};
		this.hasAutoCatcher = false; // D√©bloqu√© ou non
        this.autoCatcherSettings = {
            catchNew: false,   // Capturer les non-d√©couverts ?
            catchShiny: true,  // Capturer les Shinies ? (OUI par d√©faut !)
            catchDupe: false   // Capturer les doublons (Farm de Shards) ?
        };
		this.pokedexSortBy = 'id';   // Crit√®re par d√©faut
this.pokedexSortOrder = 'asc'; // Ordre par d√©faut
		this.captureMode = 0; // 0 = OFF, 1 = ALL, 2 = TARGET
		this.captureTargets = null; // Nom du Pok√©mon cibl√©
        this.zoneProgress = {};
        Object.keys(ZONES).forEach(zoneId => {
            this.zoneProgress[zoneId] = {
                pokemonTiers: {}, // (Anciennement enemyTiers)
                bossesDefeated: 0,
                epicsDefeated: 0
            };
        });
        this.quests = [];
		this.pendingRoamer = null;
		this.pauseOnRare = true; // Par d√©faut : On s'arr√™te (S√©curit√©)
		this.achievements = {};	
this.tooltipTimer = null; // Stocke le timer
this.TOOLTIP_DELAY = 200; // D√©lai en millisecondes (0.2s) - Modifiez ici !
		this.sessionStats = {
    combatsWon: 0,
    eggsOpenedThisRush: 0,
    lastEggOpenTime: 0,
    currentWinStreak: 0,
    perfectWinsStreak: 0,
    combatStartTime: 0,
    lastSpendTime: Date.now(),
    statusInflictedTypes: new Set()
};
        this.questTokens = 0;
        this.questsCompleted = 0;
        this.nextQuestTimer = 0;
        this.lastQuestUpdate = Date.now();
        this.activeBoosts = [];
        this.permanentBoosts = { xp: 0, pensionSlots: 0 };
		this.activeExpeditions = []; // Stocke les missions en cours
        this.maxExpeditionSlots = 1;
		
		// ‚úÖ NOUVEAU : Inventaire d'objets
    this.items = {};  // { item_key: quantity }
    
    // ‚úÖ NOUVEAU : Vitamines actives (permanent)
    this.activeVitamins = {
        hp: 0,       // Bonus permanent de gain HP/sec
        attack: 0,   // Bonus permanent de gain ATK/sec
        defense: 0,  // Bonus permanent de gain DEF/sec
        speed: 0,    // Bonus permanent de gain SPD/sec
        all: 0       // Bonus permanent universel
    };
    
	this.activeExpeditions = []; 
this.maxExpeditionSlots = 3; 

this.availableExpeditions = []; // ‚úÖ Demand√© : Stocke les missions g√©n√©r√©es
this.maxAvailableExpeditions = 6; // ‚úÖ Demand√© : 6 en attente max
this.expeditionTimer = 0; // Temps restant avant la prochaine
this.EXPEDITION_GEN_TIME = 300000; // Temps de g√©n√©ration (ex: 5 minutes = 300000ms)

    // ‚úÖ NOUVEAU : Boosts de stats actifs (temporaire)
    this.activeStatBoosts = [];  // [{ stat, value, endTime }, ...]
        
        // ‚úÖ Propri√©t√©s pour le game loop optimis√©
        this.lastDisplayUpdate = 0;
        this.gameLoopId = null;
        
        // ‚úÖ Variables pour la Tour de Combat
        this.combatTickets = 0;
        this.marquesDuTriomphe = 0; // Notre nouvelle monnaie
        this.towerRecord = 0;
        this.towerState = {
            isActive: false,
            currentFloor: 0,
            currentEnemyIndex: 0,
            enemyTeam: []
        };

this.isPensionCollapsed = false; // Par d√©faut, la pension est visible
        this.upgrades = {
            critMastery: { level: 0, baseCost: 300, costMultiplier: 1.6, name: "Ma√Ætre Critique", description: "Augmente la chance de coup critique de l'√©quipe", effect: "+1% Chance par niveau", maxLevel: 10 },
            expBoost: { level: 0, baseCost: 150, costMultiplier: 1.6, name: "Boost d'Experience", description: "Augmente l'XP gagnee par l'equipe", effect: "+10% XP par niveau", maxLevel: 15 },
            eggDrop: { level: 0, baseCost: 200, costMultiplier: 1.7, name: "Chasseur d'Oeufs", description: "Augmente les chances de drop d'oeufs", effect: "+0.1% chance par niveau", maxLevel: 20 },
            staminaRegen: { level: 0, baseCost: 120, costMultiplier: 1.5, name: "Regeneration Rapide", description: "Augmente la vitesse de regeneration d'endurance", effect: "-0.2s par niveau", maxLevel: 12 },
            shardBonus: { level: 0, baseCost: 250, costMultiplier: 1.8, name: "Collecteur de Shards", description: "Chance d'obtenir des shards bonus", effect: "+2% chance par niveau", maxLevel: 10 },
            pension: { level: 0, baseCost: 500, costMultiplier: 2.5, name: "Pension Pokemon", description: "Debloque des emplacements pour des creatures qui contribuent aux stats", effect: "+1 slot et +1% transfert de stats par niveau", maxLevel: 20 },
            respawn: { level: 0, baseCost: 500, costMultiplier: 1.5, name: "Fast Respawn ", description: " R√©dui le d√©lai de r√©apparation des adversaires! ", effect: " - 50 ms par niveau", maxLevel: 15 },
            recycle: { level: 0, baseCost: 500, costMultiplier: 1.5, name: "Recycleur de balls ", description: " Obtiens la probabilit√© de conserver la ball lanc√©e ! ", effect: " 2.5% par niveau", maxLevel: 10 }
        };
        

        
        
        this.currentEnemy = null;
        this.currentPlayerCreature = null;
        this.activeCreatureIndex = 0;
        this.sortBy = 'none';
        this.sortOrder = 'desc';
        this.autoSelectEnabled = false;
        this.badges = {};
        Object.keys(ACCOUNT_TALENTS).forEach(talentKey => {
            this.badges[talentKey] = false;
        });

        this.arenaState = {
            active: false, arenaId: null, championTeam: [], currentChampionIndex: 0, startTime: 0, maxDuration: 90000, playerKOCount: 0
        };
        this.recentCombatDurations = [];
        
        this.combatState = 'waiting';
        this.lastCombatTime = 0;
        this.combatStartTime = 0;
        
        // TEMPS D'ATTENTE ENTRE DEUX COMBATS (Respawn)
        // C'est le temps pour looter, sauvegarder, et trouver le prochain ennemi.
        // 1000ms est bien. Si vous le baissez trop (ex: 100ms), le jeu peut para√Ætre √©pileptique.
        this.combatCooldown = 200; 
        this.baseCombatCooldown = 200; // Sert de r√©f√©rence pour les upgrades (si vous gardez l'upgrade de r√©duction de temps d'attente)

        // TEMPS DE R√âCUP√âRATION (Game Over)
        // 4 secondes pour punir la d√©faite, c'est tr√®s bien. √áa donne du poids √† la mort.
        this.deathCooldown = 4000; 

        // ANIMATION DE D√âBUT ("Ready... Fight!")
        // 500ms est parfait. Assez pour voir le nom de l'ennemi, assez court pour ne pas frustrer en farming.
        this.combatStartDelay = 100;

        // ‚úÖ LE PLUS IMPORTANT : LE M√âTRONOME (ATB)
        // C'est le d√©lai minimum entre deux coups d'affil√©e.
        // 500ms = 2 attaques par seconde max visuellement.
        // C'est ce qui rend le combat "lisible" et emp√™che les bugs de calcul.
        this.combatTurnDelay = 250;;     // 250 entre chaque tour
this.lastCombatTurnTime = 0;    // Timestamp du dernier tour
        
        this.enemiesByZone = {};
        this.lastStaminaRegen = 0;
        
       this.stats = {
            // --- COMBATS ---
            combatsWon: 0,          // (Anciennement totalWins)
            combatsLost: 0,
            bossDefeated: 0,        // (Anciennement bossKilled)
            epicDefeated: 0,        // (Anciennement epicKilled)
            totalDamageDealt: 0,
            totalDamageTaken: 0,

            // --- COLLECTION ---
            creaturesObtained: 0,
            shiniesObtained: 0,     // (Anciennement shiniesCaught)
            eggsOpened: 0,
            evolutionsCount: 0,
            
            // ‚úÖ NOUVEAUX TRACKERS (Sp√©cial Succ√®s)
            perfectIvCount: 0,      // Nombre de 100% IV captur√©s
            perfectShinyCount: 0,   // Nombre de Shiny 100% IV captur√©s
            highestLevelReached: 0, // Niveau max atteint par un Pok√©mon

            // --- √âCONOMIE & PROGRESSION ---
            totalPokedollarsEarned: 0, // (Anciennement totalGoldEarned)
            prestigeCount: 0,          // (Anciennement prestigesDone)
            upgradesPurchased: 0,      // Pour "Investisseur Avis√©"
            badgesEarned: 0,           // Pour "Collectionneur de Badges"

            // --- √âTATS DYNAMIQUES (Mises √† jour en temps r√©el) ---
            pensionCount: 0,           // Pour "√âlevage Intensif" (Valeur actuelle)
            teamPower: 0,              // Pour "√âquipe d'√âlite" (Valeur actuelle)

            // --- SYST√àME ---
            startTime: Date.now(),
            totalPlayTime: 0
        };

        // 2. Progression des Succ√®s (On garde √ßa s√©par√©, c'est propre)
        this.achievementsProgress = {}; 
        
        // On initialise √† 0 pour toutes les cl√©s de base (les pr√©fixes avant le underscore)
        // Ce n'est pas strictement obligatoire car le code g√®re le "undefined", mais c'est plus propre.
        
        // =========================================================
        
        this.tabHiddenTime = null;

// GESTION DU RETOUR SUR L'ONGLET (Rattrapage du temps perdu)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.tabHiddenTime = Date.now();
                console.log("üì¥ Onglet cach√©.");
            } else {
                if (this.tabHiddenTime) {
                    const timeHidden = Date.now() - this.tabHiddenTime;
                    console.log("üì± Retour apr√®s:", (timeHidden / 1000).toFixed(1) + "s");
                    
                    if (timeHidden > 1000) { // Si absence > 1 seconde
                        
                        // 1. Rattrapage des Combats (Existant)
                        if (timeHidden > 5000) {
                            this.catchupMissedCombats(timeHidden);
                        } else {
                            // Si l'absence est courte (<5s), on rattrape quand m√™me les stats passives
                            this.catchUpPassiveStats(timeHidden);
                        }

                        // 2. ‚úÖ RATTRAPAGE G√âN√âRATION EXP√âDITIONS (NOUVEAU)
                        // On simule l'√©coulement du temps pour le timer d'exp√©dition
                        if (this.availableExpeditions.length < this.maxAvailableExpeditions) {
                            let remainingTime = timeHidden;

                            // Boucle tant qu'on a du temps √† d√©penser et des slots libres
                            while (remainingTime > 0 && this.availableExpeditions.length < this.maxAvailableExpeditions) {
                                if (remainingTime >= this.expeditionTimer) {
                                    // Assez de temps pour finir le timer actuel -> Une mission appara√Æt !
                                    remainingTime -= this.expeditionTimer;
                                    this.generateRandomExpedition();
                                    
                                    // On reset le timer pour la suivante
                                    this.expeditionTimer = this.EXPEDITION_GEN_TIME;
                                } else {
                                    // Pas assez pour finir, on avance juste le timer
                                    this.expeditionTimer -= remainingTime;
                                    remainingTime = 0;
                                }
                            }
                        }

                        // Mise √† jour imm√©diate de l'affichage des exp√©ditions
                        this.updateExpeditionsDisplay();
                    }
                    
                    this.tabHiddenTime = null;
                }
            }
        });

        this.init();
    }
	

	// OPTIMISATION : Mise en cache (Cache DOM Selectors)
    // Au lieu de chercher les √©l√©ments √† chaque frame (co√ªteux), on les stocke ici.
    initUiCache() {
        this.ui = {
            // --- JOUEUR ---
            playerSprite: document.getElementById('playerSprite'),
            playerContainer: document.getElementById('playerSpriteContainer'),
            playerName: document.getElementById('playerCreatureName'),
            playerLevel: document.getElementById('playerCreatureLevel'),
            playerStats: document.getElementById('playerHudStats'),
            playerHpFill: document.getElementById('playerHealthFill'),
            playerHpText: document.getElementById('playerHealthText'),
            playerStatus: document.getElementById('playerStatusIcons'),
            playerATB: document.getElementById('playerATB'),
            playerATBStack: document.getElementById('playerATBStack'), // Si tu l'utilises

            // --- ENNEMI ---
            enemySprite: document.getElementById('enemySprite'),
            enemyContainer: document.getElementById('enemySpriteContainer'),
            enemyName: document.getElementById('enemyCreatureName'),
            enemyLevel: document.getElementById('enemyCreatureLevel'),
            enemyStats: document.getElementById('enemyHudStats'),
            enemyHpFill: document.getElementById('enemyHealthFill'),
            enemyHpText: document.getElementById('enemyHealthText'),
            enemyStatus: document.getElementById('enemyStatusIcons'),
            enemyATB: document.getElementById('enemyATB'),
            
            // --- UI GLOBALE ---
            effectiveness: document.getElementById('effectivenessIndicator'),
            ultBtn: document.getElementById('ultimateButton'),
            ultFill: document.getElementById('ultFill'),
            ultText: document.getElementById('ultText'),
            autoSelectBtn: document.getElementById('autoSelectBtn'),
            forfeitBtn: document.getElementById('forfeitBtn')
        };
        console.log("‚úÖ UI Cache initialis√© : Pr√™t pour le 60 FPS.");
    }
	
init() {
        // Cas 1 : Une sauvegarde existe
		this.initUiCache();
        if (this.loadGame()) {
            logMessage("Partie charg√©e !");
            
            // Lancement des syst√®mes
            this.setupEggHandler();
            this.lastTickTime = Date.now();
            this.updateZoneSelector();
            this.updateDisplay();
            this.startGameLoop();
            this.startAutoSave();
			this.runSanityCheck();
            
            // S√©curit√© : Si par hasard aucune qu√™te n'est charg√©e, on en lance une
            if (this.quests.length === 0) {
                 this.nextQuestTimer = 60000;
                 this.generateQuest();
            }

        } else {
            // Cas 2 : Nouvelle partie
            // On ne lance RIEN ici (pas de loop, pas de qu√™tes).
            // On attend que le joueur choisisse dans le modal.
            logMessage("Bienvenue ! Veuillez choisir votre starter.");
            this.showStarterSelection();
        }
    }
	
	// S√âCURIT√â : V√©rifie l'int√©grit√© de la base de donn√©es (Compatible Zones Complexes)
    runSanityCheck() {
        console.groupCollapsed("üîç Diagnostic des Donn√©es");
        let errors = 0;

        // 1. V√©rifier les Zones
        for (const [zoneId, zone] of Object.entries(ZONES)) {
            
            // ‚úÖ FIX : On utilise le helper pour aplatir la zone avant de la scanner
            const enemies = this.getAllPokemonInZone(zoneId);

            if (!enemies || enemies.length === 0) {
                console.error(`Zone ${zoneId} (${zone.name}) est vide ou mal configur√©e !`);
                errors++;
                continue;
            }

            enemies.forEach(name => {
                if (!POKEMON_BASE_STATS[name]) {
                    console.warn(`‚ö†Ô∏è MISSING STATS : ${name} (Zone ${zoneId})`);
                    errors++;
                }
                // Si tu utilises des sprites
                if (typeof POKEMON_SPRITE_IDS !== 'undefined' && !POKEMON_SPRITE_IDS[name]) {
                    console.warn(`‚ö†Ô∏è MISSING SPRITE ID : ${name}`);
                }
            });
        }

        // 2. V√©rifier les √âvolutions
        if (typeof EVOLUTIONS !== 'undefined') {
            for (const [base, evoData] of Object.entries(EVOLUTIONS)) {
                if (!POKEMON_BASE_STATS[base]) {
                    console.warn(`‚ö†Ô∏è √âvolution orpheline : ${base} n'a pas de stats.`);
                }
                if (!POKEMON_BASE_STATS[evoData.evolves_to]) {
                    console.error(`‚õî √âvolution bris√©e : ${base} -> ${evoData.evolves_to} (Cible inexistante)`);
                    errors++;
                }
            }
        }

        if (errors === 0) {
            console.log("‚úÖ Toutes les donn√©es semblent int√®gres.");
        } else {
            console.log(`‚ùå ${errors} erreurs trouv√©es. V√©rifiez constants.js et pokemonStats.js`);
        }
        console.groupEnd();
    }
	
	
	showStarterSelection() {
        const modal = document.getElementById('starterModal');
        if (modal) {
            modal.classList.add('show');
        }
		}
	selectStarter(type) {
        let name, creatureType;

        // D√©finition du Pok√©mon selon le choix
        switch(type) {
            case 'grass':
                name = 'Bulbasaur';
                creatureType = TYPES.GRASS;
                break;
            case 'fire':
                name = 'Charmander';
                creatureType = TYPES.FIRE;
                break;
            case 'water':
                name = 'Squirtle';
                creatureType = TYPES.WATER;
                break;
            default:
                return;
        }

        // 1. Cr√©ation du Starter (IVs parfaits pour bien commencer)
        const starter = new Creature(name, creatureType, 5, RARITY.EPIC, false);
        starter.ivHP = 1;
        starter.ivAttack = 1;
        starter.ivDefense = 1;
        starter.ivSpeed = 1;
        starter.recalculateStats();
        starter.heal();
        
        this.playerTeam.push(starter);

        // 2. Ressources de d√©part (remplace vos anciennes valeurs de test 200/100/100)
        // On donne un kit de d√©marrage √©quilibr√©
        this.pokedollars = 500;
        this.eggs[RARITY.COMMON] = 10; 
        this.items['pokeball'] = 5; 

        logMessage(`‚ú® Vous avez choisi ${name} comme partenaire !`);
        toast.success("Aventure Commenc√©e !", `${name} rejoint votre √©quipe !`);

        // 3. Fermer le modal
        const modal = document.getElementById('starterModal');
        if (modal) {
            modal.classList.remove('show');
        }

        // 4. LANCEMENT DU MOTEUR DE JEU (C'est ici qu'on met ce qui √©tait dans votre init)
        this.setupEggHandler();
        this.lastTickTime = Date.now();
        this.updateZoneSelector();
        this.updateDisplay();
        this.startGameLoop();
        
        // 5. Initialisation des Qu√™tes pour le nouveau joueur
        this.nextQuestTimer = 60000; // Premi√®re qu√™te dans 1 minute
        this.generateQuest(); 

        // 6. Lancer l'auto-sauvegarde et sauvegarder imm√©diatement
        this.startAutoSave();
        this.saveGame();
    }

// ‚úÖ REMPLACEZ votre fonction initAchievements par celle-ci
        initAchievements() {
            // ‚úÖ CORRECTION : S'assurer que this.achievements est un objet
            if (!this.achievements || typeof this.achievements !== 'object') {
                this.achievements = {};
            }

            // Si charg√© depuis la sauvegarde...
            if (Object.keys(this.achievements).length > 0) {
                for (const key in ACHIEVEMENTS) {
                    if (!this.achievements[key]) {
                        this.achievements[key] = {
                            current: 0,
                            completed: false,
                            claimed: false
                        };
                    }
                }
            } else {
                // D√©marrage frais
                for (const key in ACHIEVEMENTS) {
                    this.achievements[key] = {
                        current: 0,
                        completed: false,
                        claimed: false
                    };
                }
            }
        }

useItem(itemKey, quantity = 1, event = null) {
    const item = ALL_ITEMS[itemKey];
    if (!item) return false;
    
    let amountToUse = quantity;

    // Gestion du Ctrl + Clic (Tout utiliser) pour les vitamines uniquement
    if (event && (event.ctrlKey || event.metaKey) && item.effect && item.effect.duration === null) {
        amountToUse = this.items[itemKey];
    }

    // V√©rification stock
    if (!this.items[itemKey] || this.items[itemKey] < amountToUse) {
        logMessage(`‚ùå Pas assez d'objets !`);
        return false;
    }
    
    // 1. Consommer
    this.items[itemKey] -= amountToUse;
    
    // Nettoyer si vide
    if (this.items[itemKey] <= 0) {
        delete this.items[itemKey];
    }
    
    // 2. Appliquer l'effet
    if (item.effect.duration === null) {
        // ‚úÖ VITAMINE (Permanent) : On envoie la quantit√© totale ici
        this.applyVitamin(item, amountToUse);
    } else {
        // ‚úÖ BOOST (Temporaire) : On boucle pour ajouter le temps X fois
        for(let i=0; i < amountToUse; i++) {
            this.applyStatBoost(item);
        }
    }
    
    this.updateItemsDisplay();
    this.updatePlayerStatsDisplay(); 
    return true;
}

hasCreatureInCollection(name, type) {
    // V√©rifier dans l'√©quipe
    if (this.playerTeam.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    // V√©rifier dans le stockage
    if (this.storage.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    // V√©rifier dans la pension
    if (this.pension.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    return false;
}

// OPTIMISATION : "Dirty Checking"
    // Ne touche au DOM que si la nouvelle valeur est diff√©rente de l'ancienne.
    // √âvite les "Recalculate Style" inutiles du navigateur.
    updateTextContent(element, text) {
        if (element && element.textContent !== text) {
            element.textContent = text;
        }
    }

    // OPTIMISATION : Performance GPU
    // Met √† jour le transform uniquement si n√©cessaire.
    updateTransformScaleX(element, ratio) {
        // On formate √† 4 d√©cimales pour √©viter les micro-changements inutiles (0.1000001 vs 0.1)
        // const safeRatio = ratio.toFixed(4); // Optionnel si ratio est d√©j√† propre
        const transformValue = `scaleX(${ratio})`;
        if (element && element.style.transform !== transformValue) {
            element.style.transform = transformValue;
        }
    }

applyVitamin(item, quantity = 1) {
    const effect = item.effect;
    
    // ‚úÖ C'EST ICI LA CORRECTION : On multiplie par la quantit√©
    const totalBonus = effect.value * quantity;
    
    // S'assurer que l'objet activeVitamins existe
    if (!this.activeVitamins) {
        this.activeVitamins = { hp: 0, attack: 0, defense: 0, speed: 0, all: 0 };
    }

    if (effect.stat === 'all') {
        this.activeVitamins.all = (this.activeVitamins.all || 0) + totalBonus;
        logMessage(`‚úÖ ${quantity}x ${item.name} utilis√©s ! +${(totalBonus * 100).toFixed(0)}% Stats (Perm.)`);
    } else {
        this.activeVitamins[effect.stat] = (this.activeVitamins[effect.stat] || 0) + totalBonus;
        logMessage(`‚úÖ ${quantity}x ${item.name} utilis√©s ! +${(totalBonus * 100).toFixed(0)}% ${effect.stat.toUpperCase()} (Perm.)`);
    }
    
    // Recalculer et Sauvegarder imm√©diatement
    this.incrementPlayerStats();
    this.saveGame();
}

// ========================================
// ‚úÖ √âTAPE 5 : Appliquer les boosts temporaires
// ========================================

applyStatBoost(item) {
    const effect = item.effect;
    const boost = {
        stat: effect.stat,
        value: effect.value,
        endTime: Date.now() + effect.duration
    };
    
    this.activeStatBoosts.push(boost);
    
    const minutes = Math.floor(effect.duration / 60000);
    logMessage(`‚úÖ ${item.icon} ${item.name} utilis√© ! +${(effect.value * 100).toFixed(0)}% de ${effect.stat === 'all' ? 'toutes les stats' : effect.stat.toUpperCase()} pendant ${minutes} minutes !`);
    
    // ‚úÖ NOUVEAU : Mettre √† jour les HP en combat si boost HP ou ALL
    if ((effect.stat === 'hp' || effect.stat === 'all') && this.currentPlayerCreature) {
        const newMaxHp = this.getPlayerMaxHp();
        const oldMaxHp = this.currentPlayerCreature.mainAccountCurrentHp || this.playerMainStats.hp;
        
        // Augmenter les HP actuels proportionnellement
        const hpRatio = oldMaxHp / this.playerMainStats.hp;
        this.currentPlayerCreature.mainAccountCurrentHp = Math.floor(newMaxHp * hpRatio);
        
        logMessage(`üíö PV max augment√©s : ${formatNumber(this.currentPlayerCreature.mainAccountCurrentHp)} / ${formatNumber(newMaxHp)}`);
    }
    
    this.updateStatBoostsDisplay();
}


getPlayerMaxHp() {
        const hpBonus = 1 + this.getAccountTalentBonus('hp_mult');
        const hpBoost = 1 + this.getStatBoostMultiplier('hp');  
        const synergies = this.getActiveSynergies();
        const synergyMaxHpMult = synergies.max_hp_mult || 1;
        
        let total = Math.floor(this.playerMainStats.hp * hpBonus * hpBoost * synergyMaxHpMult);

        // ‚úÖ AJOUT : Relique de Tour (C≈ìur de Golem)
        if (this.towerState.isActive && this.towerState.buffs && this.towerState.buffs.max_hp_mult) {
            total = Math.floor(total * this.towerState.buffs.max_hp_mult);
        }

        return total;
    }

    catchUpPassiveStats(deltaTime) {
        const ticks = Math.floor(deltaTime / 1000);
        if (ticks > 0) {
            console.log(`Rattrapage de ${ticks} secondes de stats passives...`);
            for (let i = 0; i < ticks; i++) {
                this.incrementPlayerStats();
                this.regenerateStamina();
            }
        }
    }

   // OPTIMISATION : Architecture "Game Loop" d√©coupl√©e (Logic vs Render)
    startGameLoop() {
        console.log("üöÄ Moteur de jeu optimis√© d√©marr√© (60 FPS)");
        
        // Initialisation des Timers
        this.lastFrameTime = performance.now();
        this.lowFreqTimer = 0; // Accumulateur pour les actions lentes (1s)
        
        // La fonction de boucle qui s'appelle elle-m√™me
        const loop = (currentTime) => {
            // 1. Calcul du Delta Time (Temps √©coul√© depuis la derni√®re image en ms)
            // S√âCURIT√â : On plafonne √† 100ms. Si le jeu lag ou onglet inactif, 
            // on √©vite de simuler 1 heure d'un coup ici (√ßa ferait planter le PC).
            const deltaTime = Math.min(currentTime - this.lastFrameTime, 100); 
            this.lastFrameTime = currentTime;

            // 2. LOGIQUE RAPIDE (Ce qui doit √™tre fluide)
            // On met √† jour l'ATB et les timers pr√©cis
            this.updateHighFreqLogic(deltaTime);

            // 3. LOGIQUE LENTE (Ce qui arrive chaque seconde)
            this.lowFreqTimer += deltaTime;
            if (this.lowFreqTimer >= 1000) {
                this.updateLowFreqLogic();
                this.lowFreqTimer -= 1000; // On garde le reste pour la pr√©cision
            }

            // 4. RENDU (Dessiner l'√©cran)
            // Gr√¢ce √† nos optimisations pr√©c√©dentes (Cache + GPU), 
            // on peut le faire √† chaque frame sans ralentir !
            this.updateCombatDisplay();
			
            
            // 5. Boucle suivante
            this.gameLoopId = requestAnimationFrame(loop);
        };

        // Lancement initial
        this.gameLoopId = requestAnimationFrame(loop);
        
        // INTERVALLES SECONDAIRES (UI lente & Sauvegarde)
        // On sort √ßa de la boucle principale pour ne pas surcharger le processeur graphique
        if (this.secondaryInterval) clearInterval(this.secondaryInterval);
        this.secondaryInterval = setInterval(() => {
            this.updatePlayerStatsDisplay(); // Argent, stats globales...
            this.updateUpgradesDisplay();    // Boutons d'achat
            this.checkCompletedNotifications();
            this.checkActiveExpeditions();
            this.updateQuestTimerDisplay();  // Timer de qu√™te (pas besoin de ms)
            
            // Gestion du Modal de Tiers (seulement si ouvert)
            const tierModal = document.getElementById('zoneTierModal');
            if (tierModal && tierModal.classList.contains('show')) {
                if(window.showZoneTierModal) window.showZoneTierModal();
            }
        }, 500); // 2 fois par seconde suffit largement pour l'UI statique
        
        // Calcul initial
        this.calculateTeamStats();
        this.updateDisplay();
    }
	
	// OPTIMISATION : Logique rapide (s√©par√©e du rendu)
    // CORRECTION : On r√©int√®gre la gestion des √©tats (handleCombat)
    updateHighFreqLogic(deltaTime) {
        // 1. G√©rer les √©tats (Waiting / Starting / Dead)
        // On le fait √† chaque frame pour √™tre r√©actif au clic
        this.handleCombat(); 

        // 2. Si on se bat, on fait avancer les barres ATB avec le temps pr√©cis
        if (this.combatState === 'fighting') {
            this.updateATB(deltaTime);
        }
        
        // 3. Timer d'exp√©dition
        this.updateExpeditionTimer(deltaTime);
    }
	
	// OPTIMISATION : Logique lente (1 fois/sec) - √âconomise le CPU
    // OPTIMISATION : Logique lente (1 fois/sec) - Inclut maintenant les Statuts !
    updateLowFreqLogic() {
        // 1. R√©g√©n√©ration
        this.incrementPlayerStats();
        this.regenerateStamina();
        
        // 2. Nettoyage des boosts
        this.updateStatBoosts();
		
		this.updateQuestTimer(1000);
        
        // 3. ‚úÖ GESTION DES STATUTS (DoT & Dur√©e)
        // C'est ici que les statuts avancent et s'enl√®vent !
        if (this.combatState === 'fighting') {
            // Joueur
            if (this.currentPlayerCreature && this.currentPlayerCreature.isAlive()) {
                const pResult = this.currentPlayerCreature.processStatusEffect(this);
                // Si le DoT (Poison/Br√ªlure) tue le joueur
                if (pResult.isDead) this.playerCreatureFainted();
            }
            
            // Ennemi
            if (this.currentEnemy && this.currentEnemy.isAlive()) {
                const eResult = this.currentEnemy.processStatusEffect(this);
                // Si le DoT tue l'ennemi
                if (eResult.isDead) this.winCombat();
            }
        }
    }

// ========================================
// ‚úÖ AJOUTE cette fonction pour arr√™ter proprement le game loop
// ========================================

stopGameLoop() {
    if (this.gameLoopId) {
        cancelAnimationFrame(this.gameLoopId);
        this.gameLoopId = null;
        console.log("Game loop arr√™t√©");
    }
}


        
        
    catchupMissedCombats(missedTime) {
    // 1. Rattraper les stats passives (Toujours)
    this.catchUpPassiveStats(missedTime);

    // 2. V√©rifier si un mode sp√©cial est actif
    if (this.towerState.isActive || this.arenaState.active) {
        const mode = this.towerState.isActive ? "de la Tour" : "d'Ar√®ne";
        logMessage(`‚ö° Le combat ${mode} a √©t√© mis en pause pendant votre absence.`);
        
        this.lastCombatTime = Date.now();
        this.lastCombatTurnTime = Date.now();
        if (this.combatState !== 'fighting') this.combatState = 'fighting';
       
        this.updateDisplay();
        return;
    }

    /// 3. Simulation de zone (Farm)
    // A. Calcul de la moyenne
    let avgCombatTime = this.recentCombatDurations && this.recentCombatDurations.length > 0
        ? this.recentCombatDurations.reduce((a, b) => a + b, 0) / this.recentCombatDurations.length
        : 2000; // Par d√©faut 2s si pas de donn√©es

    // B. Limites physiques et Taxe de Lag
    const minPossibleTime = (this.combatStartDelay || 50) + (this.combatTurnDelay || 250);
    avgCombatTime = Math.max(avgCombatTime, minPossibleTime);
    avgCombatTime = Math.floor(avgCombatTime * 1.1); // +10% marge erreur

    // C. Calcul du nombre de combats
    const averageCombatDuration = this.combatCooldown + avgCombatTime;
    let maxPossibleCombats = Math.floor(missedTime / averageCombatDuration);

    // üõë S√âCURIT√â ANTI-CRASH : On limite √† 2000 combats max (environ 1-2h de simu intense)
    const MAX_SAFE_SIMULATION = 2000;
    if (maxPossibleCombats > MAX_SAFE_SIMULATION) {
        console.warn(`‚ö†Ô∏è Trop de combats (${maxPossibleCombats}). Plafonn√© √† ${MAX_SAFE_SIMULATION}.`);
        maxPossibleCombats = MAX_SAFE_SIMULATION;
    }

    if (maxPossibleCombats <= 0) return;

    console.log(`üîÑ Simulation: ${maxPossibleCombats} combats (Moyenne: ${(averageCombatDuration/1000).toFixed(2)}s)`);

    // D. Pr√©paration Simulation
    const originalLogFunction = window.logMessage;
    window.logMessage = function() {}; // On coupe les logs

    // Objet unique pour tout suivre
    let stats = {
        simulated: 0,
        won: 0,
        lost: 0,
        xp: 0,
        money: 0,
        items: {},
        capturedPokemonList: [],
        time: missedTime
    };

    // E. BOUCLE DE SIMULATION
    for (let i = 0; i < maxPossibleCombats; i++) {
        // 1. V√©rif √©quipe en vie
        this.faintedThisCombat = new Set();
        this.currentPlayerCreature = this.getFirstAliveCreature();
        if (!this.currentPlayerCreature) break; // Game Over, on arr√™te
        
        this.activeCreatureIndex = this.playerTeam.indexOf(this.currentPlayerCreature);
        
        // 2. SIMULATION DU COMBAT (Une seule fois !)
        // simulateCombat doit retourner un objet {xp, money...} si victoire, ou null si d√©faite
        const result = this.simulateCombat(); 
        
        stats.simulated++;

        if (result) {
            // Victoire
            stats.won++;
            stats.xp += result.xp || 0;
            stats.money += result.money || 0;
            if (result.items) {
                for (const [itemName, count] of Object.entries(result.items)) {
                    // On additionne dans le total global
                    stats.items[itemName] = (stats.items[itemName] || 0) + count;
                }
            }
            if (result.captured) {
        stats.captured++;
        // On ajoute le Pok√©mon √† la liste (limite √† 50 pour pas exploser le modal si besoin)
        if (stats.capturedPokemonList.length < 50) {
            stats.capturedPokemonList.push(result.captured);
        }
    }
        } else {
            // D√©faite
            stats.lost++;
        }

        // 3. Regen Stamina (Post-Combat)
        const regenTicks = Math.floor(this.combatCooldown / 1000);
        for (let j = 0; j < regenTicks; j++) {
            this.regenerateStamina();
        }
        
        // Reset √©tat
        this.combatState = 'waiting';
    }

    // F. Nettoyage et Affichage
    window.logMessage = originalLogFunction; // On remet les logs
    
    // Soins complets gratuits apr√®s l'absence (Qualit√© de vie)
    for (const creature of this.playerTeam) {
        creature.heal();
        creature.currentStamina = creature.maxStamina;
        creature.clearStatusEffect();
    }
    
    this.combatState = 'waiting';
    this.lastCombatTime = Date.now();

    // Log console pour d√©bug
    console.log(`‚úÖ Fin Simu: ${stats.simulated} combats, ${stats.won} wins, Gain: ${stats.money}$`);

    // Log Joueur
    const xpFormatted = typeof formatNumber === 'function' ? formatNumber(stats.xp) : stats.xp;
    logMessage(`‚ö° Rattrapage termin√© : ${stats.simulated} combats simul√©s.`);
    
    this.updateItemsDisplay();
    this.updateDisplay();

    // G. Lancer le Modal (Seulement si on a simul√© quelque chose)
    if (stats.simulated > 0) {
        this.showOfflineReport(stats);
    }
}



showOfflineReport(stats) {
    const modal = document.getElementById('offlineModal');
    if (!modal) return;

    // 1. Calculs de temps pr√©cis
    const totalSeconds = Math.floor(stats.time / 1000);
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = Math.floor(totalSeconds % 60);
    
    // 2. Formatage dynamique (Ex: "1h 30m" ou "45s")
    let timeStr = "";
    if (h > 0) {
        timeStr = `${h}h ${m}m ${s}s`;
    } else if (m > 0) {
        timeStr = `${m}m ${s}s`;
    } else {
        timeStr = `${s}s`; // Juste les secondes si tr√®s court
    }
    // 2. HTML Structure
    // On recr√©e tout le contenu du modal dynamiquement pour √™tre propre
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2>Offline report</h2>
                <div style="cursor:pointer;" onclick="closeOfflineModal()">‚úï</div>
            </div>
            
            <div class="modal-body">
                <div class="offline-summary">
                    <div class="offline-time" id="offlineTimeDisplay">${timeStr}</div>
                    <div class="offline-subtitle">Temps √©coul√©</div>
                </div>

                <div class="stats-row">
                    <div class="mini-stat">
                        <span class="val" style="color:#ef4444">${formatNumber(stats.simulated)}</span>
                        <span class="lbl">Combats</span>
                    </div>
                    <div class="mini-stat">
                        <span class="val" style="color:#f59e0b">+${formatNumber(stats.money)}</span>
                        <span class="lbl">Argent</span>
                    </div>
                    <div class="mini-stat">
                        <span class="val" style="color:#8b5cf6">+${formatNumber(stats.xp)}</span>
                        <span class="lbl">XP</span>
                    </div>
                </div>

                <div class="section-title">üì¶ Butin (${formatNumber(Object.values(stats.items).reduce((a,b)=>a+b, 0))})</div>
                <div class="loot-scroll-area" id="lootArea">
                    </div>

                <div class="section-title" id="captureTitle">üï∏Ô∏è Captures (${formatNumber(stats.captured)})</div>
                <div class="pokemon-grid" id="captureGrid">
                    </div>
            </div>

            <div class="modal-footer">
                <button class="claim-btn" onclick="closeOfflineModal()">Tout R√©cup√©rer</button>
            </div>
        </div>
    `;

    // 3. Remplissage des ITEMS (Loot)
    const lootArea = document.getElementById('lootArea');
    const items = Object.entries(stats.items);
    
    if (items.length === 0) {
        lootArea.innerHTML = '<div style="text-align:center; padding:10px; color:#cbd5e1; font-style:italic;">Aucun objet trouv√©</div>';
    } else {
        items.forEach(([key, count]) => {
            const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const iconPath = getItemIconPath(key);
            const rarityClass = getRarityClass(key);
            
            lootArea.innerHTML += `
                <div class="loot-item ${rarityClass}">
                    <img src="${iconPath}" class="item-icon" onerror="this.src='assets/items/unknown.png'">
                    <div class="item-info">
                        <span class="item-name">${displayName}</span>
                    </div>
                    <span class="item-qty "> x${formatNumber(count)}</span>
                </div>
            `;
        });
    }

    // 4. Remplissage des CAPTURES (Pok√©mon)
    const captureGrid = document.getElementById('captureGrid');
    // On suppose que stats.capturedPokemonList est un tableau [{name: 'Pikachu', shiny: false}, ...]
    // Si tu n'as pas encore cette liste, voir √©tape 4 ci-dessous.
    
    if (!stats.capturedPokemonList || stats.capturedPokemonList.length === 0) {
        captureGrid.style.display = 'none';
        document.getElementById('captureTitle').style.display = 'none';
    } else {
        stats.capturedPokemonList.forEach(poke => {
            const sprite = getPokemonSpritePath(poke.name, poke.shiny);
            const shinyEffect = poke.shiny ? '<span class="shiny-sparkle">‚ú®</span>' : '';
            const bgStyle = poke.shiny ? 'background: #fffbeb; border-color: #f59e0b;' : '';
            
            captureGrid.innerHTML += `
                <div class="poke-capture" style="${bgStyle}">
                    ${shinyEffect}
                    <img src="${sprite}" onerror="this.src='assets/sprites/unknown.png'" title="${poke.name}">
                </div>
            `;
        });
    }

    modal.style.display = 'flex';
}

    getSpawnDelay() {
    // 1. S√©curit√© : Si GAME_SPEEDS n'est pas trouv√©, on met 250 par d√©faut
    const baseDelay = (typeof GAME_SPEEDS !== 'undefined') ? GAME_SPEEDS.RESPAWN_DELAY : 2500;

    // 2. S√©curit√© CRITIQUE : V√©rifier si l'upgrade existe dans la sauvegarde
    // Si le joueur a une vieille save, this.upgrades.respawn est undefined -> CRASH
    let level = 0;
    if (this.upgrades && this.upgrades.respawn) {
        level = this.upgrades.respawn.level;
    }

    // 3. Calcul
    const reduction = level * 50; 
    
    // 4. R√©sultat (Min 50ms)
    return Math.max(50, baseDelay - reduction); 
}

    // ====== NOUVELLES FONCTIONS POUR LA TOUR DE COMBAT ======
    startTowerRun() {
        if (this.towerState.isActive) {
            logMessage("Une tentative est d√©j√† en cours !");
            return;
        }
        if (this.combatTickets <= 0) {
            logMessage("Vous n'avez pas de Ticket de Combat !");
            return;
        }

        this.combatTickets--;
        logMessage("Un Ticket de Combat est utilis√©. L'ascension de la Tour commence !");

        // Soin complet de l'√©quipe au d√©but de la tentative
        for (const creature of this.playerTeam) {
            creature.heal();
            creature.clearStatusEffect();
        }
        // Assure-toi que currentPlayerCreature est d√©fini avant d'acc√©der √† ses propri√©t√©s
        if (!this.currentPlayerCreature && this.playerTeam.length > 0) {
            this.currentPlayerCreature = this.playerTeam[0];
        }
        if (this.currentPlayerCreature) {
            this.currentPlayerCreature.mainAccountCurrentHp = this.getPlayerMaxHp();
        }


        this.towerState = {
            isActive: true,
            currentFloor: 1,
            currentEnemyIndex: 0,
            enemyTeam: this.generateTowerEnemyTeam(1),
			buffs: { attack_mult: 1, defense_mult: 1, lifesteal: 0, crit_chance: 0 }
        };

        // Lance le premier combat
        this.currentEnemy = this.towerState.enemyTeam[0];
        this.combatState = 'starting';
        this.combatStartTime = Date.now();
        logMessage(`√âtage 1 : Le dresseur envoie ${this.currentEnemy.name} !`);
		this.triggerAutoSelect();
		updateZoneInfo();
        this.updateDisplay();
    }

checkActiveExpeditions() {
    if (this.activeExpeditions.length > 0) {
        // Cette fonction ne fait que d√©clencher une mise √† jour de l'affichage
        // si l'onglet "expeditions" est actif, pour rafra√Æchir les minuteurs.
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'expeditionsTab') {
            this.updateExpeditionsDisplay();
        }
    }
}
generateTowerEnemyTeam(floor) {
        const team = [];
        
        // 1. Trouver l'ID du Pok√©mon correspondant √† l'√©tage
        // On suppose que le dernier ID est 649 (Genesect dans votre liste).
        // Le modulo (%) permet de recommencer √† 1 apr√®s 649.
        const maxDexId = 649; 
        let targetId = ((floor - 1) % maxDexId) + 1;

        // 2. Retrouver le NOM gr√¢ce √† l'ID (Recherche invers√©e dans vos constantes)
        // On cherche la cl√© dans POKEMON_SPRITE_IDS dont la valeur est targetId
        let pokemonName = Object.keys(POKEMON_SPRITE_IDS).find(key => POKEMON_SPRITE_IDS[key] === targetId);
        
        // S√©curit√© si l'ID n'est pas trouv√©
        if (!pokemonName) pokemonName = "MissingNo";

        // 3. D√©terminer si c'est un Boss (Tous les 10 √©tages)
        // M√™me si c'est un Chenipan (ID #10), √† l'√©tage 10, ce sera un "Boss Chenipan"
        const isBossFloor = floor % 10 === 0;

        // 4. Cr√©ation de la Cr√©ature
        const type = this.findTypeForPokemon(pokemonName);
        const secondaryType = POKEMON_SECONDARY_TYPES[pokemonName] || null;
        
        // Pour le style : Les Boss de palier (tous les 10) sont affich√©s en L√©gendaire
        let rarity = RARITY.COMMON;
        if (isBossFloor) rarity = RARITY.LEGENDARY; 
        
        // Note : Le niveau affich√© est √©gal √† l'√©tage
        const creature = new Creature(
            pokemonName, 
            type, 
            floor, // Le niveau = l'√©tage
            rarity, 
            true,  // isEnemy
            false, // isShiny (ou mettez Math.random() < 0.01 pour la surprise)
            secondaryType,
            isBossFloor, // isBoss (Important pour le loot dans finalizeCombat)
            false        // isEpic
        );

        // 5. SCALING (√âquilibrage de Puissance)
        // Comme on suit l'ordre du Pok√©dex, les stats de base vont faire le yoyo 
        // (Mewtwo #150 est fort, Mew #151 est fort, Chikorita #152 est faible).
        // Il faut donc un multiplicateur puissant pour que l'√©tage prime sur l'esp√®ce.

        const baseMult = 100;
        const linearGrowth = 1 + (floor * 0.15); // +15% par √©tage
        const expoGrowth = Math.pow(1.02, floor); // +2% compos√© (√ßa monte vite apr√®s l'√©tage 100)

        let multiplier = baseMult * linearGrowth * expoGrowth;

        // Bonus massif pour les Boss de palier (x4 PV/D√©g√¢ts)
        if (isBossFloor) {
            multiplier *= 1.15;
            // On leur donne un talent au hasard pour pimenter le combat tous les 10 √©tages
            creature.assignRandomTalent();
        }

        // Application des stats
        creature.maxHp = Math.floor(creature.maxHp * multiplier);
        creature.attack = Math.floor(creature.attack * multiplier);
        creature.defense = Math.floor(creature.defense * multiplier);
        creature.speed = Math.floor(creature.speed * multiplier);
        creature.currentHp = creature.maxHp;

        // On ajoute ce seul ennemi √† l'√©quipe adverse
        team.push(creature);
        
        return team;
    }

   nextTowerFloor() {
        // Si multiple de 10, on propose une relique
        if (this.towerState.currentFloor % 10 === 0) {
            // ‚úÖ CORRECTION IMPORTANTE : Mettre le jeu en pause
            this.combatState = 'waiting'; 
            this.currentEnemy = null; // On retire l'ennemi mort pour ne plus d√©clencher winCombat
            
            this.offerTowerRelic();
            return; // On arr√™te ici, le joueur doit choisir
        }

        this.proceedToNextFloor();
    }

    proceedToNextFloor() {
        this.towerState.currentFloor++;
        logMessage(`Passage √† l'√©tage ${this.towerState.currentFloor}.`);
        
        // G√©n√©rer le nouvel √©tage
        this.towerState.enemyTeam = this.generateTowerEnemyTeam(this.towerState.currentFloor);
        this.towerState.currentEnemyIndex = 0;
        this.currentEnemy = this.towerState.enemyTeam[0];
        
        // Relancer le combat
        this.combatState = 'starting';
        this.combatStartTime = Date.now();
		this.triggerAutoSelect();
        this.updateDisplay();
    }

   endTowerRun(isForfeit = false) {
        const floorReached = this.towerState.currentFloor;
        const floorsCleared = floorReached - 1;
        
        // Note : Les Marques et Pok√©dollars ont d√©j√† √©t√© ajout√©s 
        // √©tage par √©tage dans finalizeCombat().
        // On ne fait ici que le calcul pour l'affichage du r√©sum√©.

        // V√©rifier si c'est un nouveau record
        const isNewRecord = floorsCleared > this.towerRecord;
        if (isNewRecord) {
            this.towerRecord = floorsCleared;
            // Petite r√©compense bonus pour le record (facultatif)
            this.pokedollars += floorsCleared * 100;
        }
        
        // Affichage du Modal de fin
        this.showTowerCompletionModal(floorsCleared, isNewRecord, isForfeit);
        
        // R√©initialisation compl√®te de l'√©tat Tour
        this.towerState = { 
            isActive: false, 
            currentFloor: 0, 
            currentEnemyIndex: 0, 
            enemyTeam: [],
            buffs: {} // On perd les reliques
        };
        
        // Retour √† l'√©tat d'attente normal
        this.combatState = 'waiting';
        this.lastCombatTime = Date.now();
        this.currentEnemy = null;
        
        // Soin de l'√©quipe (puisqu'on sort de la tour)
        this.playerTeam.forEach(c => {
            c.heal();
            c.currentStamina = c.maxStamina;
        });

        this.updateDisplay();
        this.saveGame(); // Sauvegarde importante pour s√©curiser les gains
    }
// AJOUTEZ CES DEUX FONCTIONS √Ä VOTRE CLASSE GAME
offerTowerRelic() {
        const modal = document.getElementById('relicModal');
        const grid = document.getElementById('relicOptionsGrid');
        if (!modal || !grid) return;

        grid.innerHTML = '';
        
        let availableKeys = Object.keys(TOWER_RELICS).filter(key => {
            const relic = TOWER_RELICS[key];
            
            // Si la relique est unique, on v√©rifie si on poss√®de d√©j√† son bonus
            if (relic.unique) {
                // Cas Hache d'Ex√©cution
                if (key === 'executioner' && this.towerState.buffs.execute_percent) return false;
                
                // ‚úÖ CAS AJOUT√â : Cape d'Ombre
                if (key === 'shadow_cloak' && this.towerState.buffs.dodge_chance) return false;
            }
            return true;
        });

        // 2. Fonction de tirage de raret√©
        const rollRarity = () => {
            const r = Math.random() * 100;
            if (r < 60) return RARITY.COMMON;
            if (r < 90) return RARITY.RARE;
            if (r < 98) return RARITY.EPIC;
            return RARITY.LEGENDARY;
        };

        // 3. S√©lectionner 3 choix
        const choices = [];
        const countToPick = Math.min(3, availableKeys.length);

        while(choices.length < countToPick) {
            const k = availableKeys[Math.floor(Math.random() * availableKeys.length)];
            if (!choices.some(c => c.key === k)) {
                choices.push({ key: k, rarity: rollRarity() });
            }
        }

        // 4. Affichage
        choices.forEach(choice => {
            const relic = TOWER_RELICS[choice.key];
            const value = relic.values[choice.rarity];
            const desc = relic.getDescription(value); // Description dynamique

            const card = document.createElement('div');
            card.className = `relic-card relic-${choice.rarity}`;
            
            card.innerHTML = `
                <div class="relic-badge badge-${choice.rarity}">${choice.rarity}</div>
                <div style="font-size: 30px; margin-top: 10px;">${relic.icon}</div>
                <div style="font-weight:bold; margin:5px 0;">${relic.name}</div>
                <div style="font-size:12px; color:#555;">${desc}</div>
            `;
            
            // On passe la cl√© ET la raret√© √† la fonction de s√©lection
            card.onclick = () => this.selectTowerRelic(choice.key, choice.rarity);
            grid.appendChild(card);
        });

        modal.classList.add('show');
    }

  selectTowerRelic(key, rarity) {
        const relic = TOWER_RELICS[key];
        if (!relic) return;

        // R√©cup√©rer la valeur sp√©cifique √† la raret√© tir√©e
        const value = relic.values[rarity];

        // Appliquer l'effet avec la valeur
        relic.effect(this, value);
        
        // Log
        logMessage(`üíé Relique obtenue : ${relic.name} (${rarity})`);
        
        if (!relic.immediate) {
            this.updateTowerBuffsDisplay();
        }

        document.getElementById('relicModal').classList.remove('show');
        this.proceedToNextFloor();
    }

updateTowerShopDisplay() {
    const shopContainer = document.getElementById('towerShopContainer');
    if (!shopContainer) return;

    shopContainer.innerHTML = '';
    
    Object.entries(TOWER_SHOP_ITEMS).forEach(([key, item]) => {
        const card = document.createElement('div');
        card.className = 'shop-item';
        
        let currentLevel = 0;
        let isMaxLevel = false;
        let cost = item.cost;
        let levelText = '';
        
        if (item.maxLevel) {
            currentLevel = Math.round((this.permanentBoosts[item.effect.type] || 0) / item.effect.value);
            isMaxLevel = currentLevel >= item.maxLevel;
            levelText = ` (Niv. ${currentLevel}/${item.maxLevel})`;
            if (Array.isArray(item.cost)) {
                cost = isMaxLevel ? 'MAX' : item.cost[currentLevel];
            }
        }
        
        const canAfford = !isMaxLevel && this.marquesDuTriomphe >= cost;
        
        card.innerHTML = `
            <div class="shop-item-name">${item.name}${levelText}</div>
            <div class="shop-item-description">${item.description}</div>
            <div class="shop-item-cost">‚ìÇÔ∏è ${isMaxLevel ? 'MAX' : cost} Marques</div>
            <button class="shop-buy-btn" onclick="game.buyTowerShopItem('${key}')" ${!canAfford || isMaxLevel ? 'disabled' : ''}>
                ${isMaxLevel ? 'NIVEAU MAX' : (canAfford ? 'Acheter' : 'Marques insuffisantes')}
            </button>
        `;
        shopContainer.appendChild(card);
    });
}

buyTowerShopItem(itemKey) {
        const item = TOWER_SHOP_ITEMS[itemKey];
        if (!item) return;
        
        // Gestion du niveau pour les objets √©volutifs
        let currentLevel = 0;
        if (item.maxLevel && item.effect && item.effect.type) {
            // Correction du mapping pour la lecture du niveau
            let readKey = item.effect.type;
            if (readKey === 'pensionSlot') readKey = 'pensionSlots'; // ‚úÖ CORRECTION LECTURE
            
            const boostValue = this.permanentBoosts[readKey] || 0;
            currentLevel = Math.round(boostValue / item.effect.value);
        }
        
        if (item.maxLevel && currentLevel >= item.maxLevel) {
            logMessage("Cette am√©lioration est d√©j√† au niveau maximum !");
            return;
        }
        
        const cost = Array.isArray(item.cost) ? item.cost[currentLevel] : item.cost;
        if (this.marquesDuTriomphe < cost) {
            logMessage(`‚ùå Pas assez de Marques du Triomphe ! (${this.marquesDuTriomphe}/${cost})`);
            return;
        }
        
        this.marquesDuTriomphe -= cost;
        logMessage(`Achat : ${item.name} pour ${cost} Marques.`);
        
        switch(item.type) {
            case 'permanent':
                const effectType = item.effect.type;
                
                // ‚úÖ CORRECTION CRITIQUE : Mapping vers la bonne variable de stockage
                let storageKey = effectType;
                if (effectType === 'pensionSlot') storageKey = 'pensionSlots'; // Singulier -> Pluriel
                
                this.permanentBoosts[storageKey] = (this.permanentBoosts[storageKey] || 0) + item.effect.value;
                
                if (effectType === 'team_contribution') {
                    const newBonusPercent = this.permanentBoosts.team_contribution * 100;
                    logMessage(`‚úÖ Contribution d'√©quipe augment√©e ! Bonus total : +${newBonusPercent.toFixed(0)}%`);
                } else if (effectType === 'xp') {
                    logMessage(`‚úÖ Gain d'XP permanent augment√© de ${item.effect.value * 100}% !`);
                } else if (effectType === 'pensionSlot') {
                    logMessage("‚úÖ +1 emplacement de pension permanent !");
                    this.updatePensionDisplay(); // Rafra√Æchir l'affichage imm√©diatement
                }
                break;
                
            case 'egg':
                this.eggs[item.rarity] = (this.eggs[item.rarity] || 0) + item.amount;
                logMessage(`‚úÖ Vous avez re√ßu ${item.amount}x ≈íuf ${item.rarity} !`);
                this.updateEggsDisplay();
                break;
                
            case 'boost':
                this.addBoost(item);
                break;
                
            case 'item':
                // Gestion des objets (Pierres √©volutions, Balls...)
                this.addItem(item.item, item.amount || 1);
                break;
                
            case 'consumable':
                if (item.item === 'talent_reroll') {
                    this.talentRerolls++;
                    logMessage(`‚ú® Cristal de R√©initialisation obtenu ! (${this.talentRerolls} disponible(s))`);
                } else if (item.item === 'talent_choice') {
                    this.talentChoices++;
                    logMessage(`üåü Orbe de Ma√Ætrise obtenu ! (${this.talentChoices} disponible(s))`);
                }
                break;
        }
        
        this.updateDisplay();
        this.updateTowerShopDisplay();
    }
// R√©initialisation al√©atoire
// R√©initialisation al√©atoire du talent
    useTalentReroll(creatureIndex, location) { // ‚úÖ Argument 'location' est maintenant un string ('team', 'storage', 'pension')
        if (this.talentRerolls <= 0) {
            logMessage("Vous n'avez pas de Cristal de R√©initialisation !");
            return false;
        }

        // 1. Trouver la cr√©ature selon le lieu
        let creature;
        if (location === 'team') creature = this.playerTeam[creatureIndex];
        else if (location === 'storage') creature = this.storage[creatureIndex];
        else if (location === 'pension') creature = this.pension[creatureIndex];
        
        if (!creature) {
            console.error("Cr√©ature introuvable !");
            return false;
        }
        
        // V√©rifications de base
        if (creature.rarity !== RARITY.EPIC && creature.rarity !== RARITY.LEGENDARY) {
            logMessage("Seules les cr√©atures Epic et Legendary peuvent changer de talent !");
            return false;
        }
        
        if (!creature.passiveTalent) return false;
        
        // 2. Logique de Reroll (Inchang√©e)
        const oldTalent = creature.passiveTalent;
        const oldTalentInfo = PASSIVE_TALENTS[oldTalent];
        
        let attempts = 0;
        do {
            creature.assignRandomTalent();
            attempts++;
        } while (creature.passiveTalent === oldTalent && attempts < 20);
        
        this.talentRerolls--;
        
        const newTalentInfo = PASSIVE_TALENTS[creature.passiveTalent];
        logMessage(`‚ú® ${creature.name} : ${oldTalentInfo.name} ‚Üí ${newTalentInfo.name} !`);
        
        // 3. Mise √† jour des donn√©es
        this.calculateTeamStats();
        this.uiDirty = true; // Signaler que l'interface doit changer
        this.updateDisplay(); // Mettre √† jour l'arri√®re-plan (listes, stats)

        // 4. ‚úÖ RAFRA√éCHIR LE MODAL (Le garder ouvert avec les nouvelles infos)
        this.showCreatureModal(creatureIndex, location);
        
        return true;
    }

// Choix manuel du talent
useTalentChoice(creatureIndex, isStorage = false) {
    if (this.talentChoices <= 0) {
        logMessage("Vous n'avez pas d'Orbe de Ma√Ætrise !");
        return false;
    }

    const creature = isStorage ? this.storage[creatureIndex] : this.playerTeam[creatureIndex];
    
    if (!creature) {
        logMessage("Cr√©ature introuvable !");
        return false;
    }
    
    if (creature.rarity !== RARITY.EPIC && creature.rarity !== RARITY.LEGENDARY) {
        logMessage("Seules les cr√©atures Epic et Legendary peuvent changer de talent !");
        return false;
    }
    
    if (!creature.passiveTalent) {
        logMessage(creature.name + " n'a pas de talent passif !");
        return false;
    }
    
    // Ouvrir un modal pour choisir le talent
    this.openTalentChoiceModal(creature, creatureIndex, isStorage);
}

openTalentChoiceModal(creature, creatureIndex, isStorage) {
    // Cr√©er le modal
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        padding: 30px;
        border-radius: 15px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        border: 2px solid #a855f7;
        box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
    `;
    
    let html = `
        <h2 style="color: #a855f7; margin-bottom: 20px; text-align: center;">
            üåü Choisir un Talent pour ${creature.name}
        </h2>
        <p style="color: #94a3b8; text-align: center; margin-bottom: 20px;">
            Talent actuel : <strong>${PASSIVE_TALENTS[creature.passiveTalent].name}</strong>
        </p>
        <div style="display: grid; gap: 10px;">
    `;
    
    // Filtrer les talents selon la raret√©
    const availableTalents = creature.rarity === RARITY.LEGENDARY 
        ? Object.keys(PASSIVE_TALENTS)
        : Object.keys(PASSIVE_TALENTS).filter(key => PASSIVE_TALENTS[key].rarity === RARITY.EPIC);
    
    availableTalents.forEach(talentKey => {
        const talent = PASSIVE_TALENTS[talentKey];
        const isCurrent = talentKey === creature.passiveTalent;
        const rarityColor = talent.rarity === RARITY.LEGENDARY ? '#ffd700' : '#9333ea';
        
        html += `
            <button 
                onclick="game.applyTalentChoice('${talentKey}', ${creatureIndex}, ${isStorage}); document.body.removeChild(this.closest('[style*=fixed]'));"
                style="
                    padding: 15px;
                    background: ${isCurrent ? 'linear-gradient(135deg, #374151, #1f2937)' : 'linear-gradient(135deg, #4c1d95, #5b21b6)'};
                    color: white;
                    border: 2px solid ${rarityColor};
                    border-radius: 10px;
                    cursor: ${isCurrent ? 'not-allowed' : 'pointer'};
                    opacity: ${isCurrent ? '0.5' : '1'};
                    text-align: left;
                    transition: all 0.3s;
                "
                ${isCurrent ? 'disabled' : ''}
                onmouseover="if(!this.disabled) this.style.transform='scale(1.05)'"
                onmouseout="this.style.transform='scale(1)'"
            >
                <div style="font-weight: bold; font-size: 16px; color: ${rarityColor};">
                    ${talent.name} ${isCurrent ? '(Actuel)' : ''}
                </div>
                <div style="font-size: 13px; margin-top: 5px; color: #cbd5e1;">
                    ${talent.description}
                </div>
            </button>
        `;
    });
    
    html += `
        </div>
        <button 
            onclick="document.body.removeChild(this.closest('[style*=fixed]'))"
            style="
                margin-top: 20px;
                padding: 10px 20px;
                background: #ef4444;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: bold;
            "
        >
            Annuler
        </button>
    `;
    
    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);
}

applyTalentChoice(talentKey, creatureIndex, isStorage) {
    const creature = isStorage ? this.storage[creatureIndex] : this.playerTeam[creatureIndex];
    
    const oldTalent = creature.passiveTalent;
    const oldTalentInfo = PASSIVE_TALENTS[oldTalent];
    
    creature.passiveTalent = talentKey;
    this.talentChoices--;
    
    const newTalentInfo = PASSIVE_TALENTS[talentKey];
    logMessage(`üåü ${creature.name} : ${oldTalentInfo.name} ‚Üí ${newTalentInfo.name} !`);
    logMessage(`üìú ${newTalentInfo.description}`);
    
    this.calculateTeamStats();
    this.updateDisplay(); 
}

showTowerCompletionModal(floor, isNewRecord, isForfeit) {
        const modal = document.getElementById('towerCompletionModal');
        const infoDiv = document.getElementById('towerCompletionInfo');
        const rewardsDiv = document.getElementById('towerCompletionRewards');
        
        let title = isForfeit ? "üè≥Ô∏è RETRAITE STRAT√âGIQUE" : "üíÄ FIN DE L'ASCENSION";
        let message = isNewRecord ? `<div style="color:#ffd700; font-weight:bold; margin:10px 0;">‚≠ê NOUVEAU RECORD ! ‚≠ê</div>` : "";
        
        infoDiv.innerHTML = `
            <div style="font-size: 48px; margin: 20px 0;">${isForfeit ? 'üéí' : 'ü™¶'}</div>
            <h2 style="color: #333;">${title}</h2>
            ${message}
            <p style="font-size: 18px;">Vous avez atteint l'√©tage <strong>${floor}</strong></p>
        `;
        
        // On rappelle au joueur que tout est dans sa poche
        rewardsDiv.innerHTML = `
            <div style="padding: 15px; background: #e8f5e9; border-radius: 8px; color: #2e7d32; font-weight: bold;">
                ‚úÖ Toutes les Marques et Pok√©dollars collect√©s durant l'ascension ont √©t√© s√©curis√©s dans votre inventaire.
            </div>
        `;
        
        modal.classList.add('show');
        
        const closeBtn = document.getElementById('closeTowerBtn');
        if (closeBtn) closeBtn.onclick = () => modal.classList.remove('show');
    }
   updateTowerDisplay() {
    if (document.getElementById('towerRecord')) {
        document.getElementById('towerRecord').textContent = this.towerRecord;
        document.getElementById('combatTickets').textContent = this.combatTickets;
        document.getElementById('marquesDuTriomphe').textContent = this.marquesDuTriomphe;
    }
}
    
    // ... Tu peux coller ici toutes tes autres fonctions (saveGame, loadGame, winCombat, etc.)
    // ... Assure-toi de remplacer winCombat et playerCreatureFainted par les versions que je t'ai donn√©es
    // ... qui contiennent la logique pour la Tour.

updatePensionVisibility() {
    const pensionContainer = document.getElementById('pensionContainer');
    const pensionIcon = document.getElementById('pensionToggleIcon');

    if (!pensionContainer || !pensionIcon) return;

    if (this.isPensionCollapsed) {
        pensionContainer.style.display = 'none';
        pensionIcon.textContent = '‚ñ∂';
    } else {
        pensionContainer.style.display = 'block';
        pensionIcon.textContent = '‚ñº';
    }
}

hasCreatureInCollection(name, type) {
    // V√©rifier dans l'√©quipe
    if (this.playerTeam.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    // V√©rifier dans le stockage
    if (this.storage.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    // V√©rifier dans la pension
    if (this.pension.some(c => c.name === name && c.type === type)) {
        return true;
    }
    
    return false;
}

// UI : Affiche un texte flottant sur un √©l√©ment d'interface (Header, Bouton...)
    showUiFloatingText(elementId, text, type = 'ft-money') {
        const target = document.getElementById(elementId);
        if (!target) return;

        // 1. Calcul de la position exacte sur l'√©cran
        const rect = target.getBoundingClientRect();
        
        // 2. Cr√©ation de l'√©l√©ment
        const el = document.createElement('div');
        el.className = `ui-floating-text ${type}`;
        el.textContent = text;
        
        // 3. Positionnement (Centr√© horizontalement sur la cible)
        // On compense l√©g√®rement vers le haut (top) pour ne pas cacher le chiffre actuel
        el.style.left = `${rect.left + (rect.width / 2)}px`; 
        el.style.top = `${rect.top}px`;
        
        // Centrage CSS final du texte lui-m√™me par rapport au point
        el.style.transform = "translateX(-50%)"; 

        document.body.appendChild(el);

        // 4. Nettoyage automatique
        setTimeout(() => {
            if (el.parentElement) el.remove();
        }, 1500);
    }


// OPTIMISATION : handleCombat ne g√®re plus que les transitions d'√©tat (State Machine)
    handleCombat() {
        const now = Date.now();
        
        // S√©curit√© Timer
        if (!this.lastCombatTime || isNaN(this.lastCombatTime) || this.lastCombatTime > now) {
            this.lastCombatTime = now;
        }

        // 1. Gestion Ar√®ne (Timeout)
        if (this.arenaState.active) {
            if (this.checkArenaTimeout()) return;
        }
        
        // 2. √âtat MORT (Cooldown 4s)
        if (this.combatState === 'dead') {
            if (now - this.lastCombatTime >= this.deathCooldown) {
                this.combatState = 'waiting';
                this.lastCombatTime = now;
                
                // Soin complet
                for (const creature of this.playerTeam) {
                    creature.heal();
                    creature.currentStamina = creature.maxStamina;
                    creature.actionGauge = 0;
                }
                
                // Rel√®ve
                this.currentPlayerCreature = this.getFirstAliveCreature();
                if (this.currentPlayerCreature) {
                    this.activeCreatureIndex = this.playerTeam.indexOf(this.currentPlayerCreature);
                    this.currentPlayerCreature.mainAccountCurrentHp = this.getPlayerMaxHp();
                }
                
                logMessage("R√©cup√©ration termin√©e !");
                this.updateDisplay();
            }
            return;
        }
        
        // 3. √âtat ATTENTE (C'est ici qu'on applique les Ph√©romones !)
    if (this.combatState === 'waiting') {
        
        // ‚úÖ ON UTILISE LA FONCTION DYNAMIQUE ICI
        // Elle calcule : Base (250ms) - Bonus Ph√©romones (ex: 50ms) = 200ms
        const dynamicDelay = this.getSpawnDelay(); 

        if (now - this.lastCombatTime >= dynamicDelay) {
            
            // On lance le combat seulement si on n'est pas d√©j√† dans un mode sp√©cial
            if (!this.towerState.isActive && !this.arenaState.active) {
                this.startCombat();
            }
        }
    }
        
        // 4. √âtat D√âMARRAGE (Animation "Ready..." -> Combat)
        if (this.combatState === 'starting') {
            if (now - this.combatStartTime >= this.combatStartDelay) {
                this.combatState = 'fighting';
                // On ne reset pas lastATBUpdate ici, car on utilise le deltaTime du moteur maintenant
                logMessage("Le combat commence !");
            }
        }
        
        // REMARQUE : Le bloc "if (fighting) { updateATB... }" a √©t√© supprim√© ici.
        // C'est maintenant updateHighFreqLogic qui s'en charge. C'est beaucoup plus propre.
    }

// === MOTEUR ATB ===

    // OPTIMISATION : updateATB (Version Finale & S√©curis√©e)
    updateATB(deltaTime) {
        // 1. S√âCURIT√â ANTI-CRASH & PAUSE
        if (this.combatState !== 'fighting' || !this.currentEnemy || !this.currentPlayerCreature || this.isAttacking) return;

        // 2. Calcul Vitesse JOUEUR
        const playerStats = this.getEffectiveStats();
        let playerSpeed = Number(playerStats.speed) || 1;

        // Statuts Joueur
        if (this.currentPlayerCreature.hasStatusEffect()) {
            const pType = this.currentPlayerCreature.statusEffect.type;
            if (pType === 'paralyzed') playerSpeed *= 15;
        }

        // 3. Calcul Vitesse ENNEMI
        let enemySpeed = Number(this.currentEnemy.speed) || 1;
        
        // Statuts Ennemi
        if (this.currentEnemy.hasStatusEffect()) {
            const eType = this.currentEnemy.statusEffect.type;
            if (eType === 'paralyzed') enemySpeed *= 15; 
            if (eType === 'enraged') enemySpeed *= 1.15;   
        }

        // 4. Normalisation
        const maxSpeed = Math.max(playerSpeed, enemySpeed, 1);

        // ---------------------------------------------------------
        // ‚úÖ CORRECTION CRITIQUE (D√©finition de BASE_TURN_TIME)
        // ---------------------------------------------------------
        let baseTimeRef = 1000; // Valeur de secours
        if (typeof GAME_SPEEDS !== 'undefined') {
            baseTimeRef = GAME_SPEEDS.BASE_TURN_TIME;
        }
        
        // En ar√®ne, on acc√©l√®re un peu le rythme (x0.8 temps = plus vite)
        let BASE_TURN_TIME = (this.arenaState.active || this.towerState.active)? baseTimeRef * 1.5: baseTimeRef;
        
        
        // ---------------------------------------------------------
        
        // Seuils
        const pThreshold = this.currentPlayerCreature.actionThreshold || 10000;
        const eThreshold = this.currentEnemy.actionThreshold || 10000;

        // Gains
        const pTickRate = pThreshold / BASE_TURN_TIME;
        const eTickRate = eThreshold / BASE_TURN_TIME;

        const playerGain = pTickRate * (playerSpeed / maxSpeed) * deltaTime;
        const enemyGain = eTickRate * (enemySpeed / maxSpeed) * deltaTime;

        // Application
        if (Number.isFinite(playerGain)) this.currentPlayerCreature.actionGauge += playerGain;
        if (Number.isFinite(enemyGain)) this.currentEnemy.actionGauge += enemyGain;

        // Plafond (500% pour permettre le stack x5)
        const maxGauge = 50000; 
        if (this.currentPlayerCreature.actionGauge > maxGauge) this.currentPlayerCreature.actionGauge = maxGauge;
        if (this.currentEnemy.actionGauge > maxGauge) this.currentEnemy.actionGauge = maxGauge;

        // D√©clenchement
        this.processPendingAttacks();
    }
    

processPendingAttacks() {
        const now = Date.now();
        const p = this.currentPlayerCreature;
        const e = this.currentEnemy;

        if (!p || !e) return;

        // ‚úÖ TEMPO VISUEL FIXE (La "Pause" que vous aimez)
        // On force un d√©lai de 500ms entre chaque action, peu importe la vitesse du compte.
        // Cela cr√©e le rythme lisible.
        const VISUAL_DELAY = 500; 

        if (now - this.lastCombatTurnTime < VISUAL_DELAY) {
            return; // On attend que l'animation "respire"
        }

        const pReady = p.actionGauge >= p.actionThreshold;
        const eReady = e.actionGauge >= e.actionThreshold;

        // Logique de priorit√© (Qui vide son stock en premier ?)
        if (pReady && eReady) {
            // Si les deux ont du stock, celui qui en a le plus joue
            if (p.actionGauge >= e.actionGauge) {
                this.executeCreatureTurn(p, e, true, now);
            } else {
                this.executeCreatureTurn(e, p, false, now);
            }
        } 
        else if (pReady) {
            this.executeCreatureTurn(p, e, true, now);
        } 
        else if (eReady) {
            this.executeCreatureTurn(e, p, false, now);
        }
    }

    // LOGIQUE : Ex√©cution d'un tour (Attaque ou Statut)
    executeCreatureTurn(attacker, target, isPlayer, now) {
        // 1. D√©finition des constantes de temps (Fallback si GAME_SPEEDS n'existe pas encore)
        const PRE_DELAY = (typeof GAME_SPEEDS !== 'undefined') ? GAME_SPEEDS.PRE_ATTACK_DELAY : 500;
        const ANIM_DELAY = (typeof GAME_SPEEDS !== 'undefined') ? GAME_SPEEDS.ANIMATION_LOCK : 800;
        
        const threshold = attacker.actionThreshold || 10000;

        // 2. A-t-on assez d'√©nergie ?
        if (attacker.actionGauge >= threshold) {
            
            // 3. Le M√©tronome : On temporise pour que l'≈ìil humain suive
            if (now - this.lastCombatTurnTime < PRE_DELAY) {
                return; // On attend encore un peu
            }

            // üõë 4. FEU ROUGE : ON BLOQUE L'ATB GLOBAL
            // C'est ici que la barre ATB arr√™te visuellement de monter
            this.isAttacking = true;

            // 5. PAIEMENT DU CO√õT
            // On soustrait le seuil (on garde le surplus pour le prochain tour)
            attacker.actionGauge -= threshold;
            this.lastCombatTurnTime = now;

            // ============================================================
            // 6. GESTION DES STATUTS BLOQUANTS (Gel, Sommeil, √âtourdissement)
            // ============================================================
            // On v√©rifie si la cr√©ature peut r√©ellement agir
            // Note : On utilise canAttack() que tu as ajout√© dans Creature.js
            if (attacker.canAttack && !attacker.canAttack()) {
                
                let icon = "üö´";
                const type = attacker.statusEffect.type;
                if (type === 'frozen') icon = "‚ùÑÔ∏è";
                else if (type === 'stunned') icon = "üí´";
                else if (type === 'sleep') icon = "üí§";

                // Feedback Visuel
                const containerId = isPlayer ? 'playerSpriteContainer' : 'enemySpriteContainer';
                const container = document.getElementById(containerId);
                if (container && window.showFloatingText) {
                    window.showFloatingText(icon, container, 'ft-status');
                }
                
                logMessage(`${attacker.name} est bloqu√© (${type}) et passe son tour !`);

                // ‚ö° R√âDUCTION DE DUR√âE (CRITIQUE)
                // Comme on saute performAttackWithBonus, on doit r√©duire la dur√©e ici
                if (attacker.statusEffect.duration > 0) {
                    attacker.statusEffect.duration--;
                    if (attacker.statusEffect.duration <= 0) {
                        const oldType = attacker.statusEffect.type;
                        attacker.statusEffect = { type: 'none', duration: 0 };
                        logMessage(`‚ú® ${attacker.name} n'est plus ${oldType} !`);
                    }
                }

                // On rend la main plus vite (300ms) car il n'y a pas d'animation d'attaque
                setTimeout(() => {
                    this.isAttacking = false; // üü¢ FEU VERT
                    this.processPendingAttacks(); // On v√©rifie si l'autre peut jouer
                }, 300);

                return; // üõë FIN DU TOUR (Pas de d√©g√¢ts)
            }

            // ============================================================
            // 7. EX√âCUTION DE L'ATTAQUE (Si on peut bouger)
            // ============================================================
            
            const isDead = this.performAttackWithBonus(
                attacker, 
                target, 
                this.arenaState.active ? null : this.playerMainStats, 
                isPlayer, 
                false 
            );
            
            // 8. FIN DE L'ANIMATION ET RELANCE
            setTimeout(() => {
                // Si le combat est fini, on ne relance pas l'ATB
                if (isDead) {
                    this.isAttacking = false;
                    if (isPlayer) this.winCombat();
                    else this.playerCreatureFainted();
                } else {
                    // Sinon, on lib√®re le feu rouge
                    this.isAttacking = false; // üü¢ FEU VERT
                    this.processPendingAttacks(); // Au suivant !
                }
            }, ANIM_DELAY);
        }
    }
  

 // ‚úÖ REMPLACEZ startCombat (index.html)
startCombat() {
 this.sessionStats.combatStartTime = Date.now();
 this.faintedThisCombat = new Set();
this.currentPlayerCreature = null;

    // Logique de s√©lection (inchang√©e)
if (this.activeCreatureIndex < this.playerTeam.length && this.playerTeam[this.activeCreatureIndex].isAlive()) {
this.currentPlayerCreature = this.playerTeam[this.activeCreatureIndex];
} else {
this.currentPlayerCreature = this.getFirstAliveCreature();
if (this.currentPlayerCreature) {
this.activeCreatureIndex = this.playerTeam.indexOf(this.currentPlayerCreature);
}
}

   // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è AJOUTEZ CE BLOC DE CODE ICI ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
        if (!this.currentPlayerCreature) {
            // Aucune cr√©ature vivante n'a √©t√© trouv√©e, on ne peut pas d√©marrer le combat.
            // On se met en √©tat de r√©cup√©ration pour r√©animer l'√©quipe.
            this.combatState = 'dead'; 
            this.lastCombatTime = Date.now();
            return; // On arr√™te la fonction startCombat ici.
        }
		
		this.currentPlayerCreature.recalculateStats();

this.currentPlayerCreature.actionGauge = 0;
this.currentPlayerCreature.mainAccountCurrentHp = this.getPlayerMaxHp();
				
this.currentEnemy = this.getOrCreateEnemy();
this.combatState = 'starting';
this.combatStartTime = Date.now();

logMessage("Combat contre " + this.currentEnemy.name + " niveau " + this.currentEnemy.level + " - Preparation...");

if (this.autoSelectEnabled) {
const bestIndex = this.findBestCreatureForEnemy();
if (bestIndex !== -1 && bestIndex !== this.activeCreatureIndex) {
this.setActiveCreature(bestIndex);
}
}
}

            getOrCreateEnemy() {
			if (this.pendingRoamer) {
            const name = this.pendingRoamer;
            this.pendingRoamer = null; // On consomme l'√©v√©nement
            
            const type = this.findTypeForPokemon(name);
            const secondaryType = POKEMON_SECONDARY_TYPES[name] || null;
            const zone = ZONES[currentZone];
            
            // Le Roamer est toujours un peu plus fort que la zone actuelle (+5 niveaux)
            const level = zone.levelRange[1] + 5;
            
            // On le cr√©e comme un Boss L√©gendaire
            const roamer = new Creature(name, type, level, RARITY.LEGENDARY, true, false, secondaryType, true, false);
			roamer.isRoaming = true;
            
            // Stats boost√©es mais moins qu'un Boss de fin de zone (x30 au lieu de x50)
            roamer.zoneMultiplier = zone.multiplier * 30;
           
            
            roamer.recalculateStats();
            roamer.heal();
            
            logMessage(`‚ú® UN POK√âMON VAGABOND APPARA√éT : ${name} !`);
            return roamer;
        }
        const zone = ZONES[currentZone];
		
        
        // 1. Boss / Epic (Inchang√©)
        const isBossTime = Math.random() < 0.01;
        const isEpicTime = !isBossTime && Math.random() < 0.025;
        if (isBossTime) return this.createBoss();
        if (isEpicTime) return this.createEpic();
        
        // 2. CONSTRUCTION DU POOL DYNAMIQUE (M√©thode Pok√©Clicker adapt√©e)
        let enemyPool = [];
        const zoneData = ZONE_POKEMON[currentZone];

        if (Array.isArray(zoneData)) {
            // Cas A : Ancien format (Juste une liste)
            enemyPool = zoneData;
        } else if (typeof zoneData === 'object') {
            // Cas B : Format Structur√© (Land / Water / Fishing)
            
            // 1. Terre (Toujours disponible)
            if (zoneData.land) enemyPool = enemyPool.concat(zoneData.land);
            
            // 2. Surf (Requiert l'objet 'surfboard')
            // (Tu peux aussi utiliser le badge Koga si tu pr√©f√®res)
            if (this.items['surfboard'] > 0 && zoneData.water) {
                enemyPool = enemyPool.concat(zoneData.water);
            }
            
            // 3. P√™che (Requiert l'objet 'old_rod' ou 'super_rod')
            if ((this.items['old_rod'] > 0 || this.items['super_rod'] > 0) && zoneData.fishing) {
                enemyPool = enemyPool.concat(zoneData.fishing);
            }
        }

        // S√©curit√© : Si le pool est vide (erreur de config), on met un Magicarpe
        if (!enemyPool || enemyPool.length === 0) {
            console.warn(`Zone ${currentZone} vide ou mal configur√©e. Fallback Magikarp.`);
            enemyPool = ['Magikarp'];
        }

        // 3. Cr√©ation Standard
        const randomName = enemyPool[Math.floor(Math.random() * enemyPool.length)];
        const randomType = this.findTypeForPokemon(randomName);
        const secondaryType = POKEMON_SECONDARY_TYPES[randomName] || null;
        
        // Niveau
        const level = Math.floor(Math.random() * (zone.levelRange[1] - zone.levelRange[0] + 1)) + zone.levelRange[0];

        // Instance
        // Note : On force la raret√© naturelle ici pour √©viter le bug du Snorlax "Common"
        const trueRarity = this.getNaturalRarity(randomName);
        const enemy = new Creature(randomName, randomType, level, trueRarity, true, false, secondaryType);

        // Tiering
        const savedTier = this.zoneProgress[currentZone].pokemonTiers[enemy.name] || 0;
        enemy.tier = savedTier;

        // Multiplicateurs de Zone
        enemy.zoneMultiplier = zone.multiplier * 10;
        
        // 4. ‚úÖ CALCUL ET SOIN (Le Fix est ici)
        enemy.recalculateStats(); 
        enemy.heal(); // FORCE les PV Actuels √† √™tre √©gaux aux PV Max
        
        return enemy;
    }
	
	/**
     * R√©cup√®re TOUS les Pok√©mon d'une zone (Liste plate).
     * Sert pour le calcul technique (Tiers, Chargement, etc.)
     */
    getAllPokemonInZone(zoneId) {
        if (typeof ZONE_POKEMON === 'undefined') return [];
        const zoneData = ZONE_POKEMON[zoneId];
        if (!zoneData) return [];

        // Cas simple (Tableau)
        if (Array.isArray(zoneData)) return zoneData;

        // Cas complexe (Objet Land/Water/Fishing)
        if (typeof zoneData === 'object') {
            let all = [];
            if (zoneData.land) all = all.concat(zoneData.land);
            if (zoneData.water) all = all.concat(zoneData.water);
            if (zoneData.fishing) all = all.concat(zoneData.fishing);
            // On d√©doublonne pour √©viter les erreurs de comptage
            return [...new Set(all)];
        }
        return [];
    }
			
			// LOGIQUE : R√©cup√®re uniquement les Pok√©mon que le joueur PEUT rencontrer actuellement
    // (Exclut les poissons s'il n'a pas de canne, etc.)
    getReachablePokemonInZone(zoneId) {
        // S√©curit√©
        if (typeof ZONE_POKEMON === 'undefined') return [];
        const zoneData = ZONE_POKEMON[zoneId];
        if (!zoneData) return [];

        // Cas simple (Tableau)
        if (Array.isArray(zoneData)) return zoneData;

        // Cas complexe (Objets requis)
        let reachable = [];
        
        // 1. Terre (Toujours accessible)
        if (zoneData.land) reachable = reachable.concat(zoneData.land);
        
        // 2. Eau (Requis: Surfboard)
        if (this.items['surfboard'] > 0 && zoneData.water) {
            reachable = reachable.concat(zoneData.water);
        }
        
        // 3. P√™che (Requis: Canne)
        // On v√©rifie n'importe quelle canne
        if ((this.items['old_rod'] > 0 || this.items['super_rod'] > 0 || this.items['mega_rod'] > 0) && zoneData.fishing) {
            reachable = reachable.concat(zoneData.fishing);
        }

        return [...new Set(reachable)]; // Retire les doublons
    }
	
			
           setupEggHandler() {
    let isProcessingEgg = false;
    
    document.addEventListener('click', (event) => {
        if (isProcessingEgg) return;
        
        let target = event.target;
        let eggElement = null;
        
        for (let i = 0; i < 5 && target; i++) {
            if (target.classList && target.classList.contains('egg-clickable')) {
                eggElement = target;
                break;
            }
            target = target.parentElement;
        }
        
        if (!eggElement) return;
        
        const rarity = eggElement.getAttribute('data-rarity');
        if (!rarity) return;
        
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        
        isProcessingEgg = true;
        
        // ‚úÖ D√âSACTIVER temporairement les logs pour √©viter les ralentissements
        const originalLogFunction = window.logMessage;
        let eggsOpened = 0;
        
        // Ctrl+Clic : Ouvrir maximum 100 ≈ìufs
        if (event.ctrlKey || event.metaKey) {
            const maxToOpen = Math.min(100, this.eggs[rarity]);
            if (maxToOpen > 0) {
                // ‚úÖ D√©sactiver les logs pendant l'ouverture massive
                window.logMessage = function() {};
                
                logMessage(`Ouverture de ${maxToOpen} ≈ìufs ${rarity}...`);
                
                for (let i = 0; i < maxToOpen; i++) {
                    this.openEgg(rarity);
                    eggsOpened++;
                }
                
                // ‚úÖ R√©activer les logs
                window.logMessage = originalLogFunction;
                logMessage(`‚úÖ ${eggsOpened} ≈ìufs ${rarity} ouverts !`);
            }
        }
        // Shift+Clic : Ouvrir 5 ≈ìufs
        else if (event.shiftKey) {
            const maxToOpen = Math.min(5, this.eggs[rarity]);
            for (let i = 0; i < maxToOpen; i++) {
                if (this.eggs[rarity] > 0) {
                    this.openEgg(rarity);
                }
            }
        }
        // Clic simple : Ouvrir 1 ≈ìuf
        else {
            this.openEgg(rarity);
        }
        
        // ‚úÖ Mettre √† jour l'affichage UNE SEULE FOIS √† la fin
        this.updateEggsDisplay();
        this.updateTeamDisplay();
        this.updatePlayerStatsDisplay();
        this.updatePokedexDisplay();
        this.updateStorageDisplay();
        
        setTimeout(() => {
            isProcessingEgg = false;
        }, 100);
    }, true);
}
          
		  
		  // Gestion du Modal Logs
    openLogModal() {
        console.log("üñ±Ô∏è Clic re√ßu : Tentative d'ouverture du Journal...");
        
        const modal = document.getElementById('logModal');
        if (modal) {
            modal.classList.add('show');
            
            // Scroll en bas
            const container = document.getElementById('gameLog');
            if (container) container.scrollTop = container.scrollHeight;
            
            console.log("‚úÖ Journal ouvert !");
        } else {
            console.error("‚ùå ERREUR CRITIQUE : L'√©l√©ment HTML <div id='logModal'> est introuvable !");
            alert("Erreur : Le modal de logs n'existe pas dans le HTML.");
        }
    }

    closeLogModal() {
        const modal = document.getElementById('logModal');
        if(modal) modal.classList.remove('show');
    }

    clearLogs() {
        const div = document.getElementById('gameLog');
        if(div) div.innerHTML = '<div class="log-entry" style="color:#666;">Journal vid√©.</div>';
    }
	

            regenerateStamina() {
                const now = Date.now();
                const regenTime = this.getStaminaRegenTime();
                
                if (this.combatState === 'waiting' || this.combatState === 'dead') {
                    if (now - this.lastStaminaRegen >= regenTime) {
                        this.lastStaminaRegen = now;
                        
                        for (const creature of this.playerTeam) {
                            if (creature.currentStamina < creature.maxStamina) {
                                creature.currentStamina++;
                            }
                        }
                        
                        this.updateTeamDisplay();
                    }
                }
            }

            startAutoSave() {
    setInterval(() => {
        this.saveGame();
        
        const indicator = document.getElementById('autoSaveIndicator');
        if (indicator) {
            const time = new Date().toLocaleTimeString();
            // On garde le point vert (.auto-save-dot) et on change juste le texte √† c√¥t√©
            indicator.innerHTML = `<span class="auto-save-dot"></span> Sauvegard√© √† ${time}`;
            
            // Petit effet visuel (flash vert sur le texte)
            indicator.style.color = "#16a34a";
            setTimeout(() => {
                indicator.style.color = "#94a3b8"; // Revient au gris
            }, 1000);
        }
    }, 15000); // Toutes les 15 secondes
}

      
incrementPlayerStats() {
    this.calculateTeamStats();
    const pensionStats = this.calculatePensionStats();

    const hpBonus = 1 + this.getAccountTalentBonus('hp_mult');
    
    const baseContribution = 0.10;
    const towerBonus = this.permanentBoosts.team_contribution || 0;
    const teamContributionRate = baseContribution + towerBonus;
    
    // ‚úÖ AJOUTER LES BONUS DES VITAMINES ICI
    const vitaminBonus = {
        hp: 1 + (this.activeVitamins.hp || 0) + (this.activeVitamins.all || 0),
        attack: 1 + (this.activeVitamins.attack || 0) + (this.activeVitamins.all || 0),
        defense: 1 + (this.activeVitamins.defense || 0) + (this.activeVitamins.all || 0),
        speed: 1 + (this.activeVitamins.speed || 0) + (this.activeVitamins.all || 0)
    };
    
    // A. √âquipe avec vitamines
    this.playerMainStats.hp += Math.floor(this.playerTeamStats.hp * teamContributionRate * hpBonus * vitaminBonus.hp);
    this.playerMainStats.attack += Math.floor(this.playerTeamStats.attack * teamContributionRate * vitaminBonus.attack);
    this.playerMainStats.defense += Math.floor(this.playerTeamStats.defense * teamContributionRate * vitaminBonus.defense);
    this.playerMainStats.speed += Math.floor(this.playerTeamStats.speed * teamContributionRate * vitaminBonus.speed);

    // B. Pension avec vitamines
    this.playerMainStats.hp += Math.floor(pensionStats.hp * hpBonus * vitaminBonus.hp);
    this.playerMainStats.attack += Math.floor(pensionStats.attack * vitaminBonus.attack);
    this.playerMainStats.defense += Math.floor(pensionStats.defense * vitaminBonus.defense);
    this.playerMainStats.speed += Math.floor(pensionStats.speed * vitaminBonus.speed);
    
    this.updatePlayerStatsDisplay();
}

            
calculateTeamStats() {
    this.playerTeamStats = { hp: 0, attack: 0, defense: 0, speed: 0 };
    
    // √âtape 1 : On additionne d'abord les stats de base de chaque cr√©ature
    for (const creature of this.playerTeam) {
        this.playerTeamStats.hp += creature.maxHp;
        this.playerTeamStats.attack += creature.attack;
        this.playerTeamStats.defense += creature.defense;
        this.playerTeamStats.speed += creature.speed;
    }
    
    // √âtape 2 : APR√àS avoir calcul√© le total, on applique le bonus d'Aura une seule fois
    const auraBonus = this.getTalentStackBonus('aura');
    if (auraBonus > 0) {
        this.playerTeamStats.attack = Math.floor(this.playerTeamStats.attack * (1 + auraBonus));
        this.playerTeamStats.defense = Math.floor(this.playerTeamStats.defense * (1 + auraBonus));
        this.playerTeamStats.speed = Math.floor(this.playerTeamStats.speed * (1 + auraBonus));
    }
}


calculatePensionStats() {
    const pensionContribution = { hp: 0, attack: 0, defense: 0, speed: 0 };
    const pensionRate = this.getPensionTransferRate(); // C'est ici que le 1% par niveau est calcul√©

    if (pensionRate > 0) {
        for (const creature of this.pension) {
            pensionContribution.hp += Math.floor(creature.maxHp * pensionRate);
            pensionContribution.attack += Math.floor(creature.attack * pensionRate);
            pensionContribution.defense += Math.floor(creature.defense * pensionRate);
            pensionContribution.speed += Math.floor(creature.speed * pensionRate);
        }
    }
    return pensionContribution;
}

// OPTIMISATION : Calcul des stats avec prise en compte des Statuts (Nerf Paralysie)
    getEffectiveStats() {
        let hpBoost = 1;
        let attackBoost = 1;
        let defenseBoost = 1;
        let speedBoost = 1;
        
        // 1. Boosts temporaires (Potions)
        this.activeStatBoosts.forEach(boost => {
            if (boost.stat === 'all') {
                hpBoost += boost.value; attackBoost += boost.value; defenseBoost += boost.value; speedBoost += boost.value;
            } else if (boost.stat === 'hp') hpBoost += boost.value;
            else if (boost.stat === 'attack') attackBoost += boost.value;
            else if (boost.stat === 'defense') defenseBoost += boost.value;
            else if (boost.stat === 'speed') speedBoost += boost.value;
        });

        // 2. Synergies d'√©quipe
        const synergies = this.getActiveSynergies();
        hpBoost += (synergies.max_hp_mult - 1);
        attackBoost += (synergies.attack_mult - 1);
        defenseBoost += (synergies.defense_mult - 1);
        speedBoost += (synergies.speed_mult ? synergies.speed_mult - 1 : 0);

        // 3. Objets Tenus (Par le Pok√©mon actif)
        if (this.currentPlayerCreature && this.currentPlayerCreature.heldItem) {
            const item = HELD_ITEMS[this.currentPlayerCreature.heldItem];
            if (item && item.effect) {
                if (item.effect.attack_mult) attackBoost += item.effect.attack_mult;
                if (item.effect.speed_mult) speedBoost += item.effect.speed_mult;
            }
        }

        // 4. Reliques de Tour
        if (this.towerState.isActive && this.towerState.buffs) {
            const buffs = this.towerState.buffs;
            if (buffs.attack_mult) attackBoost *= buffs.attack_mult;
            if (buffs.defense_mult) defenseBoost *= buffs.defense_mult;
            if (buffs.speed_mult) speedBoost *= buffs.speed_mult;
        }

        // 5. ‚úÖ STATUTS DU POK√âMON ACTIF (C'est ici qu'on applique le nerf)
        if (this.currentPlayerCreature && this.currentPlayerCreature.hasStatusEffect()) {
            const type = this.currentPlayerCreature.statusEffect.type;
            
            // NERF : La paralysie r√©duit la vitesse de 25% (x15) au lieu de 50%
            if (type === STATUS_EFFECTS.PARALYZED) speedBoost *= 15;
            
            // BUFF : Enrag√© augmente la vitesse de 15%
            if (type === STATUS_EFFECTS.ENRAGED) speedBoost *= 1.15;
        }
        
        // --- S√âLECTION DE LA BASE DE STATS ---
        let baseHp, baseAttack, baseDefense, baseSpeed;

        if (this.arenaState.active && this.currentPlayerCreature) {
            // üèüÔ∏è MODE AR√àNE : Stats Individuelles
            baseHp = this.currentPlayerCreature.maxHp;
            baseAttack = this.currentPlayerCreature.attack;
            baseDefense = this.currentPlayerCreature.defense;
            baseSpeed = this.currentPlayerCreature.speed;
        } else {
            // üåç MODE ZONE : Stats du Compte
            baseHp = this.playerMainStats.hp;
            baseAttack = this.playerMainStats.attack;
            baseDefense = this.playerMainStats.defense;
            baseSpeed = this.playerMainStats.speed;
        }
        
        // Calcul final
        return {
            hp: Math.floor(baseHp * hpBoost),
            attack: Math.floor(baseAttack * attackBoost),
            defense: Math.floor(baseDefense * defenseBoost),
            speed: Math.floor(baseSpeed * speedBoost)
        };
    }

updateStatBoosts() {
    const now = Date.now();
    
    // Retirer les boosts expir√©s
    this.activeStatBoosts = this.activeStatBoosts.filter(boost => {
        if (boost.endTime <= now) {
            logMessage(`‚è±Ô∏è Boost ${boost.stat.toUpperCase()} expir√© !`);
            return false;
        }
        return true;
    });
    
    this.updateStatBoostsDisplay();
}

// UTILITAIRE : Trouve le type (Sans crasher)
    findTypeForPokemon(name) {
        if (!name) return 'normal'; // Fallback ultime

        // Recherche dans POKEMON_BASE_STATS (si le type y est stock√©, ce qui serait mieux)
        // Sinon, on cherche dans les pools par raret√© comme avant
        
        for (const [rarity, pool] of Object.entries(POKEMON_POOL)) {
            for (const [type, names] of Object.entries(pool)) {
                if (names.includes(name)) return type;
            }
        }
        
        // Si non trouv√© (cas des nouveaux pok√©mons gen 4 non class√©s), on renvoie normal pour ne pas crasher
        // Id√©alement, il faudrait une table POKEMON_TYPES compl√®te.
        console.warn(`Type inconnu pour ${name}, d√©faut: normal`);
        return 'normal';
    }


toggleRarePause() {
    this.pauseOnRare = !this.pauseOnRare;
    this.saveGame();

    const state = this.pauseOnRare ? "ACTIV√âE" : "D√âSACTIV√âE";
    const color = this.pauseOnRare ? "success" : "error"; // Rouge pour dire "Danger"

    if (typeof toast !== 'undefined') {
        if (this.pauseOnRare) toast.success("S√©curit√© Activ√©e", "Le jeu s'arr√™tera sur les Shinies/L√©gendaires.");
        else toast.error("Mode Tueur", "Le jeu TUERA les Shinies/L√©gendaires en mode AFK !");
    }

    this.openSaveManager();
this.updateOptionButtons();	
}



   
   

            // LOGIQUE : Cr√©ation d'un Boss de Zone (Version "Alpha Local")
    // LOGIQUE : Cr√©ation d'un Boss de Zone (Version Filtr√©e par √âquipement)
    createBoss() {
        const zone = ZONES[currentZone];
        
        // ‚úÖ CORRECTIF : On ne pioche que parmi les Pok√©mon ACCESSIBLES
        // Si pas de canne, pas de Boss Magicarpe.
        const localPool = this.getReachablePokemonInZone(currentZone);
        
        let name = 'Mewtwo'; // Fallback
        if (localPool && localPool.length > 0) {
            name = localPool[Math.floor(Math.random() * localPool.length)];
        }

        // 2. Configuration
        const level = zone.levelRange[1] + 10;
        const type = this.findTypeForPokemon(name);
        const secondaryType = POKEMON_SECONDARY_TYPES[name] || null;
        
        // 3. Cr√©ation
        const enemy = new Creature(name, type, level, RARITY.LEGENDARY, true, false, secondaryType, true, false);
        
        // 4. Boosts
        enemy.ivHP = 31; enemy.ivAttack = 31; enemy.ivDefense = 31; enemy.ivSpeed = 31;
        enemy.zoneMultiplier = zone.multiplier * 50;
        
         

        enemy.recalculateStats();
        enemy.heal();
        
        logMessage(`üíÄ BOSS DE ZONE : ${enemy.name} est apparu !`);
        return enemy;
    }

    // LOGIQUE : Cr√©ation d'un √âpique de Zone (Version "Elite Local")
    // LOGIQUE : Cr√©ation d'un √âpique de Zone (Version Filtr√©e par √âquipement)
    createEpic() {
        const zone = ZONES[currentZone];
        
        // ‚úÖ CORRECTIF : On utilise getReachablePokemonInZone
        const localPool = this.getReachablePokemonInZone(currentZone);
        
        let name = 'Snorlax';
        if (localPool && localPool.length > 0) {
            name = localPool[Math.floor(Math.random() * localPool.length)];
        }

        // 2. Configuration
        const level = zone.levelRange[1] + 5;
        const type = this.findTypeForPokemon(name);
        const secondaryType = POKEMON_SECONDARY_TYPES[name] || null;
        
        // 3. Cr√©ation
        const enemy = new Creature(name, type, level, RARITY.EPIC, true, false, secondaryType, false, true);
        
        // 4. Boosts
        enemy.ivHP = 25; enemy.ivAttack = 25; enemy.ivDefense = 25; enemy.ivSpeed = 25;
        enemy.zoneMultiplier = zone.multiplier * 20;
        
        

        enemy.recalculateStats();
        enemy.heal();
        
        logMessage(`‚ö†Ô∏è UN POK√âMON √âLITE APPARA√éT : ${enemy.name} !`);
        return enemy;
    }

            processCombatTurn() {
    if (!this.currentPlayerCreature || !this.currentEnemy) return;

    // --- üõ°Ô∏è S√âCURIT√â ANTI-BUG (Auto-Fix) ---
    // Si la jauge n'existe pas ou est NaN, on la force √† 0 imm√©diatement
    if (typeof this.currentPlayerCreature.actionGauge !== 'number' || isNaN(this.currentPlayerCreature.actionGauge)) {
        this.currentPlayerCreature.actionGauge = 0;
    }
    if (typeof this.currentEnemy.actionGauge !== 'number' || isNaN(this.currentEnemy.actionGauge)) {
        this.currentEnemy.actionGauge = 0;
    }

    // --- 1. Gestion du Temps (Delta Time) ---
    const now = Date.now();
    // Si lastATBUpdate n'existe pas (premier tour), on prend 'now' pour √©viter un saut g√©ant
    if (!this.lastATBUpdate) this.lastATBUpdate = now;
    
    // Temps √©coul√© en secondes (ex: 0.016s pour 60fps)
    const deltaTime = (now - this.lastATBUpdate) / 1000;
    this.lastATBUpdate = now;

    // Si le jeu a lagu√© (pause, changement onglet), on cap le delta pour √©viter un one-shot instantan√©
    if (deltaTime > 1.0) return; 

    const ACTION_THRESHOLD = 1000;

    // --- 2. Calcul des Vitesses ---
    const playerStats = this.getEffectiveStats();
    let playerSpeed = playerStats.speed;
    let enemySpeed = this.currentEnemy.speed;

    // Statuts (Paralysie/Gel)
    if (this.currentPlayerCreature.hasStatusEffect()) {
        if (this.currentPlayerCreature.statusEffect.type === 'paralyzed') playerSpeed *= 0.5;
        if (this.currentPlayerCreature.statusEffect.type === 'frozen') playerSpeed = 0;
    }
    if (this.currentEnemy.hasStatusEffect()) {
        if (this.currentEnemy.statusEffect.type === 'paralyzed') enemySpeed *= 0.5;
        if (this.currentEnemy.statusEffect.type === 'frozen') enemySpeed = 0;
    }

    // --- 3. Remplissage (Vitesse * Multiplicateur * Temps) ---
    // Multiplicateur 2.0 : Une vitesse de 500 remplit la jauge (1000) en 1 seconde.
    this.currentPlayerCreature.actionGauge += playerSpeed * 2.0 * deltaTime;
    this.currentEnemy.actionGauge += enemySpeed * 2.0 * deltaTime;

    // --- 4. Actions ---
    
    // JOUEUR
    while (this.currentPlayerCreature.actionGauge >= ACTION_THRESHOLD) {
        if (this.currentEnemy.currentHp <= 0) break; // Ennemi d√©j√† mort
        
        this.currentPlayerCreature.actionGauge -= ACTION_THRESHOLD;
        
        const hasMaitre = this.playerTeam.some(c => c.passiveTalent === 'maitre');
        const enemyDead = this.performAttackWithBonus(this.currentPlayerCreature, this.currentEnemy, this.playerMainStats, true, hasMaitre);
        
        if (enemyDead) {
            this.winCombat();
            return;
        }
    }

    // ENNEMI
    while (this.currentEnemy.actionGauge >= ACTION_THRESHOLD) {
        if (this.currentPlayerCreature.mainAccountCurrentHp <= 0) break; // Joueur d√©j√† mort
        
        this.currentEnemy.actionGauge -= ACTION_THRESHOLD;
        
        const playerDead = this.currentEnemy.performAttack(this.currentPlayerCreature, this.playerMainStats, false, this);
        
        if (playerDead) {
            this.playerCreatureFainted();
            return;
        }
    }
    
    // --- 5. DoT (D√©g√¢ts sur la dur√©e) ---
    // Ex√©cut√© une fois par seconde maximum
    if (!this.lastDotTime || now - this.lastDotTime >= 1000) {
        this.lastDotTime = now;
        
        const playerDot = this.currentPlayerCreature.processStatusEffect(this);
        if (playerDot.isDead) { this.playerCreatureFainted(); return; }
        
        const enemyDot = this.currentEnemy.processStatusEffect(this);
        if (enemyDot.isDead) { this.winCombat(); return; }
    }
}

simulateCombat() {
    // 1. S√©lection ou r√©cup√©ration du combattant
    if (!this.currentPlayerCreature || !this.currentPlayerCreature.isAlive()) {
        this.currentPlayerCreature = this.getFirstAliveCreature();
        if (!this.currentPlayerCreature) return null; 
    }
    
    // --- S√âCURIT√â 1 : Reset des PV Virtuels du Joueur ---
    // On s'assure que la cr√©ature commence avec ses PV actuels (ou Max selon ta logique)
    // Ici on suppose qu'elle commence Full vie pour la simulation simplifi√©e, 
    // ou alors this.currentPlayerCreature.currentHp si tu veux g√©rer l'usure entre les combats simul√©s.
    // Pour le rattrapage, le plus simple/juste est de dire qu'elle commence Full HP gr√¢ce au Heal post-combat.
    this.currentPlayerCreature.mainAccountCurrentHp = this.currentPlayerCreature.maxHp; 
    
    // 2. Gestion Ennemi
    const enemy = this.getOrCreateEnemy();
    if (enemy.isBoss || enemy.isEpic) return null; 
    
    // --- S√âCURIT√â 2 : Reset des PV de l'Ennemi (CRUCIAL) ---
    // Si l'objet 'enemy' est r√©utilis√© par le cache, il faut le soigner !
    enemy.currentHp = enemy.maxHp;

    // Sauvegarde du contexte
    const previousEnemy = this.currentEnemy; 
    this.currentEnemy = enemy; 

    // --- 3. Initialisation des Stats (AVANT la boucle) ---
    // On r√©cup√®re les stats de la cr√©ature ACTUELLE
    let currentStats = this.getEffectiveStats(); 
    let playerSpeed = currentStats.speed;
    let hasRobustesse = this.currentPlayerCreature.passiveTalent === 'robustesse';
    
    // ATB
    let simPlayerGauge = 0;
    let simEnemyGauge = 0;
    const threshold = 10000;
    const enemySpeed = enemy.speed;
    
    let turns = 0;
    const maxTurns = 200; 

    // --- 4. Boucle de Combat ---
    while (turns < maxTurns) {
        turns++;
        
        // Saut temporel
        const ticksToPlayer = Math.max(0, threshold - simPlayerGauge) / playerSpeed;
        const ticksToEnemy = Math.max(0, threshold - simEnemyGauge) / enemySpeed;
        const timeJump = Math.min(ticksToPlayer, ticksToEnemy);
        
        simPlayerGauge += playerSpeed * timeJump + 0.01;
        simEnemyGauge += enemySpeed * timeJump + 0.01;

        // --- TOUR JOUEUR ---
        if (simPlayerGauge >= threshold) {
            simPlayerGauge -= threshold;
            const dmg = this.calculateSimulatedDamageForCatchup(
                currentStats.attack, // Utilise la stat mise √† jour
                enemy.defense, 
                this.currentPlayerCreature.type, 
                enemy.type, 
                true, 
                hasRobustesse
            );
            enemy.currentHp -= dmg;
            
            if (enemy.currentHp <= 0) {
                const result = this.processSimulatedVictory(enemy);
                this.currentEnemy = previousEnemy;
                return result; 
            }
            continue; 
        }

        // --- TOUR ENNEMI ---
        if (simEnemyGauge >= threshold) {
            simEnemyGauge -= threshold;
            const dmg = this.calculateSimulatedDamageForCatchup(
                enemy.attack, 
                currentStats.defense, // Utilise la stat mise √† jour
                enemy.type, 
                this.currentPlayerCreature.type, 
                false, 
                false
            );
            
            this.currentPlayerCreature.mainAccountCurrentHp -= dmg;
            
            if (this.currentPlayerCreature.mainAccountCurrentHp <= 0) {
                // KO
                this.faintedThisCombat.add(this.activeCreatureIndex);
                
                // Swap
                this.currentPlayerCreature = this.getFirstAliveCreature();
                
                if (!this.currentPlayerCreature) {
                    this.processSimulatedDefeat();
                    this.currentEnemy = previousEnemy;
                    return null; 
                }
                
                // Setup nouvelle cr√©ature
                this.currentPlayerCreature.mainAccountCurrentHp = this.currentPlayerCreature.maxHp;
                this.activeCreatureIndex = this.playerTeam.indexOf(this.currentPlayerCreature);
                simPlayerGauge = 0; 

                // --- S√âCURIT√â 3 : Mise √† jour des Stats apr√®s Swap ---
                currentStats = this.getEffectiveStats(); 
                playerSpeed = currentStats.speed;
                hasRobustesse = this.currentPlayerCreature.passiveTalent === 'robustesse';
            }
        }
    }
    
    // Timeout
    this.processSimulatedDefeat(); 
    this.currentEnemy = previousEnemy;
    return null;
}
    

calculateSimulatedDamage(attack, defense, attackerType, defenderType, isPlayer) {
    // 1. Efficacit√© des types (avec double type si disponible)
    let effectiveness = TYPE_EFFECTIVENESS[attackerType]?.[defenderType] || 1;
    
    // Si la cible a un type secondaire, multiplier aussi
    if (!isPlayer && this.currentEnemy && this.currentEnemy.secondaryType) {
        const secondaryEffectiveness = TYPE_EFFECTIVENESS[attackerType]?.[this.currentEnemy.secondaryType] || 1;
        effectiveness *= secondaryEffectiveness;
    }
    
    // Si l'attaquant joueur a un type secondaire
    if (isPlayer && this.currentPlayerCreature && this.currentPlayerCreature.secondaryType) {
        // Le type secondaire peut aussi donner le STAB
    }
    
    // 2. STAB (Same Type Attack Bonus)
    let stab = 1.0;
    if (isPlayer && this.currentPlayerCreature) {
        // V√©rifier si l'attaque correspond au type primaire ou secondaire
        const hasStab = this.currentPlayerCreature.type === attackerType || 
                       (this.currentPlayerCreature.secondaryType && this.currentPlayerCreature.secondaryType === attackerType);
        
        if (hasStab) {
            stab = 1.2;
            
            // Ma√Ætre √âl√©mentaire (+20% de bonus STAB)
            let stab = 1.2;
if (game) {
    const maitreBonus = game.getTalentStackBonus('maitre');
    if (maitreBonus > 0) {
        stab = 1.2 * (1 + maitreBonus); // 1.2 * 1.2 = 1.44 pour 1 Ma√Ætre
    }
}
        }
    }
    
    // 3. Talents de compte (badges d'ar√®ne)
    let damageMultiplier = 1.0;
    if (isPlayer) {
        // Power: +5% d√©g√¢ts inflig√©s
        damageMultiplier = 1 + this.getAccountTalentBonus('damage_mult');
    } else {
        // Resilience: -5% d√©g√¢ts re√ßus
        damageMultiplier = 1 - this.getAccountTalentBonus('damage_reduction');
    }
    
    // 4. Bonus HP de Vitality (d√©j√† appliqu√© dans playerMainStats normalement)
    // Pas besoin de le r√©appliquer ici
    
    // 1. Calcul de l'Attaque Totale (Avec tous les bonus)
    const totalAttack = attack * effectiveness * stab * bonusMult;

    // 2. Formule de R√©duction Dynamique (Ratio)
    // Si Def = Atk, on prend 50% des d√©g√¢ts. Si Def = 0, on prend 100%.
    const mitigation = attack / (attack + defense*1.25);
    
    const damage = Math.floor(totalAttack * mitigation);
    
    return Math.max(1, damage);
}
    
    calculateSimulatedDamageForCatchup(attack, defense, attackerType, defenderType, isPlayer, hasRobustesse) {
    // 1. Efficacit√© des types
    let effectiveness = TYPE_EFFECTIVENESS[attackerType]?.[defenderType] || 1;
    
    // Type secondaire ennemi
    if (!isPlayer && this.currentEnemy && this.currentEnemy.secondaryType) {
        const secondaryEffectiveness = TYPE_EFFECTIVENESS[attackerType]?.[this.currentEnemy.secondaryType] || 1;
        effectiveness *= secondaryEffectiveness;
    }
    
    // 2. STAB
    let stab = 1.0;
    if (isPlayer && this.currentPlayerCreature) {
        const hasStab = this.currentPlayerCreature.type === attackerType || 
                        (this.currentPlayerCreature.secondaryType && this.currentPlayerCreature.secondaryType === attackerType);
        
        if (hasStab) {
            stab = 1.2;
            const maitreBonus = this.getTalentStackBonus('maitre');
            if (maitreBonus > 0) {
                stab = 1.2 * (1 + maitreBonus);
            }
        }
    }
    
    // 3. P√©nalit√© Stamina
    let staminaMultiplier = 1.0;
    // üõë CORRECTION : Si 0 stamina, on applique une p√©nalit√© (0.5 par exemple)
    if (isPlayer && this.currentStamina <= 0 && !hasRobustesse) {
        staminaMultiplier = 0.5; // D√©g√¢ts divis√©s par 2 si √©puis√©
    }
    
    // 4. Talents de compte
    let damageMultiplier = 1.0;
    if (isPlayer) {
        damageMultiplier = 1 + this.getAccountTalentBonus('damage_mult');
    } else {
        damageMultiplier = 1 - this.getAccountTalentBonus('damage_reduction');
    }
    
    // 5. Calcul final
    // üõë CORRECTION MATH√âMATIQUE MAJEURE :
    // mitigation = % de d√©g√¢ts qui passent (ex: 0.8)
    const mitigation = attack / (attack + defense * 1.25);
    
    // Il faut multiplier l'ATK par la mitigation !
    const rawDamage = attack * mitigation; 
    
    let damage = Math.floor(rawDamage * effectiveness * stab * staminaMultiplier * damageMultiplier);
    
    return Math.max(1, damage);
}
// OPTIMISATION : Victoire simul√©e (XP + Loot + AUTO-CATCH SILENCIEUX)
    processSimulatedVictory(enemy) {
    // --- 1. STATISTIQUES & SUCC√àS ---
    this.stats.combatsWon++;
    if (enemy.rarity === 'boss') this.stats.bossDefeated++;
    if (enemy.rarity === 'epic') this.stats.epicDefeated++;

    this.checkAchievements('combatsWon');
    this.checkAchievements('bossDefeated');
    this.checkAchievements('epicDefeated');

    // --- 2. XP ---
    const baseExpGain = Math.floor(enemy.level * 10);
    const expGain = Math.floor(baseExpGain * this.getExpMultiplier());
    const teamTalents = this.playerTeam.filter(c => c.passiveTalent).map(c => c.passiveTalent);
    this.playerTeam.forEach(c => c.gainExp(expGain, teamTalents));
    
    // --- 3. ARGENT ---
    const baseEarnings = currentZone * 2;
    let pokedollars = Math.floor(baseEarnings + (Math.random() * baseEarnings * 2));
    const collecteurBonus = this.getTalentStackBonus('collecteur');
    if (collecteurBonus > 0) pokedollars = Math.floor(pokedollars * (1 + collecteurBonus));
    const fortuneBonus = 1 + this.getAccountTalentBonus('pokedollars_mult');
    pokedollars = Math.floor(pokedollars * fortuneBonus);
    this.pokedollars += pokedollars;
    this.checkAchievements('totalPokedollarsEarned');

    // --- 4. TIERS ---
    const maxTier = ZONES[currentZone].maxTier || 50;
    const currentTier = enemy.tier; 
    if (currentTier < maxTier) {
        this.zoneProgress[currentZone].pokemonTiers[enemy.name] = currentTier + 1;
    }

    // --- 5. ITEMS & OEUFS (DYNAMIQUE VIA ROLLITEMDROP) ---
    
    // Objet pour stocker le butin de CE combat (pour le rapport)
    let dropsInThisCombat = {}; 

    // A. Appel de la VRAIE fonction de drop
    // On passe 'true' pour dire que c'est une simulation
    // (L'item est ajout√© √† l'inventaire DANS rollItemDrop, on r√©cup√®re juste son nom ici)
    const droppedItem = this.rollItemDrop(true);

    if (droppedItem) {
        dropsInThisCombat[droppedItem] = 1;
    }

    // B. Gestion Oeufs
    const baseEggChance = currentZone * 0.001 + 0.01;
    if (Math.random() < (baseEggChance + this.getEggDropBonus())) {
        const eggRarity = this.determineEggRarity();
        this.addEgg(eggRarity);
        
        // On enregistre l'≈ìuf comme un item pour le rapport
        const eggName = `egg_${eggRarity}`;
        dropsInThisCombat[eggName] = (dropsInThisCombat[eggName] || 0) + 1;
    }

    // --- 6. AUTO-CATCH ---
    let capturedData = null;
    

    if (this.hasAutoCatcher) {
        const s = this.autoCatcherSettings;
        let shouldCatch = false;

        if (s.catchShiny && enemy.isShiny) shouldCatch = true;
        
        if (!shouldCatch && s.catchNew) {
            const alreadyCaught = Object.values(this.pokedex).some(e => e.name === enemy.name && e.count > 0);
            if (!alreadyCaught) shouldCatch = true;
        }

        if (!shouldCatch && s.catchDupe && !enemy.isBoss) shouldCatch = true;

        if (shouldCatch) {
            const ballType = 'pokeball';
            if ((this.items[ballType] || 0) > 0) {
                const recycleLevel = (this.upgrades && this.upgrades.recycle) ? this.upgrades.recycle.level : 0;
            const recycleChance = recycleLevel * 0.025; // 2.5% par niveau
            
            // On d√©cr√©mente SEULEMENT si le random est plus grand que la chance (√âchec du recyclage)
            // Si recycleChance est 1 (100%), on ne d√©cr√©mente jamais.
            if (Math.random() >= recycleChance) {
                this.items[ballType]--; 
            }
                this.items[ballType]--;

                const baseChance = (typeof CATCH_RATES !== 'undefined' ? CATCH_RATES[enemy.rarity] : 0.1) || 0.1;
                const ballMult = (typeof BALLS !== 'undefined' ? BALLS[ballType].catchMult : 1);
                
                if (Math.random() < (baseChance * ballMult)) {
                    this.stats.creaturesObtained++;
                    
                    // Cr√©ation
                    const capturedCreature = new Creature(enemy.name, enemy.type, enemy.level, enemy.rarity, false, enemy.isShiny, enemy.secondaryType);
                    capturedCreature.ivHP = enemy.ivHP; capturedCreature.ivAttack = enemy.ivAttack;
                    capturedCreature.ivDefense = enemy.ivDefense; capturedCreature.ivSpeed = enemy.ivSpeed;
                    capturedCreature.recalculateStats();

                    const existing = this.findCreatureByName(capturedCreature.name, capturedCreature.isShiny);
                    if (existing) {
                        this.processFusion(capturedCreature, existing);
                    } else {
                        this.storage.push(capturedCreature);
                        const key = capturedCreature.name + "_" + capturedCreature.type + "_" + capturedCreature.rarity;
                        if (!this.pokedex[key]) {
                            this.pokedex[key] = { discovered: true, count: 1, name: capturedCreature.name, type: capturedCreature.type, rarity: capturedCreature.rarity };
                        }
                    }
                    // Capture r√©ussie pour le rapport
                    capturedData = { name: enemy.name, shiny: enemy.isShiny };
                }
            }
        }
    }

    // --- 7. RETOUR DES R√âSULTATS ---
    return {
        xp: expGain,
        money: pokedollars,
        items: dropsInThisCombat, // Contient l'item r√©el des rates + l'oeuf √©ventuel
        captured: capturedData
    };
}

    
processSimulatedDefeat() {
    this.stats.combatsLost++;
    // Pas de p√©nalit√© suppl√©mentaire en simulation
}

           // ‚úÖ CORRECTION ARGUMENT : playerMainStats au lieu de _ignoredStats
    performAttackWithBonus(attacker, target, playerMainStats, isPlayerAttacking, hasMaitreElementaire) {
        
        // 1. S√âCURIT√â & SOURCE DE V√âRIT√â
        let sourceStats = null;
        if (!this.isEnemy && isPlayerAttacking) {
            if (this.arenaState.active) {
                sourceStats = null; 
            } else {
                sourceStats = this.getEffectiveStats(); 
            }
        }

        // 2. CONFIGURATION ATTAQUANT (Proxy)
        // On cr√©e un "Faux Attaquant" qui poss√®de les stats boost√©es (Tour, Potions)
        // C'est lui qu'on enverra √† Creature.js
        let effectiveAttacker = attacker;
        if (sourceStats) {
            effectiveAttacker = {
                ...attacker, 
                attack: sourceStats.attack, 
                getAttackMultiplier: () => attacker.getAttackMultiplier(),
                hasStatusEffect: () => attacker.hasStatusEffect(),
                canAttack: () => attacker.canAttack(),
                statusEffect: attacker.statusEffect,
                passiveTalent: attacker.passiveTalent, // Important pour Sniper/Opportuniste
                ultimateActive: attacker.ultimateActive,
                ultimateAbility: attacker.ultimateAbility,
                ultimateCharge: attacker.ultimateCharge
            };
        }

        // 3. GESTION ULTIME
        let wasUltimate = false;
        let ultimateDamageMult = 1.0;
        let ultimateLifesteal = 0;
        let ultimateDefensePen = 0;
        let ultimateHits = 1;
        let ultimateRecoil = 0;
        let isCriticalHit = false; 

        if (attacker.ultimateActive) {
            attacker.ultimateActive = false; 
            wasUltimate = true;
            const ult = attacker.ultimateAbility;
            
            switch (ult.effect.type) {
                case 'DAMAGE_MULT': ultimateDamageMult = ult.effect.value; break;
                case 'DAMAGE_AND_STATUS':
                    ultimateDamageMult = ult.effect.value;
                    let statusMult = ult.effect.statusMult || 1;
                    let sourceAtk = playerMainStats ? playerMainStats.attack : effectiveAttacker.attack;
                    if (statusMult > 1) sourceAtk *= statusMult;
                    target.applyStatusEffect(ult.effect.status, sourceAtk);
                    
                    // Soin Ultime (Joueur vs Ennemi)
                    if (ult.effect.selfHeal) {
                         if (!attacker.isEnemy) {
                             const maxHp = this.getPlayerMaxHp();
                             const heal = Math.floor(maxHp * ult.effect.selfHeal);
                             attacker.mainAccountCurrentHp = Math.min(maxHp, attacker.mainAccountCurrentHp + heal);
                             if(window.showFloatingText) window.showFloatingText(`+${heal}`, document.getElementById('playerSpriteContainer'), 'ft-heal');
                         } else {
                             const max = attacker.maxHp || (attacker.stats ? attacker.stats.HP : 100);
                             const heal = Math.floor(max * ult.effect.selfHeal);
                             attacker.currentHP = Math.min(max, (attacker.currentHP || 0) + heal);
                         }
                    }
                    break;
                case 'LIFESTEAL': 
                    ultimateDamageMult = ult.effect.value; 
                    ultimateLifesteal = ult.effect.steal; 
                    break;
                case 'DEFENSE_PENETRATION': 
                    ultimateDamageMult = ult.effect.value; 
                    ultimateDefensePen = ult.effect.penetration; 
                    break;
                case 'MULTI_HIT':
                    ultimateDamageMult = ult.effect.value;
                    ultimateHits = ult.effect.hits;
                    if (ult.effect.status) {
                        let baseAtk = playerMainStats ? playerMainStats.attack : effectiveAttacker.attack;
                        target.applyStatusEffect(ult.effect.status, baseAtk);
                    }
                    break;
                case 'RECOIL': 
                    ultimateDamageMult = ult.effect.value; 
                    ultimateRecoil = ult.effect.recoil; 
                    break;
                case 'DAMAGE_AND_STATUS_TYPE': 
                    ultimateDamageMult = ult.effect.value;
                    const statusType = TYPE_TO_STATUS[attacker.type];
                    if (statusType) {
                        let baseAtk = playerMainStats ? playerMainStats.attack : effectiveAttacker.attack;
                        target.applyStatusEffect(statusType, baseAtk);
                    }
                    break;
            }
        }

        // Orbe Vie (Item)
        if (attacker.heldItem === 'life_orb') {
            ultimateDamageMult *= 1.3; 
        }

        // 4. CONTR√îLES (Confusion, Stun, Esquive)
        if (attacker.hasStatusEffect('confused') && Math.random() < 0.30) {
            const selfDamage = Math.floor(effectiveAttacker.attack * 0.5);
            attacker.takeDamage(selfDamage, playerMainStats);
            if(window.showFloatingText) window.showFloatingText("üòµ", document.getElementById('playerSpriteContainer'), 'ft-status');
            logMessage(attacker.name + " est confus et se blesse !");
            return false;
        }
        
        if (!attacker.canAttack()) {
            if(window.showFloatingText) window.showFloatingText("üö´", document.getElementById('playerSpriteContainer'), 'ft-status');
            if (attacker.statusEffect.duration > 0) attacker.statusEffect.duration--;
            return false;
        }
        
        if (target.hasStatusEffect('agile') && target.statusEffect.dodgeCount < 2 && Math.random() < 0.30) {
            target.statusEffect.dodgeCount++;
            if(window.showFloatingText) window.showFloatingText("Miss", document.getElementById('enemySpriteContainer'), '');
            logMessage(target.name + " esquive l'attaque !");
            return false;
        }

        // =========================================================
        // ‚úÖ 5. BONUS GLOBAUX (RESTREINTS AU JOUEUR)
        // =========================================================
        
        let bonusDamageMult = 1.0;
        
        // 1. Talents de compte (Ex: +10% D√©g√¢ts passifs)
        // On ne l'applique que si c'est le joueur (ou ses alli√©s) qui tape
        if (!attacker.isEnemy) {
            bonusDamageMult += this.getAccountTalentBonus('damage_mult');
        }
        
        // Variables pour les conditions
        const tMaxHp = target.maxHp || (target.stats ? target.stats.HP : 1);
        const tCurrHp = target.currentHP || target.currentHp || 0;
        const healthRatio = tCurrHp / tMaxHp;

        // 2. Bonus de la Tour (Seulement si le JOUEUR attaque)
        if (!attacker.isEnemy && this.towerState.isActive && this.towerState.buffs) {
            const buffs = this.towerState.buffs;
            if (buffs.status_dmg_bonus && target.hasStatusEffect()) bonusDamageMult *= (1 + buffs.status_dmg_bonus);
            if (buffs.execute_percent && (healthRatio < 0.5)) bonusDamageMult *= (1 + buffs.execute_percent);
            if (buffs.lifesteal) ultimateLifesteal += buffs.lifesteal;
            
            // Relique Critique
            if (buffs.crit_chance && Math.random() < buffs.crit_chance) {
                isCriticalHit = true;
            }
        }

        // 3. Bonus du Shop (Seulement si le JOUEUR attaque)
        if (!attacker.isEnemy && this.upgrades) {
            // EX√âCUTEUR
            if (this.upgrades['executor']) {
                if (healthRatio < 0.30) {
                    bonusDamageMult *= (1 + (this.upgrades['executor'] * 0.15));
                    isCriticalHit = true; 
                }
            }

            // MA√éTRE √âL√âMENTAIRE
            if (this.upgrades['element_master']) {
                if (target.hasStatusEffect()) {
                    bonusDamageMult *= (1 + (this.upgrades['element_master'] * 0.10));
                }
            }
        }

        // 4. Critiques Passifs (Shop/Talents) -> JOUEUR UNIQUEMENT
        if (!attacker.isEnemy) {
            let critChance = 0.05; // 5% de base pour le joueur
            if (this.upgrades && this.upgrades.critMastery) critChance += (this.upgrades.critMastery.level * 0.01);
            if (this.upgrades && this.upgrades['precision']) critChance += (this.upgrades['precision'] * 0.02);
            if (this.towerState.isActive && this.towerState.buffs?.crit_chance) critChance += this.towerState.buffs.crit_chance;
            if (attacker.passiveTalent === 'sniper') critChance += 0.20;
            
            if (!isCriticalHit) isCriticalHit = Math.random() < critChance;
        } else {
            // Pour l'ennemi, juste 5% de chance de base (ou 0 selon ton √©quilibrage)
            if (!isCriticalHit) isCriticalHit = Math.random() < 0.05;
        }

        // =========================================================

        // 6. EX√âCUTION (Boucle Multihit)
        let totalDamage = 0;
        let isDead = false; 

        for (let i = 0; i < ultimateHits; i++) {
            if (isDead) break; 

            // üî• APPEL MOTEUR (Logique d√©l√©gu√©e √† Creature.js)
            // On ne calcule PLUS stab ou effectiveness ici, Creature.js s'en charge.
            let damage = Creature.calculateDamageOutput(effectiveAttacker, target, {
                isCritical: isCriticalHit,
                ultMultiplier: ultimateDamageMult * bonusDamageMult, // On combine les bonus externes
                ignoreDefensePct: ultimateDefensePen,
                gameContext: this // On passe le contexte pour les talents
            });

            // Ajustements Talents Compte Finaux (Post-Calcul)
            if (!attacker.isEnemy && target.isEnemy) {
                damage = Math.floor(damage * (1 + this.getAccountTalentBonus('damage_mult')));
            }
            if (attacker.isEnemy && !target.isEnemy) {
                damage = Math.floor(damage * (1 - this.getAccountTalentBonus('damage_reduction')));
            }

            const isBigHit = wasUltimate || isCriticalHit;

            // ‚úÖ THORNY (√âPINE) : Version Optimis√©e (Renvoi avant r√©duction)
            if (target.hasStatusEffect() && target.statusEffect.type === STATUS_EFFECTS.THORNY) {
                const thornsDmg = Math.floor(damage * 0.15); // 15% Renvoi
                if (thornsDmg > 0) {
                    if (!attacker.isEnemy) {
                        attacker.mainAccountCurrentHp = Math.max(0, attacker.mainAccountCurrentHp - thornsDmg);
                        if(window.showFloatingText) window.showFloatingText(`-${thornsDmg}`, document.getElementById('playerSpriteContainer'), 'ft-damage-player');
                    } else {
                        attacker.currentHP = Math.max(0, (attacker.currentHP || 0) - thornsDmg);
                    }
                }
                damage = Math.floor(damage * 0.67); // R√©duction d√©g√¢ts re√ßus (33%)
            }

            // APPLICATION D√âG√ÇTS
            isDead = target.takeDamage(damage, playerMainStats, isBigHit);
            totalDamage += damage;
            
            // ==============================================================
            // ‚úÖ CHARGE D√âFENSIVE (6%) - Sp√©cialit√© "epineux"
            // ==============================================================
            if (!isDead && target.ultimateAbility && target.ultimateCharge < target.ultimateAbility.chargeNeeded) {
                // Base : 6 points par coup re√ßu
                let defCharge = 6;
                
                // Talent epineux : Charge 2x plus vite en d√©fendant
                if (target.passiveTalent === 'epineux') defCharge *= 2;
                
                // Bonus Ar√®ne
                if (this.arenaState.active) defCharge *= 1.5;

                target.ultimateCharge = Math.min(target.ultimateAbility.chargeNeeded, target.ultimateCharge + defCharge);
            }
            

            // Reflect Tour (Si actif)
            if (!target.isEnemy && this.towerState.isActive && this.towerState.buffs && this.towerState.buffs.reflect_percent) {
                const reflectDmg = Math.floor(damage * this.towerState.buffs.reflect_percent);
                if (reflectDmg > 0) {
                    attacker.currentHp = Math.max(0, attacker.currentHp - reflectDmg);
                    window.showFloatingText(`üí¢ ${reflectDmg}`, document.getElementById('enemySpriteContainer'), 'ft-damage-enemy');
                }
            }

            // --- GESTION ITEMS & SOINS (Logique Split Joueur/Ennemi) ---
            
            // Orbe Vie
            if (attacker.heldItem === 'life_orb') {
                const recoil = Math.floor(this.getPlayerMaxHp() * 0.10);
                if (!attacker.isEnemy) {
                     attacker.mainAccountCurrentHp = Math.max(0, attacker.mainAccountCurrentHp - recoil);
                     window.showFloatingText("-" + formatFloatingNumber(recoil), document.getElementById('playerSpriteContainer'), 'ft-damage-player');
                } else {
                     attacker.currentHP = Math.max(0, (attacker.currentHP || 0) - recoil);
                }
            }

            // Shell Bell
            if (attacker.heldItem === 'shell_bell') {
                const heal = Math.floor(damage * 0.15);
                if (!attacker.isEnemy) {
                     const maxHp = this.getPlayerMaxHp();
                     attacker.mainAccountCurrentHp = Math.min(maxHp, attacker.mainAccountCurrentHp + heal);
                     window.showFloatingText("+" + formatFloatingNumber(heal), document.getElementById('playerSpriteContainer'), 'ft-heal');
                } else {
                     const max = attacker.maxHp || (attacker.stats ? attacker.stats.HP : 100);
                     attacker.currentHP = Math.min(max, (attacker.currentHP || 0) + heal);
                }
            }
            
            // Lifesteal Ultime
            if (ultimateLifesteal > 0) {
                const healAmount = Math.floor(damage * ultimateLifesteal);
                if (!attacker.isEnemy) {
                    const maxHp = this.getPlayerMaxHp();
                    attacker.mainAccountCurrentHp = Math.min(maxHp, attacker.mainAccountCurrentHp + healAmount);
                    window.showFloatingText("+" + formatFloatingNumber(healAmount), document.getElementById('playerSpriteContainer'), 'ft-heal');
                } else {
                    const max = attacker.maxHp || (attacker.stats ? attacker.stats.HP : 100);
                    attacker.currentHP = Math.min(max, (attacker.currentHP || 0) + healAmount);
                }
            }
            
            // Recul Ultime
            if (ultimateRecoil > 0) {
                const recoilAmount = Math.floor(damage * ultimateRecoil);
                if (!attacker.isEnemy) {
                    attacker.mainAccountCurrentHp = Math.max(1, attacker.mainAccountCurrentHp - recoilAmount);
                } else {
                    attacker.currentHP = Math.max(1, (attacker.currentHP || 0) - recoilAmount);
                }
            }
        } // Fin boucle

        // 7. FIN DE TOUR
        const hasRobustesse = attacker.passiveTalent === 'robustesse';
        if (attacker.currentStamina > 0 && !hasRobustesse && !wasUltimate) {
            attacker.currentStamina--;
        }
        if (attacker.hasStatusEffect('puncher')) attacker.clearStatusEffect();
        if (attacker.passiveTalent === 'berserker' && (attacker.berserkStacks || 0) < 10) {
            attacker.berserkStacks = (attacker.berserkStacks || 0) + 1;
        }
        
        // Logs Combat
        // Note: On ne log plus les d√©tails techniques ici (stab, type) car c'est g√©r√© par Creature.js,
        // mais on affiche le r√©sultat final.
        let message = attacker.name + " attaque " + target.name + " pour <span class=\"damage-" + attacker.type + "\">" + formatNumber(totalDamage) + " degats</span>";
        if (wasUltimate) message += " [ULTIME]";
        if (isCriticalHit) message += " [CRITIQUE]";
        logMessage(message);
        
        // Animation
        const spriteId = !attacker.isEnemy ? 'playerSprite' : 'enemySprite';
        const targetSpriteId = !attacker.isEnemy ? 'enemySprite' : 'playerSprite';
        document.getElementById(spriteId)?.classList.add('attack-lunge');
        document.getElementById(targetSpriteId)?.classList.add('take-hit');
        setTimeout(() => {
            document.getElementById(spriteId)?.classList.remove('attack-lunge');
            document.getElementById(targetSpriteId)?.classList.remove('take-hit');
        }, 300);
        
        // Statuts
        if (!isDead && !target.hasStatusEffect()) {
            let procChance = (STATUS_PROC_CHANCES[attacker.rarity] || 0) + this.getStatusProcBonus();
            if (Math.random() < procChance) {
                const statusType = TYPE_TO_STATUS[attacker.type];
                if (statusType) {
                    let baseAtk = (!attacker.isEnemy && playerMainStats) ? playerMainStats.attack : effectiveAttacker.attack;
                    const isBuff = ['reinforced', 'agile', 'thorny', 'enraged', 'puncher'].includes(statusType);
                    const effectTarget = isBuff ? attacker : target;
                    
                    if (effectTarget.applyStatusEffect(statusType, baseAtk)) {
                        logMessage(effectTarget.name + " est maintenant " + effectTarget.getStatusEffectName() + " !");
                        if (!attacker.isEnemy) this.checkSpecialQuests('statusInflicted');
                    }
                }
            }
        }

        // ==============================================================
        // ‚úÖ CHARGE OFFENSIVE (12%) - Sp√©cialit√© "Adr√©naline"
        // ==============================================================
        if (!wasUltimate && attacker.ultimateAbility) {
            if (attacker.ultimateCharge < attacker.ultimateAbility.chargeNeeded) {
                // Base : 12 points par tour d'attaque
                let charge = 12;
                
                // Talent ADR√âNALINE : Charge 2x plus vite en attaquant
                if (attacker.passiveTalent === 'adrenaline') charge *= 2;
                
                // Bonus Ar√®ne
                if (this.arenaState.active) charge *= 1.5;
                
                attacker.ultimateCharge = Math.min(attacker.ultimateAbility.chargeNeeded, attacker.ultimateCharge + charge);
            }
        } else if (wasUltimate && attacker.ultimateAbility?.effect?.bonusCharge) {
            attacker.ultimateCharge = Math.min(attacker.ultimateAbility.chargeNeeded, attacker.ultimateCharge + attacker.ultimateAbility.effect.bonusCharge);
        }
        
        // Regen Tour (Logique Split)
        if (!attacker.isEnemy && this.towerState.isActive && this.towerState.buffs && this.towerState.buffs.regen_percent) {
            const maxHp = this.getPlayerMaxHp();
            const regenAmount = Math.floor(maxHp * this.towerState.buffs.regen_percent);
            
            if (regenAmount > 0 && attacker.mainAccountCurrentHp < maxHp) {
                attacker.mainAccountCurrentHp = Math.min(maxHp, attacker.mainAccountCurrentHp + regenAmount);
                window.showFloatingText(`+${formatFloatingNumber(regenAmount)}`, document.getElementById('playerSpriteContainer'), 'ft-heal');
            }
        }
        
        return isDead;
    }
	
	// Helper pour g√©rer le soin (utilis√© par DAMAGE_AND_STATUS et autres)
    applyHeal(creature, amountOrPercent) {
        if (!creature || !creature.isAlive()) return;

        let healAmount = 0;
        
        // Gestion Pourcentage (0.5) vs Fixe (500)
        if (amountOrPercent <= 1) {
            healAmount = Math.floor(creature.maxHp * amountOrPercent);
        } else {
            healAmount = Math.floor(amountOrPercent);
        }

        // Application
        const oldHp = creature.currentHp;
        creature.currentHp = Math.min(creature.maxHp, creature.currentHp + healAmount);
        
        // Mise √† jour de la variable de sauvegarde si c'est le joueur principal (et pas un clone/invocation)
        if (creature.mainAccountCurrentHp !== undefined) {
             creature.mainAccountCurrentHp = creature.currentHp;
        }

        // Feedback
        const actualHeal = creature.currentHp - oldHp;
        if (actualHeal > 0) {
            logMessage(`üíö ${creature.name} r√©cup√®re ${formatNumber(actualHeal)} PV !`);
            
            // Texte flottant (Si disponible)
            const containerId = creature.isEnemy ? 'enemySpriteContainer' : 'playerSpriteContainer';
            const container = document.getElementById(containerId);
            if (container && window.showFloatingText) {
                 window.showFloatingText(`+${formatNumber(actualHeal)}`, container, 'ft-heal');
            }
            
            this.updateCombatDisplay();
        }
    }

// ‚úÖ AJOUTER CETTE FONCTION MANQUANTE DANS LA CLASSE GAME

            activateUltimate() {
                const creature = this.currentPlayerCreature;
                if (!creature) return;
                
                const ult = creature.ultimateAbility;
                if (!ult) return;

                if (creature.ultimateCharge < ult.chargeNeeded) {
                    logMessage("Charge insuffisante !");
                    return;
                }

                if (creature.ultimateActive) {
                    logMessage("L'ultime est d√©j√† actif !");
                    return;
                }

                logMessage(`‚ö° ${creature.name} utilise son ultime : ${ult.name} !`);
                creature.ultimateCharge = 0; // Consomme la charge

                // G√©rer les effets imm√©diats (ex: Soin)
                if (ult.effect.type === 'HEAL') {
                    const maxHp = this.getPlayerMaxHp();
                    const healAmount = Math.floor(maxHp * ult.effect.value);
                    creature.mainAccountCurrentHp = Math.min(maxHp, creature.mainAccountCurrentHp + healAmount);
                    logMessage(`üíö ${creature.name} se soigne de ${healAmount} PV !`);
                
                } else if (ult.effect.type === 'MULTI_BUFF') {
                    ult.effect.status.forEach(statusEffect => {
                        // G√©rer le poison x3 de Gengar
                        let sourceAtk = this.playerMainStats.attack;
                        if (ult.effect.statusMult && ult.effect.statusMult > 1) {
                            sourceAtk *= ult.effect.statusMult;
                        }
                        creature.applyStatusEffect(statusEffect, sourceAtk);
                        logMessage(`üí• ${creature.name} applique ${creature.getStatusEffectName()} !`);
                    });
                
                } else if (ult.effect.type === 'APPLY_STATUS') {
                     creature.applyStatusEffect(ult.effect.status, this.playerMainStats.attack);
                     logMessage(`üí• ${creature.name} applique ${creature.getStatusEffectName()} !`);
                
                } else {
                    // Si ce n'est pas un effet imm√©diat, on "arme" la prochaine attaque
                    creature.ultimateActive = true;
                }

                this.updateCombatDisplay();
            }
			
            
			// LOGIQUE : Victoire Combat (Version Finale : S√©curis√©e & Options Respect√©es)
    winCombat() {
        if (!this.currentEnemy) {
        console.warn("‚ö†Ô∏è winCombat appel√© sans ennemi actif. Ignor√©.");
        return;
    }
        // 1. V√©rification Simulation
        const isSimulation = typeof window.logMessage === 'function' && window.logMessage.toString() === 'function() {}';

        this.stats.combatsWon++;
        

    // 2. V√©rification des succ√®s li√©s
    this.checkAchievements('combatsWon');
    this.checkAchievements('bossDefeated');
    this.checkAchievements('epicDefeated');
        const noDeath = this.faintedThisCombat ? this.faintedThisCombat.size === 0 : true;
        this.checkSpecialQuests('combatsWon', { noDeath: noDeath });
        
        
        // Auto-catch (si talent actif)
        if (!isSimulation && this.triggerAutoCatch()) {
            return; 
        }
        
        // --- D√âBUT LOGIQUE DE D√âCISION ---
        let shouldTriggerCapture = false;
        
        const isSpecialMode = this.towerState.isActive || this.arenaState.active;

        if (!isSpecialMode && !isSimulation) {
            const enemy = this.currentEnemy;
            
            // ‚úÖ FIX : S√âCURIT√â ANTI-CRASH
            // Si l'ennemi n'existe pas (bug de timing), on arr√™te tout pour √©viter l'√©cran blanc.
            if (!enemy) {
                console.warn("‚ö†Ô∏è winCombat appel√© sans ennemi actif. Annulation de la capture.");
                this.finalizeCombat(false);
                return;
            }

            // D√©finition du Jackpot (Maintenant on est s√ªr que 'enemy' existe)
            const isJackpot = enemy.isShiny || enemy.isRoaming;

            // CAS A : Jackpot (Shiny/Roaming)
            if (isJackpot) {
                if (this.pauseOnRare) {
                    shouldTriggerCapture = true;
                    if (this.captureMode === 0) {
                        console.log("üö® S√âCURIT√â : Pause demand√©e pour Shiny/Rare.");
                    }
                } else {
                    console.log("üíÄ MODE TUEUR : Shiny/Rare ignor√©.");
                }
            }
            
            // CAS B : Mode "TOUS"
            else if (this.captureMode === 1) { 
                shouldTriggerCapture = true;
            } 
            
            // CAS C : Mode "CIBLE"
            else if (this.captureMode === 2) { 
                if (this.captureTargets && this.captureTargets.includes(enemy.name)) {
                    shouldTriggerCapture = true;
                }
                else if (this.captureTarget === enemy.name) {
                    shouldTriggerCapture = true;
                }
            }
        
            
            // CAS C : Mode "CIBLE" (CORRECTION ICI)
            else if (this.captureMode === 2) { 
                // ‚úÖ CORRECTIF : On v√©rifie si le nom est DANS le tableau
                if (this.captureTargets && this.captureTargets.includes(enemy.name)) {
                    shouldTriggerCapture = true;
                }
                // S√©curit√© (Ancien syst√®me string)
                else if (this.captureTarget === enemy.name) {
                    shouldTriggerCapture = true;
                }
            }
        }

        // 3. V√âRIFICATION DU STOCK DE BALLES
        let hasAnyBall = false;
        if (shouldTriggerCapture) {
            const ballTypes = ['pokeball', 'greatball', 'hyperball', 'masterball'];
            hasAnyBall = ballTypes.some(type => (this.items[type] || 0) > 0);
        }

        // 4. EX√âCUTION
        if (shouldTriggerCapture && hasAnyBall) {
            this.startCapturePhase();
        } else {
            // On termine le combat (Kill / Gain XP)
            this.finalizeCombat(false);
        }
    }
    
    // Petite fonction utilitaire pour garder winCombat propre (si vous ne l'avez pas d√©j√†)
    handleSpecialModeVictory() {
         if (this.arenaState.active) {
            this.arenaState.currentChampionIndex++;
            if (this.arenaState.currentChampionIndex >= this.arenaState.championTeam.length) {
                this.winArena();
            } else {
                this.currentEnemy = this.arenaState.championTeam[this.arenaState.currentChampionIndex];
                this.currentEnemy.clearStatusEffect();
                logMessage("Le champion envoie " + this.currentEnemy.name + " !");
                this.combatState = 'fighting';
            }
        } else if (this.towerState.isActive) {
             this.towerState.currentEnemyIndex++;
             if (this.towerState.currentEnemyIndex < this.towerState.enemyTeam.length) {
                 this.currentEnemy = this.towerState.enemyTeam[this.towerState.currentEnemyIndex];
                 this.combatState = 'starting';
                 this.combatStartTime = Date.now();
                 this.updateDisplay();
             } else {
                 this.nextTowerFloor();
             }
        }
    }

/**
 * Lance le chrono pour afficher l'infobulle.
 * @param {MouseEvent} event - L'√©v√©nement de la souris.
 * @param {string} title - Le titre de l'objet.
 * @param {string} description - La description.
 */
scheduleTooltip(event, title, description) {
    // 1. Si un timer existe d√©j√† (on a boug√© vite d'un item √† l'autre), on l'annule
    this.hideTooltip();

    // 2. On capture la position de la souris MAINTENANT
    const x = event.clientX;
    const y = event.clientY;

    // 3. On lance le timer
    this.tooltipTimer = setTimeout(() => {
        const tooltip = document.getElementById('customTooltip');
        if (!tooltip) return;

        // Remplir le contenu
        tooltip.innerHTML = `<span class="tooltip-title">${title}</span>${description}`;

        // Positionner (l√©g√®rement d√©cal√© de la souris pour ne pas g√™ner)
        // On g√®re aussi le d√©bordement √† droite de l'√©cran
        let left = x + 15;
        let top = y + 15;
        
        // Afficher
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.display = 'block';
        
    }, this.TOOLTIP_DELAY);
}



/**
 * Cache l'infobulle et annule le timer en cours.
 */
hideTooltip() {
    if (this.tooltipTimer) {
        clearTimeout(this.tooltipTimer);
        this.tooltipTimer = null;
    }
    const tooltip = document.getElementById('customTooltip');
    if (tooltip) tooltip.style.display = 'none';
}

// --- D√âBUT DES FONCTIONS DE CAPTURE √Ä AJOUTER ---

    // OPTIMISATION : Capture UI avec Vrais Sprites & Nouveau Titre
    startCapturePhase() {
        // S√©curit√©s
        if (this.towerState.isActive || this.arenaState.active || (typeof window.logMessage === 'function' && window.logMessage.toString() === 'function() {}')) {
            this.finalizeCombat(false);
            return;
        }
        
        this.combatState = 'capture';
        const enemy = this.currentEnemy;
        const modal = document.getElementById('captureModal');
        const content = modal.querySelector('.quest-completion-content'); 
        
        const baseChance = (typeof CATCH_RATES !== 'undefined' ? CATCH_RATES[enemy.rarity] : 0.1) || 0.1;
        const spriteUrl = getPokemonSpriteUrl(enemy.name, enemy.isShiny);

        // Construction des boutons de balles
        let ballsHTML = '';
        const ballTypes = ['pokeball', 'greatball', 'hyperball', 'masterball'];
        
        ballTypes.forEach(type => {
            const count = this.items[type] || 0;
            // On r√©cup√®re la d√©finition depuis notre constante BALLS
            const ballDef = (typeof BALLS !== 'undefined' && BALLS[type]) ? BALLS[type] : { name: type, catchMult: 1, img: '' };
            
            // Calcul du taux visuel
            let charmBonus = (this.currentPlayerCreature && this.currentPlayerCreature.passiveTalent === 'charmeur') ? 1.25 : 1.0;
            let visualRate = Math.min(100, baseChance * ballDef.catchMult * charmBonus * 100);
            if(type === 'masterball') visualRate = 100;

            // Couleur de la barre de chance
            let barColor = '#ef4444'; // Rouge
            if (visualRate > 30) barColor = '#f59e0b'; // Orange
            if (visualRate > 70) barColor = '#22c55e'; // Vert
            
            // L'Image de la Ball (Fallback sur l'emoji si pas d'image)
            const iconHTML = ballDef.img 
                ? `<img src="${ballDef.img}" class="ball-icon-img" alt="${ballDef.name}">`
                : `<div class="ball-icon-large">${ballDef.icon || 'üî¥'}</div>`;

            ballsHTML += `
                <button class="ball-select-btn" onclick="game.tryCapture('${type}')" ${count === 0 ? 'disabled' : ''}>
                    <div class="ball-count-badge">x${count}</div>
                    
                    ${iconHTML}
                    
                    <div style="font-weight:bold; font-size:12px; margin-bottom:2px;">${ballDef.name}</div>
                    <div style="font-size:11px; color:#666;">${visualRate.toFixed(0)}%</div>
                    <div class="capture-chance-bar">
                        <div class="capture-chance-fill" style="width:${visualRate}%; background:${barColor};"></div>
                    </div>
                </button>
            `;
        });

        // Contenu du Modal
        content.innerHTML = `
            <div class="quest-completion-title" style="color: #3b82f6; margin-bottom:15px;">
                Capture
            </div>
            
            <div class="capture-layout">
                <div class="capture-target-card rarity-${enemy.rarity}">
                    <div class="capture-scene">
                        <img src="${spriteUrl}" class="capture-sprite">
                    </div>
                    <div style="font-weight:800; font-size:16px; margin-top:10px;">${enemy.name}</div>
                    <span class="rarity-label ${enemy.rarity}" style="font-size:10px;">${enemy.rarity}</span>
                    <div style="font-size:11px; color:#666; margin-top:5px;">Niv. ${enemy.level}</div>
                </div>

                <div class="balls-grid">
                    ${ballsHTML}
                </div>
            </div>

            <button class="btn" style="background: #f1f5f9; color: #64748b; width: 100%; margin-top:20px; font-weight:bold;" onclick="game.skipCapture()">
                Fuir (Ne pas capturer)
            </button>
        `;

        modal.classList.add('show');
    }
// OPTIMISATION : Cycle des modes avec For√ßage de la Liste
    cycleCaptureMode() {
        // 0 (OFF) -> 1 (ALL) -> 2 (TARGET) -> 0
        this.captureMode = (this.captureMode + 1) % 3;
        
        console.log("üîÑ Changement mode : " + this.captureMode);

        // ‚úÖ IMPORTANT : Si on passe en mode Cible (2), on remplit la liste IMM√âDIATEMENT
        if (this.captureMode === 2) {
            // On v√©rifie si la fonction existe avant de l'appeler
            if (this.updateCaptureTargetList) {
                this.updateCaptureTargetList(); 
            } else {
                console.error("‚ùå ERREUR : La fonction updateCaptureTargetList n'existe pas !");
            }
        }
        
        this.updateCaptureButtonDisplay();
    }

    

   /// UI : Mise √† jour de la grille de cibles (Ton Design Grid)
    updateCaptureTargetList() {
        const grid = document.getElementById('captureTargetGrid');
        const wrapper = document.getElementById('captureTargetWrapper');
        if (!grid || !wrapper) return;

        const zoneId = (typeof currentZone !== 'undefined') ? currentZone : 1;
        const zonePokemon = this.getReachablePokemonInZone(zoneId); 
        
        // Initialisation du tableau si vide
        if (!this.captureTargets) this.captureTargets = [];
        // Migration de s√©curit√©
        if (this.captureTarget && !this.captureTargets.includes(this.captureTarget)) {
             this.captureTargets.push(this.captureTarget);
        }

        grid.innerHTML = ''; 

        if (!zonePokemon || zonePokemon.length === 0) {
            grid.innerHTML = '<div style="font-size:10px; color:#666; padding:10px;">Aucune cible</div>';
            return;
        }

        // Boucle d'affichage
        zonePokemon.forEach(name => {
            const slot = document.createElement('div');
            
            // ‚úÖ CHANGEMENT ICI : On v√©rifie si le nom est dans le tableau
            const isSelected = this.captureTargets.includes(name);
            
            // On applique tes classes CSS exactes
            slot.className = isSelected ? 'target-slot selected' : 'target-slot';
            slot.setAttribute('data-name', name);
            
            const img = document.createElement('img');
            img.src = getPokemonSpriteUrl(name, false); 
            slot.appendChild(img);

            // ‚úÖ CHANGEMENT ICI : Au clic, on appelle la nouvelle fonction Toggle
            slot.onclick = () => {
                this.toggleCaptureTarget(name);
                // On ne manipule plus les classes manuellement ici, 
                // car toggleCaptureTarget va rappeler cette fonction enti√®re pour tout redessiner proprement.
            };
            
            grid.appendChild(slot);
        });
        
        // Affichage du wrapper si mode Cible actif
        if (this.captureMode === 2) {
            wrapper.classList.add('show');
            wrapper.style.display = 'block';
        }
    }
	// MODIFICATION : S√©lection Multi-Cibles (Compatible avec ton design Grid)
    toggleCaptureTarget(name) {
        // 1. Initialisation / Migration vers un Tableau
        if (!this.captureTargets) this.captureTargets = [];
        // Si tu avais une ancienne cible unique qui tra√Æne, on la r√©cup√®re
        if (this.captureTarget && this.captureTargets.length === 0) {
            this.captureTargets.push(this.captureTarget);
            this.captureTarget = null; 
        }

        // 2. V√©rification Jumelles
        const hasScope = (this.items['scope'] || 0) > 0;
        const maxSlots = hasScope ? 2 : 1;

        const index = this.captureTargets.indexOf(name);

        if (index > -1) {
            // A. D√âJ√Ä S√âLECTIONN√â -> On le retire (D√©s√©lection)
            this.captureTargets.splice(index, 1);
        } else {
            // B. NOUVELLE S√âLECTION
            if (this.captureTargets.length < maxSlots) {
                // Il y a de la place -> On ajoute
                this.captureTargets.push(name);
            } else {
                // C'est plein !
                if (maxSlots === 1) {
                    // Si 1 seul slot, on remplace l'ancien (ton comportement actuel)
                    this.captureTargets = [name];
                } else {
                    // Si 2 slots pleins, on avertit
                    if(typeof toast !== 'undefined') toast.warning("Jumelles Satur√©es", "Retirez une cible pour en ajouter une autre.");
                    return; 
                }
            }
        }

        // 3. Mise √† jour Visuelle
        this.updateCaptureTargetList();       // On redessine la grille avec les bonnes cases bleues
        this.updateCaptureButtonDisplay();    // On met √† jour le texte du bouton principal
    }
    
	
	// OPTIMISATION : Mise √† jour UI avec affichage FORC√â du menu
    updateCaptureButtonDisplay() {
        const btn = document.getElementById('captureModeBtn');
        const wrapper = document.getElementById('captureTargetWrapper');
        const icon = document.getElementById('captureIcon');
        const text = document.getElementById('captureText');
        
        if (!btn) return;

        // Reset
        btn.classList.remove('capture-off', 'capture-all', 'capture-target');
        
        if (wrapper && this.captureMode !== 2) {
            wrapper.classList.remove('show');
            wrapper.style.display = 'none';
        }

        // Application du Mode
        if (this.captureMode === 0) {
            btn.classList.add('capture-off');
            if(icon) icon.textContent = "üï∏Ô∏è";
            if(text) text.textContent = "Capt. OFF";
        } 
        else if (this.captureMode === 1) {
            btn.classList.add('capture-all');
            if(icon) icon.textContent = "üî¥";
            if(text) text.textContent = "Capt. TOUS";
        } 
        else if (this.captureMode === 2) {
            btn.classList.add('capture-target');
            if(icon) icon.textContent = "üéØ";
            
            // ‚úÖ Gestion du texte Multiple
            const count = this.captureTargets ? this.captureTargets.length : 0;
            
            if (count === 0) {
                if(text) text.textContent = "Choisir...";
            } else if (count === 1) {
                const tName = this.captureTargets[0];
                if(text) text.textContent = tName.length > 9 ? tName.substring(0,8)+"." : tName;
            } else {
                if(text) text.textContent = `${count} Cibles`;
            }
            
            // For√ßage affichage
            if (wrapper) {
                wrapper.style.display = 'block';
                wrapper.classList.add('show');
            }
        }
    }


    // OPTIMISATION : Capture Classique (Sans Critique)
    async tryCapture(ballType) {
    if ((this.items[ballType] || 0) <= 0) return;

    // UI Freeze
    const buttonsDiv = document.querySelector('.balls-grid');
    if(buttonsDiv) { buttonsDiv.style.pointerEvents = 'none'; buttonsDiv.style.opacity = '0.5'; }

    // ============================================================
    // ‚úÖ IMPL√âMENTATION RECYCLAGE (Modification ici)
    // ============================================================
    
    // 1. R√©cup√©ration du niveau d'am√©lioration
    const recycleLevel = (this.upgrades && this.upgrades.recycle) ? this.upgrades.recycle.level : 0;
    const recycleChance = recycleLevel * 0.025; // 2% par niveau
    
    let ballSaved = false;

    // 3. Tirage au sort
    if (Math.random() < recycleChance) {
        ballSaved = true;
        
        // 1. Log classique (Journal de combat)
        logMessage(`‚ôªÔ∏è ${ballType} recycl√©e avec succ√®s !`);

        // 2. ‚úÖ NOTIFICATION VISUELLE (En haut √† droite)
        // On v√©rifie que le syst√®me de toast existe pour √©viter les erreurs
        if (typeof toast !== 'undefined') {
            // Titre : Recyclage, Message : Ball √©conomis√©e, Ic√¥ne : ‚ôªÔ∏è
            toast.success("Recyclage !", `${ballType} √©conomis√©e ‚ôªÔ∏è`);
        }
    }

    // 3. Consommation r√©elle (Seulement si PAS sauv√©e)
    if (!ballSaved) {
        this.items[ballType]--;
    }
    // ============================================================

    if(this.updateItemsDisplay) this.updateItemsDisplay();

    const enemy = this.currentEnemy;
    const ballDef = (typeof BALLS !== 'undefined') ? BALLS[ballType] : { catchMult: 1, name: 'Ball', img: '' };
        
        // --- CALCUL DES PROBABILIT√âS ---
        const baseChance = (typeof CATCH_RATES !== 'undefined' ? CATCH_RATES[enemy.rarity] : 0.1) || 0.1;
        let charmBonus = (this.currentPlayerCreature && this.currentPlayerCreature.passiveTalent === 'charmeur') ? 1.25 : 1.0;
        
        let catchRate = baseChance * ballDef.catchMult * charmBonus;
        if (ballType === 'masterball') catchRate = 1.0;

        let success = false;
        let shakes = 0;

        if (ballType === 'masterball') {
            success = true;
            shakes = 3; 
        } else {
            // Logique Classique "Shake Checks" (Gen 3/4)
            // On calcule la probabilit√© de passer UN shake (racine 4√®me)
            const shakeProbability = Math.pow(catchRate, 0.25);

            success = true;
            // On tente de passer 3 barri√®res (la 4√®me √©tant le "Click" final)
            for (let i = 1; i <= 3; i++) {
                if (Math.random() < shakeProbability) {
                    shakes++; // Ce shake est valid√©
                } else {
                    success = false;
                    break; // La balle casse ici
                }
            }
            // Si la boucle finit avec success = true, c'est captur√©
        }

        // --- LANCE L'ANIMATION (Sans le param√®tre critique) ---
        const spriteEl = document.querySelector('.capture-sprite');
        if (spriteEl && window.playCaptureSequence) {
            const ballImg = ballDef.img || "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png";
            
            // On envoie juste le succ√®s et le nombre de shakes
            await window.playCaptureSequence(ballImg, spriteEl, success, shakes);
        }

        // --- R√âSULTAT ---
        document.getElementById('captureModal').classList.remove('show');
        if(buttonsDiv) { buttonsDiv.style.pointerEvents = 'auto'; buttonsDiv.style.opacity = '1'; }

        if (success) {
            // ... (Copie ici ton bloc de SUCC√àS habituel : Cr√©ation, Pok√©dex, Fusion, Toast...) ...
            const trueRarity = this.getNaturalRarity(enemy.name);
            const capturedCreature = new Creature(enemy.name, enemy.type, enemy.level, trueRarity, false, enemy.isShiny, enemy.secondaryType);
            capturedCreature.ivHP = enemy.ivHP; capturedCreature.ivAttack = enemy.ivAttack;
            capturedCreature.ivDefense = enemy.ivDefense; capturedCreature.ivSpeed = enemy.ivSpeed;
            capturedCreature.recalculateStats();

            // ====================================================
            // ‚úÖ TRACKING SUCC√àS (AJOUT√â)
            // ====================================================
            
            // 1. Compteur Global
            this.stats.creaturesObtained++;
            // this.checkAchievements('creaturesObtained'); // D√©commente si tu as un succ√®s "Total Captures"

            // 2. Gestion Shiny
            if (capturedCreature.isShiny) {
                this.stats.shiniesObtained++;
                this.checkAchievements('shiniesObtained');
            }

            // 3. Gestion Perfect IV (100%)
            // On v√©rifie manuellement les 4 stats √† 31
            const isPerfect = (capturedCreature.ivHP >= 31 && capturedCreature.ivAttack >= 31 && capturedCreature.ivDefense >= 31 && capturedCreature.ivSpeed >= 31);

            if (isPerfect) {
                this.stats.perfectIvCount++;
                this.checkAchievements('perfectIvCount');

                // 4. Le Saint Graal : Shiny + Perfect
                if (capturedCreature.isShiny) {
                    this.stats.perfectShinyCount++;
                    this.checkAchievements('perfectShinyCount');
                }
            }
            // ====================================================

            this.checkSpecialQuests('creature_obtained', { creatureType: capturedCreature.type, secondaryType: capturedCreature.secondaryType });

            const pokedexKey = capturedCreature.name + "_" + capturedCreature.type + "_" + capturedCreature.rarity;
            if (!this.pokedex[pokedexKey]) {
                this.pokedex[pokedexKey] = { discovered: true, count: 1, shinyCount: capturedCreature.isShiny?1:0, hasShiny: capturedCreature.isShiny, name: capturedCreature.name, type: capturedCreature.type, rarity: capturedCreature.rarity, firstDiscoveredAt: Date.now() };
                this.checkSpecialQuests('new_discovery');
            } else {
                this.pokedex[pokedexKey].count++;
                if (capturedCreature.isShiny) this.pokedex[pokedexKey].shinyCount++;
            }

            const existingCreature = this.findCreatureByName(capturedCreature.name, capturedCreature.isShiny);

            if (existingCreature) {
                this.checkSpecialQuests('fusion_completed'); 
                const result = this.processFusion(capturedCreature, existingCreature);
                let msg = `üß¨ CAPTURE FUSION : +${result.shards} Shards.`;
                if (result.improved) msg += " IVs Am√©lior√©s !";
                logMessage(msg);
                toast.success("Capture Fusion", `+${result.shards} Shards` + (result.improved ? " & Stats Up" : ""));
            } else {
                const maxTeamSize = 6 + this.getAccountTalentBonus('team_slot');
                if (this.playerTeam.length < maxTeamSize) {
                    this.playerTeam.push(capturedCreature);
                    logMessage(`üéØ ${capturedCreature.name} rejoint l'√©quipe !`);
                } else {
                    this.storage.push(capturedCreature);
                    logMessage(`üéØ ${capturedCreature.name} envoy√© au stockage !`);
                }
                
                if (trueRarity === RARITY.LEGENDARY) toast.legendary("L√âGENDAIRE", `${capturedCreature.name} captur√© !`);
                else if (trueRarity === RARITY.EPIC) toast.info("EPIC", `${capturedCreature.name} captur√© !`);
                else toast.success("Capture R√©ussie", `${capturedCreature.name} ajout√© !`);
            }
            this.finalizeCombat(true);

        } else {
            // ECHEC
            let failMsg = `${enemy.name} s'est lib√©r√© !`;
            if (shakes === 0) failMsg = `La balle a cass√© tout de suite !`;
            if (shakes === 1) failMsg = `Une secousse... et √ßa casse.`;
            if (shakes === 2) failMsg = `Argh ! ${enemy.name} y √©tait presque !`;
            if (shakes === 3) failMsg = `INCROYABLE ! Il s'est lib√©r√© au dernier moment !`;

            toast.error("√âchec...", failMsg);
            logMessage(`üí® ${failMsg}`);
            this.finalizeCombat(false);
        }
    }

    // Passe la capture
    skipCapture() {
        document.getElementById('captureModal').classList.remove('show');
        logMessage("Vous laissez l'ennemi partir.");
        this.finalizeCombat(false);
    }

// GAMEPLAY : Logique de l'Auto-Catcher
    // OPTIMISATION : Auto-Catcher avec filtre "Nouveau" strict (Esp√®ce uniquement)
    triggerAutoCatch() {
    if (!this.currentEnemy) return;

        if (!this.hasAutoCatcher) return false;
        
        // S√©curit√© : Pas d'auto-catch en Tour ou Ar√®ne
        if (this.towerState.isActive || this.arenaState.active) return false;

        const enemy = this.currentEnemy;
        const s = this.autoCatcherSettings;
        let shouldCatch = false;

        // 1. Priorit√© Absolue : Shinies
        if (s.catchShiny && enemy.isShiny) shouldCatch = true;
        
        // 2. Nouveaux (CORRIG√â : On v√©rifie l'Esp√®ce, pas la variante)
        if (!shouldCatch && s.catchNew) {
            // On regarde dans tout le Pok√©dex si on a une entr√©e avec ce NOM qui a √©t√© captur√©e au moins 1 fois
            const alreadyCaughtSpecies = Object.values(this.pokedex).some(entry => 
                entry.name === enemy.name && entry.count > 0
            );

            // Si on ne l'a jamais vu (aucune raret√©), alors on capture
            if (!alreadyCaughtSpecies) {
                shouldCatch = true;
            }
        }

        // 3. Doublons (Farm) - Sauf Boss
        if (!shouldCatch && s.catchDupe && !enemy.isBoss) {
            shouldCatch = true;
        }

        if (!shouldCatch) return false;

        // 4. V√©rification Ressources
        const ballToUse = 'pokeball';
        if ((this.items[ballToUse] || 0) <= 0) return false; 

        // 5. Ex√©cution
        // Note : On utilise un petit log pour confirmer pourquoi il capture
        let reason = "Doublon";
        if (enemy.isShiny) reason = "‚ú® Shiny";
        else if (s.catchNew && !this.pokedex[enemy.name + "_" + enemy.type + "_" + enemy.rarity]) reason = "Nouveau";

        // On ne spam pas le log, tryCapture le fera
        this.tryCapture(ballToUse);
        
        return true; 
    }
	
	// UI : Mise √† jour du panneau Auto-Catcher
    updateAutoCatcherUI() {
        const panel = document.getElementById('autoCatcherPanel');
        if (!panel) return;

        if (this.hasAutoCatcher) {
            panel.style.display = 'block';
            document.getElementById('ac-shiny').checked = this.autoCatcherSettings.catchShiny;
            document.getElementById('ac-new').checked = this.autoCatcherSettings.catchNew;
            document.getElementById('ac-dupe').checked = this.autoCatcherSettings.catchDupe;
        } else {
            panel.style.display = 'none';
        }
    }

    toggleAutoCatch(setting) {
        if (setting === 'shiny') this.autoCatcherSettings.catchShiny = !this.autoCatcherSettings.catchShiny;
        if (setting === 'new') this.autoCatcherSettings.catchNew = !this.autoCatcherSettings.catchNew;
        if (setting === 'dupe') this.autoCatcherSettings.catchDupe = !this.autoCatcherSettings.catchDupe;
        this.saveGame(); // Sauvegarde la pr√©f√©rence
    }

    // V√©rifie si une cr√©ature a 31 IV partout (ou le max de ton jeu)
    isCreaturePerfect(creature) {
        if (!creature.ivs) return false; // S√©curit√©
        // V√©rifie que chaque stat (hp, attack, defense, speed, etc.) est √† 31
        return Object.values(creature.ivs).every(ivValue => ivValue >= 31);
    }
	
   finalizeCombat(captured) {
        const enemy = this.currentEnemy;
        if (!enemy) return;

        // 1. Nettoyage (Statuts & Berserker)
        if (this.currentPlayerCreature) {
            this.currentPlayerCreature.clearStatusEffect();
            this.currentPlayerCreature.berserkStacks = 0; 
        }

        // =================================================
        // CAS 1 : TOUR DE COMBAT
        // =================================================
        if (this.towerState.isActive) {
            // XP x15
            const expGain = Math.floor(enemy.level * 0.1 * this.getExpMultiplier());
            this.playerTeam.forEach(c => c.gainExp(expGain));

            // Marques
            this.marquesDuTriomphe = Number(this.marquesDuTriomphe) || 0;
            const floor = this.towerState.currentFloor;
            let marksWon = 1 + Math.floor(floor / 100);
            if (Math.random() < ((floor % 100) / 100)) marksWon++;

            if (marksWon > 0) {
                this.marquesDuTriomphe += marksWon;
                if (document.getElementById('enemySpriteContainer')) {
                    window.showFloatingText(`+${marksWon} ‚ìÇÔ∏è`, document.getElementById('enemySpriteContainer'), 'ft-damage-enemy');
                }
            }

            // Boss de Tour (x10)
            if (floor % 10 === 0) {
                // Soin 30%
                this.playerTeam.forEach(c => {
                    if (c.isAlive()) {
                        const heal = Math.floor(c.maxHp * 0.30);
                        c.mainAccountCurrentHp = Math.min(this.getPlayerMaxHp(), (c.mainAccountCurrentHp || 0) + heal);
                        window.showFloatingText(`+${formatFloatingNumber(heal)}`, document.getElementById('playerSpriteContainer'), 'ft-heal');
                    }
                });

                this.rollItemDrop(); 
                
                let bossEggRarity = RARITY.RARE;
                const roll = Math.random();
                if (roll < 0.10) bossEggRarity = RARITY.LEGENDARY;
                else if (roll < 0.55) bossEggRarity = RARITY.EPIC;
                this.addEgg(bossEggRarity);
                
                logMessage(`‚ú® MA√éTRE D'√âTAGE VAINCU ! +${marksWon} Marques, ≈íuf ${bossEggRarity} & Soin !`);
                toast.success("Boss Tour Vaincu !", `+${marksWon} ‚ìÇÔ∏è, ≈íuf ${bossEggRarity} & Soin`);
            }

            // √âtage suivant
            this.towerState.currentEnemyIndex++;
            if (this.towerState.currentEnemyIndex < this.towerState.enemyTeam.length) {
                this.currentEnemy = this.towerState.enemyTeam[this.towerState.currentEnemyIndex];
                this.combatState = 'starting';
                this.combatStartTime = Date.now();
                this.triggerAutoSelect();
            } else {
                this.nextTowerFloor();
            }
            
            this.updateDisplay();
            return; // STOP
        }
        
        // =================================================
        // CAS 2 : AR√àNE
        // =================================================
        if (this.arenaState.active) {
            this.arenaState.currentChampionIndex++;
            if (this.arenaState.currentChampionIndex >= this.arenaState.championTeam.length) {
                this.winArena();
            } else {
                this.currentEnemy = this.arenaState.championTeam[this.arenaState.currentChampionIndex];
                this.currentEnemy.clearStatusEffect();
                logMessage("Le champion envoie " + this.currentEnemy.name + " !");
                this.combatState = 'fighting';
            }
            return; // STOP
        }

        // =================================================
        // CAS 3 : COMBAT DE ZONE (Standard)
        // =================================================
        
        if (!captured) logMessage(enemy.name + " est vaincu !");
        
        const zone = ZONES[currentZone];
        const isBoss = enemy.isBoss;
        const isEpic = enemy.isEpic;

        // Compteurs Boss/Epic
        if (isBoss) {
            this.stats.bossDefeated++;
            if (this.zoneProgress[currentZone]) this.zoneProgress[currentZone].bossesDefeated++;
            this.checkSpecialQuests('bossDefeated');
        }
        if (isEpic) {
            this.stats.epicDefeated++;
            if (this.zoneProgress[currentZone]) this.zoneProgress[currentZone].epicsDefeated++;
        }

        // 1. GAIN : POK√âDOLLARS
        let pokedollarsEarned = Math.floor((currentZone * 20) + (Math.random() * currentZone * 10));
        if (isBoss) pokedollarsEarned *= 5;
        else if (isEpic) pokedollarsEarned *= 2;
        
        // Bonus (Collecteur + Fortune)
        const collecteurBonus = this.getTalentStackBonus('collecteur');
        pokedollarsEarned = Math.floor(pokedollarsEarned * (1 + collecteurBonus));
        
        const fortuneBonus = 1 + this.getAccountTalentBonus('pokedollars_mult');
        pokedollarsEarned = Math.floor(pokedollarsEarned * fortuneBonus);
        
        this.pokedollars += pokedollarsEarned;
        this.stats.totalPokedollarsEarned += pokedollarsEarned;
        this.checkAchievements('totalPokedollarsEarned');
        if (pokedollarsEarned > 0) {
            this.showUiFloatingText('headerStatMoney', `+${pokedollarsEarned}$`, 'ft-money');
        }
        this.checkSpecialQuests('pokedollars_gained');

        // 2. GAIN : XP
        let expMultiplier = isBoss ? 50 : (isEpic ? 25 : 10);
        const baseExpGain = Math.floor(enemy.level * expMultiplier);
        const expGain = Math.floor(baseExpGain * this.getExpMultiplier());
        
        const teamTalents = this.playerTeam.filter(c => c.passiveTalent).map(c => c.passiveTalent);
        
        // XP √âquipe
        let anyLeveledUp = false;

        this.playerTeam.forEach(c => { // Ici 'c' repr√©sente le Pok√©mon
             // Si le Pok√©mon gagne un niveau (gainExp retourne true)
             if(c.gainExp(expGain, teamTalents)) {
                 anyLeveledUp = true;

                 // ‚úÖ V√âRIFICATION SUCC√àS (D√©plac√© ici, sur 'c')
                 if (c.level > this.stats.highestLevelReached) {
                     this.stats.highestLevelReached = c.level;
                     this.checkAchievements('highestLevelReached');
                 }
                 this.updateTeamPowerStat();
             }
        });

        if(anyLeveledUp) this.checkSpecialQuests('level_up');

        // XP Pension (1%)
        const pensionExpGain = Math.floor(expGain * 0.01); 
        if (pensionExpGain > 0 && this.pension.length > 0) {
            let pensionLeveledUp = false;
            this.pension.forEach(c => {
                if(c.gainExp(pensionExpGain, teamTalents)) pensionLeveledUp = true;
            });
            if (pensionLeveledUp) {
                this.updatePensionDisplay();
                this.incrementPlayerStats(); 
            }
        }

        // 3. BUTIN (Tickets, Objets, ≈íufs)
        if ((isBoss && Math.random() < 0.10) || (isEpic && Math.random() < 0.01)) {
            this.combatTickets++;
            logMessage("üéüÔ∏è Ticket de Combat trouv√© !");
        }

        this.rollItemDrop();

        // Drop ≈íufs
        let eggChance = 0;
        if (isBoss) {
            let rarity = RARITY.RARE;
            const r = Math.random();
            if (r < 0.10) rarity = RARITY.LEGENDARY;
            else if (r < 0.55) rarity = RARITY.EPIC;
            
            this.addEgg(rarity);
            logMessage(`üéÅ Butin Boss : ≈íuf ${rarity} !`);
            
            // Chance double drop
            if (Math.random() < 0.5) {
                this.addEgg(this.determineEggRarity());
                logMessage("üéÅ ≈íuf bonus !");
            }
        } else if (isEpic) {
            this.addEgg(RARITY.RARE);
            if (Math.random() < 0.3) {
                this.addEgg(RARITY.EPIC);
                logMessage("üéÅ Butin √âpique : ≈íuf Epic !");
            }
        } else {
            const baseEggChance = currentZone * 0.001 + 0.01;
            if (Math.random() < (baseEggChance + this.getEggDropBonus())) {
                this.addEgg(this.determineEggRarity());
            }
        }

        // 4. PROGRESSION (Tiers)
        const maxTier = zone.maxTier || 50;
        if (!this.zoneProgress[currentZone].pokemonTiers) {
            this.zoneProgress[currentZone].pokemonTiers = {};
        }
        const currentTier = this.zoneProgress[currentZone].pokemonTiers[enemy.name] || 0;
        if (currentTier < maxTier) {
            this.zoneProgress[currentZone].pokemonTiers[enemy.name] = currentTier + 1;
        }
        
        // D√©blocage Zone Suivante
        const nextZone = parseInt(currentZone) + 1;
        if (this.isZoneMastered(currentZone)) {
            // Si on d√©bloque une zone jamais atteinte
            if (nextZone > maxReachedZone && ZONES[nextZone]) {
                maxReachedZone = nextZone;
                logMessage(`üéâ NOUVELLE ZONE D√âBLOQU√âE : ${ZONES[nextZone].name} !`);
                toast.success("Progression", `Acc√®s ouvert vers ${ZONES[nextZone].name}`);
                this.updateZoneSelector();
            }
        }
        this.updateZoneSelector(); 
        
        if (ZONES[nextZone] && !this.isZoneUnlocked(nextZone) && this.isZoneUnlocked(nextZone, true)) {
            logMessage(`‚úÖ ZONE D√âBLOQU√âE : ${ZONES[nextZone].name} !`);
            this.updateZoneSelector();
        }
        
        // Stats de dur√©e
        if (this.combatStartTime) {
            const duration = Date.now() - this.combatStartTime;
            if (!this.recentCombatDurations) this.recentCombatDurations = [];
            this.recentCombatDurations.push(duration);
            if (this.recentCombatDurations.length > 10) this.recentCombatDurations.shift();
        }

        // ... (dans finalizeCombat)

        // 1. Passage en √©tat d'attente
        this.combatState = 'waiting';
        this.lastCombatTime = Date.now();
        this.currentEnemy = null;
        
        // 2. CIBLAGE : On r√©cup√®re la carte qui pose probl√®me
        // (Adapte le s√©lecteur si ta carte est ailleurs, mais vu ton HTML, c'est une .creature-card)
        const enemyCard = document.querySelector('#enemySpriteContainer .creature-card') 
                          || document.querySelector('.creature-card'); 

        if (enemyCard) {
            // ‚úÖ √âTAPE 1 : Nettoyage Visuel
            // On enl√®ve 'shiny', 'rarity-rare', etc. L'√©toile va dispara√Ætre.
            enemyCard.className = 'creature-card'; 
            
            // On cache le tout visuellement
            enemyCard.style.opacity = '0'; 

            // ‚úÖ √âTAPE 2 : D√©sactivation des Clics (Le plus important !)
            // On emp√™che le curseur de devenir une main
            enemyCard.style.cursor = 'default';
            
            // On rend l'√©l√©ment "transparent" √† la souris (on ne peut plus cliquer dessus)
            enemyCard.style.pointerEvents = 'none';
            
            // S√©curit√© ultime : on supprime l'action de clic
            enemyCard.removeAttribute('onclick'); 
        }

        // 3. Mise √† jour du reste
        this.updateZoneSelector();
        this.rollRoamingEncounter(); 
        if (typeof updateZoneInfo === 'function') updateZoneInfo();
        
        this.updateDisplay();
}
	
	
	// OPTIMISATION : Fusion avec Correction de Raret√© (Fix Snorlax)
    processFusion(source, target) {
        let improved = false;
        let prestigeImproved = false;
        let shinyFound = false;
        let rarityFixed = false; // Nouveau flag

        // 1. Fusion des IVs
        if (source.ivHP > target.ivHP) { target.ivHP = source.ivHP; improved = true; }
        if (source.ivAttack > target.ivAttack) { target.ivAttack = source.ivAttack; improved = true; }
        if (source.ivDefense > target.ivDefense) { target.ivDefense = source.ivDefense; improved = true; }
        if (source.ivSpeed > target.ivSpeed) { target.ivSpeed = source.ivSpeed; improved = true; }

        // 2. Fusion du Prestige
        if (source.prestige > target.prestige) {
            target.prestige = source.prestige;
            prestigeImproved = true;
            improved = true;
        }

        
        
        // A. Additionner les Jetons non d√©pens√©s
        if (source.prestigeTokens > 0) {
            target.prestigeTokens = (target.prestigeTokens || 0) + source.prestigeTokens;
            // On consid√®re √ßa comme une am√©lioration (le joueur a gagn√© une ressource)
            // Pas besoin de flag 'improved' pour le recalcul, mais c'est bien pour la logique
        }

        // B. Additionner les Bonus de Stats d√©j√† achet√©s
        if (source.prestigeBonuses) {
            if (!target.prestigeBonuses) target.prestigeBonuses = { hp: 0, attack: 0, defense: 0, speed: 0 };
            
            // On additionne tout (Cumulatif)
            target.prestigeBonuses.hp = (target.prestigeBonuses.hp || 0) + (source.prestigeBonuses.hp || 0);
            target.prestigeBonuses.attack = (target.prestigeBonuses.attack || 0) + (source.prestigeBonuses.attack || 0);
            target.prestigeBonuses.defense = (target.prestigeBonuses.defense || 0) + (source.prestigeBonuses.defense || 0);
            target.prestigeBonuses.speed = (target.prestigeBonuses.speed || 0) + (source.prestigeBonuses.speed || 0);
            
            // Si la source avait des bonus, la cible devient plus forte -> Recalcul n√©cessaire
            if (source.prestigeBonuses.hp > 0 || source.prestigeBonuses.attack > 0 || 
                source.prestigeBonuses.defense > 0 || source.prestigeBonuses.speed > 0) {
                improved = true;
            }
        }
        

        // 3. Fusion Shiny
        if (source.isShiny && !target.isShiny) {
            target.isShiny = true;
            shinyFound = true;
            improved = true;
        }

        // 4. ‚úÖ CORRECTION RARET√â (Le Fix pour ton Snorlax)
        // On d√©finit une hi√©rarchie de valeur
        const rarityValue = { 'common': 1, 'rare': 2, 'epic': 3, 'legendary': 4 };
        
        // Si le nouveau est "plus rare" (la bonne raret√©) que l'ancien (le bugu√©)
        if (rarityValue[source.rarity] > rarityValue[target.rarity]) {
            target.rarity = source.rarity;
            rarityFixed = true;
            improved = true;
            // On v√©rifie si un talent doit √™tre assign√© (ex: passage de Rare √† Epic)
            if (!target.passiveTalent && (target.rarity === 'epic' || target.rarity === 'legendary')) {
                target.assignRandomTalent(); // On lui donne son talent manquant !
            }
        }

        // 5. Recalcul
        if (improved) {
            target.recalculateStats();
            target.heal(); 
        }

        // 6. Shards
        let shardsGained = source.isShiny ? 3 : 1;
        if (Math.random() < this.getShardBonusChance()) shardsGained *= 2;
        
        const shardKey = getShardKey(target.name, target.rarity);
        this.shards[shardKey] = (this.shards[shardKey] || 0) + shardsGained;
        
        for (let i = 0; i < shardsGained; i++) this.checkSpecialQuests('totalShards');
        this.checkSpecialQuests('fusion_completed');

        return {
            improved: improved,
            shards: shardsGained,
            prestigeUp: prestigeImproved,
            becameShiny: shinyFound,
            rarityUp: rarityFixed // On renvoie l'info
        };
    }
	
// LOGIQUE : Drop d'objets (S√©curis√© : Pas d'Objets Cl√©s)
   rollItemDrop(isSimulation = false) {
    const zone = ZONES[currentZone];
    
    // Taux de base
    let dropChance = 0.05 + (currentZone * 0.001); 
    
    // SI SIMULATION : On divise la chance par 2 (√âquilibrage)
    // ‚ö†Ô∏è NOTE : Si tu veux exactement les m√™mes rates qu'en online pour le rattrapage,
    // tu devrais peut-√™tre retirer cette condition ou passer un autre param√®tre.
    if (isSimulation) {
        dropChance = dropChance / 2;
    }
    
    if (Math.random() < dropChance) {
        const rarityRoll = Math.random();
        let itemRarity;
        
        if (rarityRoll < 0.81) itemRarity = 'common';
        else if (rarityRoll < 0.96) itemRarity = 'rare';
        else if (rarityRoll < 0.99) itemRarity = 'epic';
        else itemRarity = 'legendary';
        
        const itemsOfRarity = Object.keys(ALL_ITEMS).filter(key => {
            const item = ALL_ITEMS[key];
            
            // ‚úÖ On interdit les objets cl√©s en drop al√©atoire
            if (item.type === 'key_item') return false;
            
            return item.rarity === itemRarity;
        });
        
        if (itemsOfRarity.length > 0) {
            const itemKey = itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
            
            // Si simulation => updateUI = false (pour ne pas lagger)
            // !isSimulation renvoie 'false' si on est en simulation, donc pas d'update UI
            this.addItem(itemKey, 1, !isSimulation); 
            
            // ‚úÖ LE CHANGEMENT CRUCIAL EST ICI :
            return itemKey; // On retourne le nom de l'objet pour le rapport
        }
    }
    
    return null; // ‚úÖ On retourne null si rien n'est tomb√©
}

// Dans la classe Game
addItem(itemKey, quantity = 1, updateUI = true) { // Ajout du param√®tre updateUI
    const item = ALL_ITEMS[itemKey];
    if (!item) return;
    
    this.items[itemKey] = (this.items[itemKey] || 0) + quantity;
    
    // On loggue toujours (le log est d√©sactiv√© globalement pendant la simulation de toute fa√ßon)
    logMessage(`‚ú® ${item.icon} ${item.name} x${quantity} obtenu !`);
    
    // On ne met √† jour l'affichage que si demand√©
    if (updateUI) {
        this.updateItemsDisplay();
    }
}

// UI : Affiche le contenu du Sac √† Dos (Version S√©curis√©e pour Key Items)
    updateItemsDisplay() {
        const container = document.getElementById('itemsContainer');
        if (!container) return;
        
        const itemKeys = Object.keys(this.items).filter(key => this.items[key] > 0);
        
        // --- Structure de base ---
        let headerCount = document.getElementById('inventory-total-count');
        let grid = container.querySelector('.inventory-grid');

        if (!grid) {
            container.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h3 style="margin:0; color:#334155; font-size:18px;">üéí Sac √† dos</h3>
                    <span id="inventory-total-count" style="font-size:11px; color:#64748b; font-weight:700; background:#f1f5f9; padding:4px 8px; border-radius:12px;">
                        0 OBJETS
                    </span>
                </div>
                <div id="inventory-empty-msg" style="display:none; text-align: center; color: #94a3b8; padding: 30px; border: 2px dashed #e2e8f0; border-radius: 10px; font-style: italic;">Votre sac est vide.</div>
            `;
            grid = document.createElement('div');
            grid.className = 'inventory-grid';
            container.appendChild(grid);
            headerCount = document.getElementById('inventory-total-count');
        }

        if (headerCount) headerCount.textContent = `${itemKeys.length} TYPES D'OBJETS`;

        const emptyMsg = document.getElementById('inventory-empty-msg');
        if (itemKeys.length === 0) {
            if (grid) grid.style.display = 'none';
            if (emptyMsg) emptyMsg.style.display = 'block';
            return;
        } else {
            if (grid) grid.style.display = 'grid';
            if (emptyMsg) emptyMsg.style.display = 'none';
        }

        // Tri
        itemKeys.sort((a, b) => {
            const itemA = ALL_ITEMS[a] || { rarity: 'common' };
            const itemB = ALL_ITEMS[b] || { rarity: 'common' };
            const getWeight = (key, item) => {
                if (item.type === 'key_item') return 0; // Les objets cl√©s en premier !
                if (key.includes('ball') || (item.type && item.type === 'ball')) return 1;
                if (typeof HELD_ITEMS !== 'undefined' && HELD_ITEMS[key]) return 2;
                if (item.effect) return 3;
                return 4;
            };
            return getWeight(a, itemA) - getWeight(b, itemB);
        });

        // --- Rendu ---
        const currentSlots = Array.from(grid.children);
        const activeIds = new Set();

        itemKeys.forEach(key => {
            const item = ALL_ITEMS[key] || { name: key, description: "Objet inconnu", icon: "‚ùì", rarity: "common" };
            const count = this.items[key];
            const slotId = `inv-slot-${key}`;
            
            activeIds.add(slotId);

            let card = document.getElementById(slotId);

            if (card) {
                // Update simple
                const countDiv = card.querySelector('.item-count');
                if (countDiv && countDiv.textContent !== `x${count}`) {
                    countDiv.textContent = `x${count}`;
                }
                grid.appendChild(card); 
            } else {
                // Cr√©ation
                card = document.createElement('div');
                card.id = slotId;
                card.className = `inventory-slot rarity-${item.rarity || 'common'}`; 
                
                let typeIcon = '';
                // Action par d√©faut : Utiliser
                let clickAction = `game.useItem('${key}', 1, event)`; 

                // CAS 1 : Objets Cl√©s (Canne, Surf)
                if (item.type === 'key_item') {
                    card.style.borderColor = "#ffd700"; // Bordure dor√©e pour les distinguer
                    card.style.background = "#fffbeb";
                    typeIcon = '<span class="item-type-badge" style="background:#fef3c7; color:#d97706;">CL√â</span>';
                    // ‚úÖ PROTECTION : On remplace l'action par un message
                    clickAction = "toast.info('Objet Cl√©', 'Cet objet s\\'active automatiquement dans les zones appropri√©es.')";
                }
                
                // CAS 2 : Objets Tenus (Restes, etc.)
                else if (typeof HELD_ITEMS !== 'undefined' && HELD_ITEMS[key]) {
                    card.classList.add('is-held-item');
                    typeIcon = '<span class="item-type-badge">√âQUIP.</span>';
                    clickAction = "toast.info('Objet Tenu', '√âquipez cet objet depuis le menu d\\'une cr√©ature.')";
                }

                let iconHTML = `<div style="font-size:32px;">${item.icon || 'üì¶'}</div>`;
                if (item.img) {
                    iconHTML = `<img src="${item.img}" class="item-sprite-img" alt="${item.name}" style="width:48px; height:48px; object-fit:contain;">`;
                }

                const isVitamin = item.effect && item.effect.duration === null;
                const safeName = item.name.replace(/'/g, "\\'");
                const safeDesc = item.description ? item.description.replace(/'/g, "\\'") : "";

                card.innerHTML = `
                    <div class="inventory-slot-content" 
                         onmouseenter="game.scheduleTooltip(event, '${safeName}', '${safeDesc}')" 
                         onmouseleave="game.hideTooltip()"
                         onclick="${clickAction}" 
                         style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                         
                        ${typeIcon}
                        <div class="item-icon">${iconHTML}</div>
                        <div class="item-count">x${count}</div>
                        <div class="item-name">${item.name}</div>
                        
                        <div style="font-size: 9px; color: #94a3b8; margin-top: 2px; opacity: 1; min-height:11px;">
                            ${isVitamin ? 'Ctrl: Tout' : ''}
                        </div>
                    </div>
                `;

                grid.appendChild(card);
            }
        });

        // Nettoyage
        currentSlots.forEach(slot => {
            if (!activeIds.has(slot.id)) slot.remove();
        });
    }
updateStatBoostsDisplay() {
    const container = document.getElementById('activeStatBoosts');
    if (!container) {
        console.warn('‚ùå activeStatBoosts introuvable dans le HTML !');
        return;
    }
    
    if (!this.activeStatBoosts || this.activeStatBoosts.length === 0) {
        container.style.display = 'none';
        return;
    }
    
    container.style.display = 'block';
    container.innerHTML = '<h3>‚ö° Boosts Actifs</h3>';
    
    const boostsList = document.createElement('div');
    boostsList.style.cssText = 'display: flex; flex-direction: column; gap: 8px; margin-top: 10px;';
    
    const statNames = {
        hp: 'PV',
        attack: 'Attaque',
        defense: 'D√©fense',
        speed: 'Vitesse',
        all: 'TOUTES les stats'
    };
    
    this.activeStatBoosts.forEach(boost => {
        const timeLeft = boost.endTime - Date.now();
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        
        const boostItem = document.createElement('div');
        boostItem.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #e1f5fe 0%, #81d4fa 100%);
            border: 2px solid #0277bd;
            border-radius: 8px;
            padding: 10px 15px;
        `;
        
        boostItem.innerHTML = `
            <span style="font-weight: bold; color: #0277bd;">
                ${boost.emoji} +${(boost.value * 100)}% ${statNames[boost.stat]}
            </span>
            <span style="font-size: 12px; color: #666; background: rgba(255, 255, 255, 1); padding: 4px 8px; border-radius: 12px;">
                ${minutes}:${seconds.toString().padStart(2, '0')}
            </span>
        `;
        
        boostsList.appendChild(boostItem);
    });
    
    container.appendChild(boostsList);
    
}

// S√âCURIT√â : V√©rification d√©blocage Ar√®ne (Correction Data Model)
    isArenaUnlocked(arenaId) {
        // S√©curit√© de base
        if (typeof ARENAS === 'undefined') return true;
        const arena = ARENAS[arenaId];
        if (!arena) return false;

        // 1. Condition de Badge pr√©c√©dent (Progression lin√©aire des ar√®nes)
        // Exemple : L'ar√®ne 2 n√©cessite le badge de l'ar√®ne 1
        // (Si tu as d√©fini 'requiredBadge' dans tes constantes, sinon on ignore)
        if (arena.requiredBadge) {
            if (!this.hasBadge(arena.requiredBadge)) return false;
        }

        // 2. ‚úÖ LE FIX EST ICI : Condition de Zone Requise
        // Tes donn√©es utilisent 'requiredZone' (ex: 3 pour Argenta)
        if (arena.requiredZone) {
            // On v√©rifie si cette zone sp√©cifique est MA√éTRIS√âE √† 100%
            if (!this.isZoneMastered(arena.requiredZone)) return false;
        }

        // 3. Condition Legacy (Pour compatibilit√© si tu changes tes donn√©es plus tard)
        if (arena.unlockCondition && arena.unlockCondition.type === 'zone_mastery') {
            return this.isZoneMastered(arena.unlockCondition.zoneId);
        }

        // Si toutes les conditions passent, l'ar√®ne est ouverte
        return true;
    }

hasBadge(badgeKey) {
    return this.badges[badgeKey] === true;
}

getAccountTalentBonus(effectType) {
    let totalBonus = 0;
    
    Object.entries(this.badges).forEach(([talentKey, unlocked]) => {
        if (unlocked) {
            const talent = ACCOUNT_TALENTS[talentKey];
            if (talent && talent.effect === effectType) {
                totalBonus += talent.value;
            }
        }
    });
    
    return totalBonus;
}


getTalentStackBonus(talentName) {
    const count = this.playerTeam.filter(c => c.passiveTalent === talentName).length;
    if (count === 0) return 0;
    
    // D√©finir les bonus par niveau de stack
    const bonusTables = {
        'mentor': [0, 0.25, 0.40, 0.50, 0.55, 0.58, 0.60],        // XP
        'collecteur': [0, 0.50, 15, 0.90, 1.00, 1.05, 1.10],    // Pok√©dollars
        'maitre': [0, 0.20, 0.35, 0.45, 0.50, 0.53, 0.55],        // D√©g√¢ts STAB
        'catalyseur': [0, 0.025, 0.045, 0.060, 0.070, 0.075, 0.08], // Chance statut
        'catalyseur_supreme': [0, 0.05, 0.08, 0.10, 0.11, 0.115, 0.12], // Chance statut
        'aura': [0, 0.10, 0.17, 0.22, 0.25, 0.27, 0.28]           // Stats √©quipe
    };
    
    const table = bonusTables[talentName];
    if (!table) return 0;
    
    const index = Math.min(count, table.length - 1);
    return table[index];
}

createChampionTeam(arenaId) {
        const arena = ARENAS[arenaId];
        if (!arena) return [];
        
        const team = [];
        const level = arena.teamLevel;
        const type = arena.type;
        
        // On s'assure d'avoir un nombre (1 √† 8)
        const difficulty = parseInt(arenaId) || 1;

        const teamNames = arena.fixedTeam || []; 

        teamNames.forEach(name => {
            const creature = new Creature(
                name,
                type,
                level,
                RARITY.EPIC, 
                true, // isEnemy
                false // isShiny
            );
            
            // --- BOOST CHAMPION DYNAMIQUE (Selon le N¬∞ d'Ar√®ne) ---
            
            // PV 
            const hpMult = 2 + (difficulty * 1);
            
            // Stats (ATK/DEF) : 
            const statMult = 2 + (difficulty * 1);
            
            // Vitesse :
            const speedMult = 2 + (difficulty * 1);

            creature.maxHp = Math.floor(creature.maxHp * hpMult);
            creature.attack = Math.floor(creature.attack * statMult);
            creature.defense = Math.floor(creature.defense * statMult);
            creature.speed = Math.floor(creature.speed * speedMult);
            
            // Soin complet avec les nouveaux PV
            creature.currentHp = creature.maxHp;
            
            // Talent & ATB
            creature.assignRandomTalent();
            creature.actionGauge = 0;
            creature.actionThreshold = 10000;
            
            team.push(creature);
        });
        
        return team;
    }

startArena(arenaId) {
        // 1. V√©rifications de base
        if (!this.isArenaUnlocked(arenaId)) {
            logMessage("Cette ar√®ne n'est pas encore d√©bloqu√©e !");
            return false;
        }
        
        const arena = ARENAS[arenaId];
        if (this.hasBadge(arena.badge)) {
            logMessage("Vous avez d√©j√† obtenu le badge de cette ar√®ne !");
            return false;
        }

        if (this.towerState.isActive) {
            logMessage("Quittez la Tour de Combat avant de d√©fier un champion !");
            return false;
        }
        if (this.arenaState.active) {
            logMessage("Un d√©fi d'ar√®ne est d√©j√† en cours !");
            return false;
        }
        
        // 2. Interruption du Farming
        if (this.combatState === 'fighting' || this.combatState === 'starting') {
            logMessage("Combat sauvage interrompu pour le d√©fi d'ar√®ne !");
            this.currentEnemy = null;
            this.combatState = 'waiting';
        }

        // 3. ‚úÖ PR√âPARATION CRITIQUE (Le Fix est ici)
        console.log("üèüÔ∏è Pr√©paration Ar√®ne : Application des synergies...");

        // A. On force le recalcul pour "cuire" les synergies dans les stats brutes
        this.playerTeam.forEach(c => c.recalculateStats());

        // B. On soigne tout le monde (pour remplir la nouvelle barre de PV boost√©e)
        this.playerTeam.forEach(c => {
            c.heal(); 
            c.currentStamina = c.maxStamina;
            c.clearStatusEffect();
            c.actionGauge = 0;
            c.ultimateCharge = 0;
            c.ultimateActive = false;
        });
        
        // 4. Lancement de l'Ar√®ne
        this.arenaState.active = true;
        this.arenaState.arenaId = arenaId;
        this.arenaState.championTeam = this.createChampionTeam(arenaId);
        this.arenaState.currentChampionIndex = 0;
        this.arenaState.startTime = Date.now();
        this.arenaState.maxDuration = 90000; 
        
        // 5. Configuration Combat
        this.activeCreatureIndex = 0;
        this.currentPlayerCreature = this.playerTeam[0];
        
        // Backup des stats globales (au cas o√π)
        this.currentPlayerCreature.mainAccountCurrentHp = this.playerMainStats.hp; 
        
        this.currentEnemy = this.arenaState.championTeam[0];
        this.combatState = 'starting';
        this.combatStartTime = Date.now();
        
        logMessage("=== üèüÔ∏è D√âFI D'AR√àNE COMMENC√â ===");
        logMessage(`Champion ${arena.championName} vous d√©fie !`);
        
        this.updateDisplay();
        return true;
    }

checkArenaTimeout() {
    if (!this.arenaState.active) return false;
    
    const elapsed = Date.now() - this.arenaState.startTime;
    if (elapsed >= this.arenaState.maxDuration) {
        this.loseArena("Temps ecoule !");
        return true;
    }
    
    return false;
}

// Affiche la modale de synergie avec les d√©tails
    showSynergyModal(name, description, icon) {
        const modal = document.getElementById('synergyModal');
        const title = document.getElementById('synergyModalTitle');
        const content = document.getElementById('synergyModalContent');

        if (!modal || !title || !content) return;

        // Mise √† jour du contenu
        title.innerHTML = `${icon} ${name}`;
        content.innerHTML = description;

        // Affichage
        modal.classList.add('show');
    }
	
	

winArena() {
    if (!this.arenaState.active) return;
    
    const arena = ARENAS[this.arenaState.arenaId];
    const elapsedTime = ((Date.now() - this.arenaState.startTime) / 1000).toFixed(1);
    
    this.badges[arena.badge] = true;
    this.checkAchievements('badgesEarned');
    logMessage("=== VICTOIRE D'ARENE ===");
    logMessage("Vous avez vaincu " + arena.championName + " en " + elapsedTime + "s !");
    logMessage("BADGE OBTENU: " + ACCOUNT_TALENTS[arena.badge].name);
    logMessage(ACCOUNT_TALENTS[arena.badge].description);
    
    this.stats.arenasWon = (this.stats.arenasWon || 0) + 1;
    
    this.resetArenaState();
    this.applyAccountTalents();
}

loseArena(reason = "Defaite") {
    if (!this.arenaState.active) return;
    
    const arena = ARENAS[this.arenaState.arenaId];
    
    logMessage("=== DEFAITE D'ARENE ===");
    logMessage(reason);
    logMessage("Champion " + arena.championName + " n'a pas ete vaincu.");
    logMessage("Vous pouvez reessayer !");
    
    this.resetArenaState();
}

resetArenaState() {
    this.arenaState = {
        active: false,
        arenaId: null,
        championTeam: [],
        currentChampionIndex: 0,
        startTime: 0,
        maxDuration: 90000
    };
    
    this.combatState = 'waiting';
    this.lastCombatTime = Date.now();
    this.currentEnemy = null;
    
    for (const creature of this.playerTeam) {
        creature.heal();
        creature.currentStamina = creature.maxStamina;
        creature.clearStatusEffect();
    }
}

/**
    * Calcule les multiplicateurs de synergies actifs pour l'√©quipe du joueur.
    * CORRECTIF : On compte TOUS les membres (m√™me KO) pour √©viter de perdre les bonus en plein combat.
    */
    getActiveSynergies() {
        const typeCounts = {};
        
        // 1. Compter les types (Inclus les KO)
        this.playerTeam.forEach(c => {
            // ‚úÖ RETRAIT de "if (c.isAlive())"
            // Une synergie est une construction d'√©quipe, elle doit rester stable.
            if (c) { 
                typeCounts[c.type] = (typeCounts[c.type] || 0) + 1;
                if (c.secondaryType) {
                    typeCounts[c.secondaryType] = (typeCounts[c.secondaryType] || 0) + 1;
                }
            }
        });

        // Les bonus commencent √† 1.0 (100%)
        const bonuses = { attack_mult: 1, defense_mult: 1, max_hp_mult: 1, exp_mult: 1, speed_mult: 1 };

        if (typeof TEAM_SYNERGIES === 'undefined') return bonuses;

        Object.values(TEAM_SYNERGIES).forEach(synergy => {
            let isActive = false;

            if (synergy.all_required) {
                isActive = synergy.types.every(type => (typeCounts[type] || 0) >= synergy.min_count);
            } else {
                isActive = synergy.types.some(type => (typeCounts[type] || 0) >= synergy.min_count);
            }
            
            if (isActive) {
                if (synergy.effect.attack_mult) bonuses.attack_mult += synergy.effect.attack_mult;
                if (synergy.effect.defense_mult) bonuses.defense_mult += synergy.effect.defense_mult;
                if (synergy.effect.max_hp_mult) bonuses.max_hp_mult += synergy.effect.max_hp_mult;
                if (synergy.effect.exp_mult) bonuses.exp_mult += synergy.effect.exp_mult;
                if (synergy.effect.speed_mult) bonuses.speed_mult += synergy.effect.speed_mult;
            }
        });

        return bonuses;
    }
	
	refreshTeamStats() {
        this.playerTeam.forEach(creature => {
            // C'est cette ligne qui fait le travail !
            if (creature.recalculateStats) creature.recalculateStats(); 
        });
        console.log("üîÑ Stats de l'√©quipe mises √† jour (Synergies recalcul√©es) !");
        
        // Mettre √† jour l'affichage apr√®s le calcul
        this.updateDisplay();
    }
	changeZone(zoneId) {
        // 1. Force le navigateur √† l√¢cher le focus pour permettre l'affichage
        const selector = document.getElementById('zoneSelect');
        if (selector) selector.blur();

        const zId = parseInt(zoneId);

        // 2. V√©rification de s√©curit√©
        if (!this.isZoneUnlocked(zId)) {
            const prevZone = zId - 1;
            const prevZoneName = ZONES[prevZone] ? ZONES[prevZone].name : "pr√©c√©dente";
            if (typeof toast !== 'undefined') toast.error("Zone Verrouill√©e", `Terminez d'abord : ${prevZoneName}`);
            
            this.updateZoneSelector(); 
            return;
        }

        // 3. Application du changement
        currentZone = zId;
        
        this.currentEnemy = null;
        this.combatState = 'waiting';
        this.lastCombatTime = Date.now();
        
        logMessage(`Voyage vers : ${ZONES[currentZone].name}`);

        // 4. Mises √† jour UI
        this.updateZoneSelector(); 
        this.updateCaptureTargetList();
        
        if (typeof updateZoneInfo === 'function') updateZoneInfo();

        if (!this.sessionStats.zonesVisited) this.sessionStats.zonesVisited = new Set();
        this.sessionStats.zonesVisited.add(zId);
        this.checkSpecialQuests('zone_visited');

        // =========================================================
        // ‚úÖ GESTION DES QU√äTES D'HISTOIRE (SC√âNARIO COMPLET)
        // =========================================================
        
        // Helper : V√©rifie si une qu√™te peut √™tre lanc√©e
        // Elle doit : √ätre dans la bonne zone + Condition remplie + Pas d√©j√† active + Pas d√©j√† finie
        const checkAndStartStory = (questDef, conditionFn) => {
            if (zId >= questDef.triggerZone && conditionFn()) {
                const alreadyActive = this.quests.some(q => q.id === questDef.id);
                // Si tu as un historique des succ√®s, on v√©rifie aussi. Sinon on se base juste sur "active".
                // (Pour l'instant on suppose que si elle n'est pas active et qu'on a l'objet/condition, c'est bon,
                // sauf si c'est une qu√™te unique sans objet comme Rocket/Master).
                // Pour Rocket/Master, on v√©rifie si la r√©compense est d√©j√† acquise ou via un flag.
                
                // Pour simplifier ici : on lance si pas active.
                if (!alreadyActive) {
                    // S√©curit√© anti-spam pour les qu√™tes uniques d√©j√† finies (via les items uniques gagn√©s)
                    if (questDef.rewards.items) {
                        const uniqueItem = Object.keys(questDef.rewards.items)[0];
                        if (this.items[uniqueItem]) return false; // D√©j√† fait (on a l'objet)
                    }

                    this.addStoryQuest(questDef);
                    return true;
                }
            }
            return false;
        };

        let storyTriggered = false;

        // 1. Qu√™te Canne √† P√™che (Zone 7)
        if (!storyTriggered) {
            storyTriggered = checkAndStartStory(STORY_QUESTS.unlock_rod, () => !this.items['old_rod']);
        }

        // 2. Qu√™te Fusion - L√©o (Zone 4) - Se lance si on n'a pas encore beaucoup de doublons
        if (!storyTriggered) {
            // Condition : Toujours vrai si on est en zone 4+ et qu'on ne l'a pas faite
            storyTriggered = checkAndStartStory(STORY_QUESTS.science_fusion, () => true); 
        }

        // 3. Qu√™te Team Rocket (Zone 14)
        if (!storyTriggered) {
            // Condition : Pas l'objet 'leftovers' (Restes)
            storyTriggered = checkAndStartStory(STORY_QUESTS.rocket_threat, () => !this.items['leftovers']);
        }

        // 4. Qu√™te Surf (Zone 19)
        if (!storyTriggered) {
            storyTriggered = checkAndStartStory(STORY_QUESTS.unlock_surf, () => !this.items['surfboard']);
        }
        
        // 5. Qu√™te Ma√Ætre - Manoir (Zone 25)
        if (!storyTriggered) {
            // Condition : Pas l'objet 'masterball_token' ou 'masterball' (selon ton impl√©mentation)
            // On v√©rifie si on a d√©j√† une masterball OU si on a d√©j√† fait la qu√™te
            storyTriggered = checkAndStartStory(STORY_QUESTS.master_key, () => !this.items['masterball'] && this.items['masterball'] !== 0);
        }

        // Si une qu√™te d'histoire appara√Æt, on acc√©l√®re le timer pour qu'elle soit visible tout de suite
        if (storyTriggered && this.quests.length < 10) {
            logMessage("üìú √âV√âNEMENT : Une nouvelle qu√™te majeure est disponible !");
            this.nextQuestTimer = 1000; // 1s pour laisser le temps de lire le log voyage
            this.updateQuestTimerDisplay();
        }
    }


	/**
 * Retourne le HTML de l'ic√¥ne (Image si dispo, sinon Emoji)
 */
getItemIconHTML(item) {
    if (item.img) {
        return `<img src="${item.img}" class="item-sprite-img" alt="${item.name}">`;
    }
    // Fallback sur l'emoji si pas d'image
    return item.icon || 'üì¶';
}
claimAchievement(key) {
            const achievementState = this.achievements[key];
            const achievementDef = ACHIEVEMENTS[key];

            if (!achievementState || !achievementDef || !achievementState.completed || achievementState.claimed) {
                logMessage("‚ùå Impossible de r√©cup√©rer ce succ√®s !");
                return;
            }

            achievementState.claimed = true;
            
            const rewards = achievementDef.rewards;
            
            // Donner les r√©compenses
            if (rewards.pokedollars && rewards.pokedollars > 0) {
                this.pokedollars += rewards.pokedollars;
                logMessage(`üí∞ +${formatNumber(rewards.pokedollars)} Pok√©dollars (Succ√®s)`);
                this.checkSpecialQuests('pokedollars_gained');
                this.checkAchievements('totalPokedollarsEarned');
            }
            if (rewards.tokens && rewards.tokens > 0) {
                this.questTokens += rewards.tokens;
                logMessage(`üé´ +${rewards.tokens} Jetons (Succ√®s)`);
            }
            if (rewards.eggs) {
                Object.entries(rewards.eggs).forEach(([rarity, count]) => {
                    this.eggs[rarity] = (this.eggs[rarity] || 0) + count;
                    logMessage(`ü•ö +${count}x ≈íuf ${rarity} (Succ√®s)`);
                });
            }
            
            toast.success('R√©compense R√©cup√©r√©e !', achievementDef.title);
            this.updateAchievementsDisplay();
            this.updatePlayerStatsDisplay();
            this.updateEggsDisplay();
            this.updateShopDisplay();
        }

        /**
     * Filtre les succ√®s pour n'afficher que le prochain niveau pertinent
     * (Ex: Si Guerrier I est fini, on affiche Guerrier II)
     */
    getVisibleAchievements() {
        const visibleList = [];
        const families = {};

        // 1. Regrouper par famille (ex: "shinyHunter")
        // On suppose que les cl√©s sont format√©es comme "nomFamille_1"
        for (const [key, data] of Object.entries(ACHIEVEMENTS)) {
            const parts = key.split('_');
            // S√©curit√© : si la cl√© n'a pas de underscore, on prend la cl√© enti√®re comme famille
            const familyName = parts.length > 1 ? parts[0] : key; 
            
            if (!families[familyName]) families[familyName] = [];
            families[familyName].push({ key, ...data });
        }

        // 2. Trouver le prochain niveau pertinent pour chaque famille
        for (const familyName in families) {
            // Trier par difficult√© (target) pour avoir l'ordre 1 -> 2 -> 3
            const sorted = families[familyName].sort((a, b) => a.target - b.target);
            
            let active = null;

            for (const ach of sorted) {
                // Est-ce que ce succ√®s est d√©j√† valid√© ?
                const isCompleted = this.achievementsCompleted && this.achievementsCompleted[ach.key];

                if (!isCompleted) {
                    active = ach; // C'est le premier non fini, c'est celui qu'on affiche !
                    break; 
                }
            }

            // Cas sp√©cial : Si tous les succ√®s de la famille sont finis (ex: Guerrier I, II et III)
            // On affiche le dernier (le III) pour montrer fi√®rement qu'il est "COMPL√âT√â"
            if (!active && sorted.length > 0) {
                active = sorted[sorted.length - 1];
            }

            if (active) {
                visibleList.push(active);
            }
        }
        return visibleList;
    }

       // ‚úÖ CORRECTION DU NOM : updateAchievementsDisplay au lieu de updateAchievementsUI
    updateAchievementsDisplay() {
        const container = document.getElementById('achievementsContainer');
        const countEl = document.getElementById('achievementsCount'); 
        const totalEl = document.getElementById('achievementsTotal'); 

        if (!container) return;

        // 1. FILTRE INTELLIGENT (Slot unique)
        const visibleList = this.getVisibleAchievements(); 
        
        container.innerHTML = '';
        
        // Mise √† jour des compteurs
        if (countEl) countEl.textContent = Object.keys(this.achievementsCompleted || {}).length;
        if (totalEl) totalEl.textContent = Object.keys(ACHIEVEMENTS).length;

        if (visibleList.length === 0) {
            container.innerHTML = '<div class="empty-state">Aucun succ√®s visible.</div>';
            return;
        }

        visibleList.forEach(ach => {
            // 2. DONN√âES DEPUIS 'this.stats'
            const currentVal = this.stats[ach.trackingKey] || 0;
            const target = ach.target;
            
            let percent = Math.floor((currentVal / target) * 100);
            if (percent > 100) percent = 100;

            const isCompleted = this.achievementsCompleted && this.achievementsCompleted[ach.key];

            // 3. UI
            const card = document.createElement('div');
            card.className = `quest-card ${isCompleted ? 'completed' : ''}`;

            let rewardsHTML = '';
            if (ach.rewards) {
                if (ach.rewards.pokedollars) rewardsHTML += `<span class="quest-reward-item">üí∞ ${formatNumber(ach.rewards.pokedollars)}</span>`;
                if (ach.rewards.tokens) rewardsHTML += `<span class="quest-reward-item">üé´ ${ach.rewards.tokens}</span>`;
                if (ach.rewards.items) {
                    Object.entries(ach.rewards.items).forEach(([item, qty]) => {
                         rewardsHTML += `<span class="quest-reward-item">üéí ${qty}x ${item}</span>`;
                    });
                }
                if (ach.rewards.eggs) {
                    Object.entries(ach.rewards.eggs).forEach(([rarity, count]) => {
                        rewardsHTML += `<span class="quest-reward-item">ü•ö ${count}x ${rarity}</span>`;
                    });
                }
            }

            let progressText = isCompleted ? "COMPL√âT√â" : `${formatNumber(currentVal)} / ${formatNumber(target)}`;
            let progressBarColor = isCompleted ? '#4ade80' : '#fbbf24'; 

            card.innerHTML = `
                <div class="quest-header">
                    <div class="quest-title" style="color: ${isCompleted ? '#4ade80' : '#fbbf24'};">
                        ${isCompleted ? '‚úÖ' : 'üèÜ'} ${ach.title}
                    </div>
                </div>
                
                <div class="quest-description">${ach.desc}</div>
                
                <div class="quest-progress-container">
    <div class="quest-progress-bar">
        <div class="quest-progress-fill" style="width: ${percent}%; background-color: ${progressBarColor};">
        </div>
    </div>
    
    <div class="quest-progress-text">
        ${isCompleted ? 'COMPL√âT√â' : `${formatNumber(currentVal)} / ${formatNumber(target)}`}
    </div>
</div>
                
                <div class="quest-rewards">${rewardsHTML}</div>
            `;
            
            container.appendChild(card);
        });
    }
		
/**
 * Affiche les talents actifs (Version Stabilis√©e Anti-Clignotement).
 */
displayActiveTalents() {
    const talentsDiv = document.getElementById('activeTalentsDisplay');
    if (!talentsDiv) return;
    
    const talentCounts = {};
    this.playerTeam.forEach(c => {
        if (c.passiveTalent) {
            talentCounts[c.passiveTalent] = (talentCounts[c.passiveTalent] || 0) + 1;
        }
    });

    // 1. Gestion de l'affichage global
    if (Object.keys(talentCounts).length === 0) {
        talentsDiv.style.display = 'none';
        return;
    }
    talentsDiv.style.display = 'block';
    
    // 2. Initialisation de la structure (si pas encore faite)
    let grid = document.getElementById('talentGrid');
    if (!grid) {
        talentsDiv.innerHTML = `
            <div class="talents-header-title">‚ö° Talents d'√âquipe Actifs</div>
            <div class="talent-summary-grid" id="talentGrid"></div>
        `;
        grid = document.getElementById('talentGrid');
    }

    const activeIds = new Set();

    // 3. Mise √† jour intelligente (Diffing)
    Object.entries(talentCounts).forEach(([talentKey, count]) => {
        const talent = PASSIVE_TALENTS[talentKey];
        if (!talent) return;
        
        const chipId = `talent-chip-${talentKey}`;
        activeIds.add(chipId);
        
        // Calcul du bonus
        const bonus = this.getTalentStackBonus(talentKey);
        let bonusText = '';
        if (talentKey === 'mentor') bonusText = `+${(bonus * 100).toFixed(0)}% XP`;
        else if (talentKey === 'collecteur') bonusText = `+${(bonus * 100).toFixed(0)}% $`;
        else if (talentKey === 'maitre') bonusText = `+${(bonus * 100).toFixed(0)}% STAB`;
        else if (talentKey === 'catalyseur' || talentKey === 'catalyseur_supreme') bonusText = `+${(bonus * 100).toFixed(1)}% Statut`;
        else if (talentKey === 'aura') bonusText = `+${(bonus * 100).toFixed(0)}% Stats`;

        const rarityClass = talent.rarity === 'legendary' ? 'legendary' : 'epic';
        
        // Textes s√©curis√©s pour le tooltip
        const safeName = talent.name.replace(/'/g, "\\'");
        const safeDesc = `Cumul : x${count}\nEffet total : ${bonusText || 'Actif'}\n\n${talent.description}`.replace(/'/g, "\\'").replace(/\n/g, "<br>");

        // R√©cup√©ration de l'√©l√©ment existant
        let chip = document.getElementById(chipId);

        if (chip) {
            // CAS 1 : EXISTE D√âJ√Ä -> On met √† jour uniquement si le nombre change
            // (L'attribut data-count sert de m√©moire)
            if (chip.getAttribute('data-count') != count) {
                chip.setAttribute('data-count', count);
                chip.innerHTML = `
                    <strong>${talent.name}</strong>
                    <span style="font-size:9px; opacity:1;">x${count}</span>
                    ${bonusText ? `<span class="talent-bonus-text">${bonusText}</span>` : ''}
                `;
                // Mise √† jour du tooltip pour refl√©ter le nouveau bonus
                chip.setAttribute('onmouseenter', `game.scheduleTooltip(event, '${safeName}', '${safeDesc}')`);
            }
        } else {
            // CAS 2 : NOUVEAU -> Cr√©ation
            chip = document.createElement('div');
            chip.id = chipId;
            chip.className = `talent-chip ${rarityClass}`;
            chip.setAttribute('data-count', count);
            
            // √âv√©nements de souris
            chip.setAttribute('onmouseenter', `game.scheduleTooltip(event, '${safeName}', '${safeDesc}')`);
            chip.setAttribute('onmouseleave', `game.hideTooltip()`);
            
            chip.innerHTML = `
                <strong>${talent.name}</strong>
                <span style="font-size:9px; opacity:1;">x${count}</span>
                ${bonusText ? `<span class="talent-bonus-text">${bonusText}</span>` : ''}
            `;
            
            grid.appendChild(chip);
        }
    });
    
    // 4. Nettoyage (Supprimer les talents qui ne sont plus actifs)
    Array.from(grid.children).forEach(child => {
        if (!activeIds.has(child.id)) {
            child.remove();
        }
    });
}
applyAccountTalents() {
    // Les talents sont appliqu√©s via getAccountTalentBonus() dans les calculs
    this.calculateTeamStats();
    this.updateDisplay();
}

playerCreatureFainted() {
        // 1. Talent Phoenix (Chance de survie)
        const hasPhoenix = this.currentPlayerCreature.passiveTalent === 'phoenix';
        // En ar√®ne, on v√©rifie currentHp, sinon mainAccountCurrentHp
        const hpToCheck = this.arenaState.active ? this.currentPlayerCreature.currentHp : this.currentPlayerCreature.mainAccountCurrentHp;
        
        if (hasPhoenix && Math.random() < 0.25) {
            const restoredHp = Math.floor(this.getPlayerMaxHp() * 0.5);
            
            if (this.arenaState.active) {
                this.currentPlayerCreature.currentHp = Math.floor(this.currentPlayerCreature.maxHp * 0.5);
            } else {
                this.currentPlayerCreature.mainAccountCurrentHp = restoredHp;
            }
            
            logMessage("üî• PHOENIX ! " + this.currentPlayerCreature.name + " rena√Æt de ses cendres !");
            this.updateCombatDisplay();
            return;
        }

        // 2. Marquer le Pok√©mon actuel comme KO
        logMessage(this.currentPlayerCreature.name + " est KO !");
		this.currentPlayerCreature.berserkStacks = 0;
        this.faintedThisCombat.add(this.currentPlayerCreature.name);
        
        // On s'assure qu'il est bien √† 0 pour l'affichage
        if (this.arenaState.active) {
            this.currentPlayerCreature.currentHp = 0;
        }

        // 3. CHERCHER LA REL√àVE (Le Pok√©mon vivant suivant)
        let nextCreature = null;
        let nextIndex = -1;

        // On parcourt l'√©quipe pour trouver quelqu'un de vivant qui n'est pas d√©j√† tomb√©
        for (let i = 0; i < this.playerTeam.length; i++) {
            // On ne se choisit pas soi-m√™me
            if (i === this.activeCreatureIndex) continue;
            
            const candidate = this.playerTeam[i];
            
            // Est-il vivant ? (En ar√®ne on regarde ses PV perso, en Normal on regarde s'il n'est pas dans la liste des KO)
            // Note : En mode Normal, si un meurt, le compte est mort, donc on ne switch g√©n√©ralement pas sauf si on a une m√©canique de "vies".
            // Ici on se concentre sur le fix Ar√®ne.
            if (candidate.currentHp > 0 && !this.faintedThisCombat.has(candidate.name)) {
                nextCreature = candidate;
                nextIndex = i;
                break; // On a trouv√© le rempla√ßant !
            }
        }

        // 4. CAS A : PLUS PERSONNE (D√âFAITE TOTALE)
        if (!nextCreature) {
            if (this.towerState.isActive) {
                this.endTowerRun();
                return;
            }
            
            if (this.arenaState.active) {
                this.loseArena("Toute votre √©quipe a √©t√© vaincue !");
                return;
            }
            
            // Mode Normal (Zone)
            this.stats.combatsLost++;
            this.checkSpecialQuests('combat_lost');
            this.combatState = 'dead';
            this.lastCombatTime = Date.now();
            toast.error('D√©faite', 'Toute votre √©quipe est KO !', 2000);
            logMessage("√âquipe hors de combat ! R√©cup√©ration...");
            
            this.updateTeamDisplay();
            this.updateCombatDisplay();
            return;
        }

        // 5. CAS B : REMPLACEMENT (REL√àVE)
        this.currentPlayerCreature = nextCreature;
        this.activeCreatureIndex = nextIndex;
        this.currentPlayerCreature.recalculateStats();
        // R√©initialisation pour le nouveau combattant
        this.currentPlayerCreature.actionGauge = 0; // ATB √† 0
        this.currentPlayerCreature.ultimateCharge = 0; // Ultime √† 0 (ou on garde la charge ? √† toi de voir, ici 0 c'est plus √©quilibr√©)
        this.currentPlayerCreature.ultimateActive = false;

        // Si on est en mode Normal, on remet les PV du compte (au cas o√π)
        if (!this.arenaState.active) {
            this.currentPlayerCreature.mainAccountCurrentHp = this.getPlayerMaxHp();
        } 
        // Si on est en Ar√®ne, il a d√©j√† ses PV individuels (currentHp) car on les a soign√©s au d√©but

        logMessage(`Go ! ${nextCreature.name} prend le relais !`);
        
        // Petit d√©lai visuel ou encha√Ænement imm√©diat
        this.updateCombatDisplay();
        this.updateTeamDisplay();
    }
getFirstAliveCreature() {
    return this.playerTeam.find(creature => creature.isAlive()) || null;
}

// LOGIQUE CENTRALIS√âE : V√©rifie si une zone est termin√©e √† 100%
    isZoneMastered(zoneId) {
        const zone = ZONES[zoneId];
        if (!zone) return false;
        
        const progress = this.zoneProgress[zoneId];
        if (!progress) return false;

        // 1. Boss & Epics
        if (zone.requiredBosses > 0 && (progress.bossesDefeated || 0) < zone.requiredBosses) return false;
        if (zone.requiredEpics > 0 && (progress.epicsDefeated || 0) < zone.requiredEpics) return false;

        // 2. Tiers des Pok√©mon (Utilise le filtre Canne √† p√™che !)
        const pokemonInZone = this.getReachablePokemonInZone(zoneId);
        const tiers = progress.pokemonTiers || {};
        const maxTier = zone.maxTier || 50;

        return pokemonInZone.every(name => (tiers[name] || 0) >= maxTier);
    }
	
// S√âCURIT√â : V√©rification d√©blocage Zone (Avec syst√®me de Cliquet)
    isZoneUnlocked(zoneId, checkPrevious = true) {
        // Zone 1 toujours ouverte
        if (zoneId === 1) return true;

        // ‚úÖ R√àGLE D'OR : Si on a d√©j√† atteint cette zone (ou une plus loin), c'est ouvert.
        // Peu importe si la zone pr√©c√©dente est repass√©e √† 80%.
        if (zoneId <= maxReachedZone) return true;

        // Sinon, on applique la r√®gle stricte de ma√Ætrise pour progresser
        if (checkPrevious) {
            const prevZoneId = zoneId - 1;
            if (!this.isZoneUnlocked(prevZoneId, false)) return false;
            if (!this.isZoneMastered(prevZoneId)) return false;
        }

        return true;
    }
// UI : Mise √† jour du s√©lecteur (Version Respect du Focus)
    updateZoneSelector() {
        const selector = document.getElementById('zoneSelect');
        if (!selector) return;
        
        const zoneIds = Object.keys(ZONES);
        
        // 1. Reconstruction structurelle (Seulement si n√©cessaire)
        // On ne le fait qu'au d√©marrage ou si le nombre de zones change
        if (selector.options.length !== zoneIds.length) {
            selector.innerHTML = '';
            zoneIds.forEach(zoneId => {
                const zId = parseInt(zoneId);
                const option = document.createElement('option');
                option.value = zId;
                selector.appendChild(option);
            });
        }

        // 2. Mise √† jour des Textes et √âtats (Cadenas, Gris√©...)
        // On peut faire √ßa m√™me si le joueur a le menu ouvert, √ßa ne g√™ne pas
        Array.from(selector.options).forEach(option => {
            const zId = parseInt(option.value);
            const zone = ZONES[zId];
            const isUnlocked = this.isZoneUnlocked(zId);
            
            let label = zone.name;
            if (!isUnlocked) label = `${label}`;
            
            // Dirty Checking (Optimisation GPU)
            if (option.text !== label) option.text = label;
            if (option.disabled !== !isUnlocked) option.disabled = !isUnlocked;
        });

        // 3. ‚úÖ LE FIX CRITIQUE : Gestion de la S√©lection
        // On ne force la valeur que si le joueur N'EST PAS en train d'utiliser le menu.
        if (document.activeElement !== selector) {
            // On convertit en entier pour comparer proprement
            if (parseInt(selector.value) !== currentZone) {
                selector.value = currentZone;
            }
        }
    }
            

           // CORRECTION : Ajout du bonus de Badge Wisdom (+10% XP)
    getExpMultiplier() {
        let multiplier = 1 + (this.upgrades.expBoost.level * 0.1); // Am√©liorations (Shop)
        
        // Boosts temporaires (Potions)
        multiplier += this.getActiveBoostMultiplier('xp');
        
        // Boosts permanents (Tour)
        if (this.permanentBoosts && this.permanentBoosts.xp) {
            multiplier += this.permanentBoosts.xp;
        }

        // ‚úÖ FIX : Ajout du Badge d'Ar√®ne (Wisdom)
        multiplier += this.getAccountTalentBonus('exp_mult');
        
        // Synergies d'√©quipe
        const synergies = this.getActiveSynergies();
        if (synergies.exp_mult > 1) {
            multiplier += (synergies.exp_mult - 1);
        }
        
        return multiplier;
    }
		
getTeamAverageRarity() {
    if (this.playerTeam.length === 0) return 0;
    const total = this.playerTeam.reduce((sum, c) => sum + this.getRarityValue(c.rarity), 0);
    return total / this.playerTeam.length;
}

getRarityValue(rarity) {
    const values = {
        [RARITY.COMMON]: 1,
        [RARITY.RARE]: 2,
        [RARITY.EPIC]: 3,
        [RARITY.LEGENDARY]: 4
    };
    return values[rarity] || 1;
}
		
			// Dans la classe Game
getStatusProcBonus() {
    let totalBonus = 0;
    
    // Catalyseur normal
    const catalyseurBonus = this.getTalentStackBonus('catalyseur');
    totalBonus += catalyseurBonus;
    
    // Catalyseur Supr√™me
    const catalyseurSupremeBonus = this.getTalentStackBonus('catalyseur_supreme');
    totalBonus += catalyseurSupremeBonus;
    
    return totalBonus;
}

            getEggDropBonus() {
    let bonus = this.upgrades.eggDrop.level * 0.002;
    
    // Ajouter les boosts temporaires
    bonus += this.getActiveBoostMultiplier('eggDrop');
    
    return bonus;
}

            getStaminaRegenTime() {
                const baseTime = 10000;
                const reduction = this.upgrades.staminaRegen.level * 200;
                return Math.max(1000, baseTime - reduction);
            }

            // CORRECTION : Ajout du bonus de Badge Prestige (+10% Chance Shard)
    getShardBonusChance() {
        let chance = this.upgrades.shardBonus.level * 0.02; // Am√©lioration (Shop)
        
        // ‚úÖ FIX : Ajout du Badge d'Ar√®ne (Prestige)
        chance += this.getAccountTalentBonus('shard_chance'); 
        
        return chance;
    }

            // Calcul du co√ªt du prestige (Prestige + 1)
    getPrestigeCost(currentPrestige) {
        // Si aucun argument n'est pass√© (ex: pour l'affichage boutique), on renvoie 1 par d√©faut
        if (currentPrestige === undefined || currentPrestige === null) return 1;
        
        // Formule demand√©e : Prestige 0 (veut passer 1) = 1 Shard
        // Prestige 5 (veut passer 6) = 6 Shards
        let cost = currentPrestige + 1;
        
        // Note : L'am√©lioration "Ma√Ætre du Prestige" (r√©duction de co√ªt) est d√©sactiv√©e
        // avec cette formule pour √©viter les co√ªts n√©gatifs ou nuls.
        
        return Math.max(1, cost);
    }
    

            // CORRECTION : Ajout du bonus de badge (+2 slots Parmanie) au calcul
    getPensionSlots() {
        // 1. Slots achet√©s (Am√©liorations)
        const upgradeSlots = this.upgrades.pension.level;
        
        // 2. Slots permanents (Tour de combat)
        const towerSlots = this.permanentBoosts.pensionSlots || 0;
        
        // 3. ‚úÖ FIX : Slots du Badge Parmanie
        const badgeSlots = this.getAccountTalentBonus('pension_slots');

        return upgradeSlots + towerSlots + badgeSlots;
    }

            getPensionTransferRate() {
                return this.upgrades.pension.level * 0.01;
            }

            getUpgradeCost(upgradeKey) {
                const upgrade = this.upgrades[upgradeKey];
                if (!upgrade) return 0;
                return Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, upgrade.level));
            }

            canAffordUpgrade(upgradeKey) {
                const cost = this.getUpgradeCost(upgradeKey);
                return this.pokedollars >= cost;
            }

            buyUpgrade(upgradeKey) {
                const upgrade = this.upgrades[upgradeKey];
                if (!upgrade) return false;
                
                if (upgrade.level >= upgrade.maxLevel) {
                    logMessage("Cette amelioration est deja au niveau maximum !");
                    return false;
                }
                
                const cost = this.getUpgradeCost(upgradeKey);
                if (!this.canAffordUpgrade(upgradeKey)) {
                    logMessage("Pas assez de Pokedollars ! (" + this.pokedollars + "/" + cost + ")");
                    return false;
                }
                
                this.pokedollars -= cost;
                this.stats.upgradesPurchased = (this.stats.upgradesPurchased || 0) + 1;
				this.checkAchievements('upgradesPurchased');
				
				this.checkSpecialQuests('money_spent');
                upgrade.level++;
                
                logMessage("Amelioration achetee : " + upgrade.name + " niveau " + upgrade.level + " !");
                
                this.updateUpgradesDisplay();
                this.updatePlayerStatsDisplay();
                this.updateTeamDisplay();
                this.updateStorageDisplay();
                this.updatePensionDisplay();
				
				
                
                return true;
            }
			
			
	updateSynergyDisplay() {
    const btn = document.getElementById('synergyBtn');
    if (!btn) return;

    // 1. Compter les types
    const typeCounts = {};
    this.playerTeam.forEach(c => {
        if (c.isAlive()) { // Seuls les vivants comptent pour l'activation
            typeCounts[c.type] = (typeCounts[c.type] || 0) + 1;
            if (c.secondaryType) typeCounts[c.secondaryType] = (typeCounts[c.secondaryType] || 0) + 1;
        }
    });

    // 2. V√©rifier si AU MOINS UNE synergie est active
    let hasActiveSynergy = false;

    // On utilise some() pour s'arr√™ter d√®s qu'on en trouve une
    hasActiveSynergy = Object.values(TEAM_SYNERGIES).some(synergy => {
        if (synergy.all_required) {
            // Mode ET (Combinaison)
            return synergy.types.every(type => (typeCounts[type] || 0) >= synergy.min_count);
        } else {
            // Mode OU (Classique)
            return synergy.types.some(type => (typeCounts[type] || 0) >= synergy.min_count);
        }
    });

    // 3. Mettre √† jour le style du bouton
    
    const iconHtml = `<img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/key-stone.png" class="icon-img" style="width:20px; height:20px; margin-right:5px; vertical-align:text-bottom;">`;
    if (hasActiveSynergy) {
        // ACTIF
        btn.style.background = "linear-gradient(135deg, #22c55e, #16a34a)";
        btn.style.boxShadow = "0 0 10px rgba(34, 197, 94, 0.6)";
        btn.style.borderColor = "#86efac";
        btn.innerHTML = `${iconHtml} Synergies (ACTIF)`; // ‚úÖ Avec l'image
        btn.classList.add("pulse-animation");
    } else {
        // INACTIF
        btn.style.background = "#8b5cf6";
        btn.style.boxShadow = "none";
        btn.style.borderColor = "transparent";
        btn.innerHTML = `${iconHtml} Synergies`; // ‚úÖ Avec l'image
        btn.classList.remove("pulse-animation");
    }
}	
	
updateArenasDisplay() {
    const arenasContainer = document.getElementById('arenasContainer');
    const badgesList = document.getElementById('badgesList');
    
    if (!arenasContainer || !badgesList) return;
    
    // Afficher les badges obtenus
    badgesList.innerHTML = '';
    let badgesObtained = 0;
    
    Object.entries(ACCOUNT_TALENTS).forEach(([talentKey, talent]) => {
        if (this.hasBadge(talentKey)) {
            badgesObtained++;
            const badgeCard = document.createElement('div');
            badgeCard.style.cssText = 'padding: 10px; background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; border-radius: 8px;';
            badgeCard.innerHTML = `
                <div style="font-weight: bold; color: #22c55e; margin-bottom: 5px;">‚úì ${talent.name}</div>
                <div style="font-size: 12px; color: #666;">${talent.description}</div>
            `;
            badgesList.appendChild(badgeCard);
        }
    });
    
    if (badgesObtained === 0) {
        badgesList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Aucun badge obtenu. Compl√©tez des ar√®nes pour d√©bloquer des talents !</div>';
    }
    
    // Afficher les ar√®nes
    arenasContainer.innerHTML = '';
    
    Object.entries(ARENAS).forEach(([arenaId, arena]) => {
        const unlocked = this.isArenaUnlocked(arenaId);
        const completed = this.hasBadge(arena.badge);
        const talent = ACCOUNT_TALENTS[arena.badge];
        
        const arenaCard = document.createElement('div');
        arenaCard.className = 'upgrade-card';
        
        if (completed) {
            arenaCard.style.background = 'linear-gradient(135deg, #d4edda 0%, #a3d4a8 100%)';
            arenaCard.style.border = '2px solid #22c55e';
        } else if (!unlocked) {
            arenaCard.style.opacity = '0.6';
        }
        
        const requiredZone = ZONES[arena.requiredZone];
        const requiredZoneName = requiredZone ? requiredZone.name : "Zone " + arena.requiredZone;
        
        arenaCard.innerHTML = `
            <div class="upgrade-title">${arena.name}</div>
            <div class="upgrade-description">
                <strong>Champion:</strong> ${arena.championName}<br>
                <strong>Type:</strong> ${arena.type}<br>
                <strong>Niveau:</strong> ${arena.teamLevel}<br>
                <strong>√âquipe:</strong> 6 Pok√©mon<br>
                <strong>Temps limite:</strong> 90 secondes
            </div>
            <div style="margin: 15px 0; padding: 10px; background: rgba(255, 215, 0, 0.2); border-radius: 8px; border-left: 4px solid #ffd700;">
                <div style="font-weight: bold; color: #d97706; margin-bottom: 5px;">R√©compense: ${talent.name}</div>
                <div style="font-size: 12px; color: #666;">${talent.description}</div>
            </div>
            <div style="font-size: 12px; color: #666; margin-bottom: 15px;">
                ${unlocked ? '‚úì D√©bloqu√©e' : 'üîí Requiert: ' + requiredZoneName + ' compl√®te'}
            </div>
            <button class="upgrade-btn" 
                    onclick="game.startArena(${arenaId})" 
                    ${!unlocked || completed ? 'disabled' : ''}>
                ${completed ? '‚úì BADGE OBTENU' : (unlocked ? 'COMBATTRE' : 'VERROUILL√â')}
            </button>
        `;
        
        arenasContainer.appendChild(arenaCard);
    });
}
            updateUpgradesDisplay() {
                const upgradesContainer = document.getElementById('upgradesContainer');
                upgradesContainer.innerHTML = '';
                
                Object.entries(this.upgrades).forEach(([key, upgrade]) => {
                    const upgradeCard = document.createElement('div');
                    upgradeCard.className = 'upgrade-card';
                    
                    const cost = this.getUpgradeCost(key);
                    const canAfford = this.canAffordUpgrade(key);
                    const isMaxLevel = upgrade.level >= upgrade.maxLevel;
                    
                    let currentEffect = "";
                    switch(key) {
                        case 'critMastery': 
								const critPercent = (upgrade.level * 1).toFixed(0);
								currentEffect = "Bonus actuel: +" + critPercent + "%";
								break;
                        case 'expBoost':
                            const expMultiplier = (this.getExpMultiplier() * 100).toFixed(0);
                            currentEffect = "Multiplicateur: x" + (expMultiplier / 100).toFixed(1);
                            break;
                        case 'eggDrop':
                            const dropBonus = (this.getEggDropBonus() * 100).toFixed(0);
                            currentEffect = "Bonus: +" + dropBonus + "%";
                            break;
                        case 'staminaRegen':
                            const regenTime = (this.getStaminaRegenTime() / 1000).toFixed(1);
                            currentEffect = "Temps: " + regenTime + "s";
                            break;
                        case 'shardBonus':
                            const shardChance = (this.getShardBonusChance() * 100).toFixed(0);
                            currentEffect = "Chance: " + shardChance + "%";
                            break;
                        case 'pension':
                            const slots = this.getPensionSlots();
                            const rate = (this.getPensionTransferRate() * 100).toFixed(0);
                            currentEffect = "Slots: " + slots + " | Transfert: " + rate + "%";
                            break;
                            case 'respawn':
                const delayReduc = upgrade.level * 50;
                currentEffect = `D√©lai r√©duit: -${delayReduc}ms`;
                break;
                case 'recycle':
                const recyclePct = (upgrade.level * 2.5).toFixed(0);
                currentEffect = "Chance d'√©conomie: " + recyclePct + "%";
                break;
                    }
                    
                    upgradeCard.innerHTML = `
                        <div class="upgrade-title">${upgrade.name}</div>
                        <div class="upgrade-description">${upgrade.description}</div>
                        <div class="upgrade-stats">
                            <div class="upgrade-level">Niveau: ${upgrade.level}/${upgrade.maxLevel}</div>
                            <div class="upgrade-effect">${upgrade.effect}</div>
                        </div>
                        ${currentEffect ? `<div style="font-size: 12px; color: #666; margin-bottom: 10px;">${currentEffect}</div>` : ''}
                        <div class="upgrade-cost" style="margin-bottom: 15px;">
                            ${isMaxLevel ? 'NIVEAU MAX' : cost + ' Pokedollars'}
                        </div>
                        <button class="upgrade-btn" 
                                onclick="game.buyUpgrade('${key}')" 
                                ${!canAfford || isMaxLevel ? 'disabled' : ''}>
                            ${isMaxLevel ? 'NIVEAU MAX' : (canAfford ? 'ACHETER' : 'PAS ASSEZ DE FONDS')}
                        </button>
                    `;
                    
                    upgradesContainer.appendChild(upgradeCard);
                });
            }

            determineEggRarity() {
                const roll = Math.random() * 100;
                let cumulative = 0;
                
                for (const [rarity, chance] of Object.entries(RARITY_CHANCES)) {
                    cumulative += chance;
                    if (roll <= cumulative) {
                        return rarity;
                    }
                }
                return RARITY.COMMON;
            }

            addEgg(rarity) {
                this.eggs[rarity]++;
                logMessage("Oeuf " + rarity + " obtenu !");
            }

          


// OPTIMISATION : Ouverture d'≈ìuf nettoy√©e avec Fusion Centralis√©e
    openEgg(rarity) {
        if (this.eggs[rarity] <= 0) {
            logMessage("Aucun oeuf de cette raret√© disponible !");
            return;
        }
        
        // 1. Mise √† jour des stats et qu√™tes d'ouverture
        this.eggs[rarity]--;
        this.stats.eggsOpened++;
        this.checkSpecialQuests('eggsOpened');
        
        logMessage("Ouverture d'un oeuf " + rarity + "...");
        
        // 2. G√©n√©ration de la cr√©ature
        const egg = new Egg(rarity);
        const creature = egg.open();
        
        // 3. Gestion Pok√©dex
        const pokedexKey = creature.name + "_" + creature.type + "_" + creature.rarity;
        if (!this.pokedex[pokedexKey]) {
            this.pokedex[pokedexKey] = { 
                discovered: true, 
                count: 1, 
                shinyCount: creature.isShiny ? 1 : 0, 
                hasShiny: creature.isShiny,
                name: creature.name, 
                type: creature.type, 
                rarity: creature.rarity, 
                firstDiscoveredAt: Date.now()
            };
            logMessage("NOUVEAU ! " + creature.name + (creature.isShiny ? " ‚ú®SHINY‚ú®" : "") + " ajout√© au Pokedex !");
            this.checkSpecialQuests('new_discovery');
        } else {
            this.pokedex[pokedexKey].count++;
            if (creature.isShiny && !this.pokedex[pokedexKey].hasShiny) {
                this.pokedex[pokedexKey].hasShiny = true;
            }
        }

        // 4. Gestion Shiny & L√©gendaire (Feedback)
        if (creature.isShiny) {
            this.stats.shiniesObtained++;
            this.checkSpecialQuests('shiniesObtained');
            toast.shiny('‚ú® SHINY OBTENU !', `${creature.name} brille de mille feux !`);
        }
        
        if (creature.rarity === RARITY.LEGENDARY) {
            this.checkSpecialQuests('legendary_obtained');
            if (!creature.isShiny) {
                toast.legendary('üëë L√âGENDAIRE !', `${creature.name} rejoint votre collection !`);
            }
        }

        // 5. Recherche de doublon (Fusion)
        const existingCreature = this.findCreatureByName(creature.name, creature.isShiny);

        if (existingCreature) {
            // ‚úÖ APPEL DE LA FUSION CENTRALIS√âE
            const result = this.processFusion(creature, existingCreature);
            
            let msg = `‚ôªÔ∏è DOUBLON : ${creature.name} recycl√© en ${result.shards} Shards.`;
            if (result.improved) msg += " IVs Am√©lior√©s !";
            if (result.becameShiny) msg += " ‚ú® DEVIENT SHINY !"; // Cas rare fusion Normal->Shiny
            
            logMessage(msg);
            
            // Toast de feedback
            if (result.improved) {
                toast.success("Fusion R√©ussie !", `${existingCreature.name} est plus fort ! (+${result.shards} Shards)`);
            } else {
                // Optionnel : Toast discret pour le farm
                // toast.info("Doublon", `+${result.shards} Shards`); 
            }
            
            // La 'creature' temporaire est abandonn√©e au Garbage Collector ici
            
        } else {
            // CE N'EST PAS UN DOUBLON -> Ajout √† l'√©quipe/stockage
            this.stats.creaturesObtained++;
            this.checkSpecialQuests('creature_obtained', { 
                creatureType: creature.type,
                secondaryType: creature.secondaryType 
            });
            
            const maxTeamSize = 6 + this.getAccountTalentBonus('team_slot');
            if (this.playerTeam.length < maxTeamSize) {
                this.playerTeam.push(creature);
            } else {
                this.storage.push(creature);
            }
        }
        
        // 6. Affichage final
        this.showEggHatchModal(creature, rarity);
    }

// --- GESTION DU POK√âMART (√âPICERIE) ---

    updatePokeMartDisplay() {
    const container = document.getElementById('martContainer');
    const moneyDisplay = document.getElementById('martMoney');
    
    if (!container || !moneyDisplay) return;
    
    moneyDisplay.textContent = formatNumber(this.pokedollars);
    container.innerHTML = '';

    Object.entries(POKEMART_ITEMS).forEach(([key, shopEntry]) => {
        const card = document.createElement('div');
        card.className = 'shop-item';
        
        // 1. R√©cup√©rer les donn√©es r√©elles de l'objet (pour avoir l'image)
        // shopEntry.itemId contient la cl√© (ex: 'pokeball')
        const realItem = ALL_ITEMS[shopEntry.itemId];
        
        // 2. G√©n√©rer l'ic√¥ne
        // Si on trouve l'item r√©el on l'utilise, sinon on utilise l'entr√©e du shop par d√©faut
        const iconHTML = this.getItemIconHTML(realItem || shopEntry);

        const canAfford = this.pokedollars >= shopEntry.cost;
        
        card.innerHTML = `
            <div class="shop-item-name" style="display:flex; align-items:center; gap:10px;">
                ${iconHTML} 
                <span>${shopEntry.name}</span>
            </div>
            <div class="shop-item-description">${shopEntry.description}</div>
            <div class="shop-item-cost" style="color: #333;">üí∞ ${formatNumber(shopEntry.cost)}</div>
            <button class="shop-buy-btn" 
                    style="background: ${canAfford ? 'linear-gradient(135deg, #2196f3, #1976d2)' : '#ccc'};"
                    onclick="game.buyPokeMartItem('${key}')" 
                    ${!canAfford ? 'disabled' : ''}>
                ${canAfford ? 'Acheter' : 'Pas assez d\'argent'}
            </button>
        `;
        container.appendChild(card);
    });
}

    buyPokeMartItem(key) {
        const item = POKEMART_ITEMS[key];
        if (!item) return;

        if (this.pokedollars < item.cost) {
            logMessage("Pas assez de Pok√©dollars !");
            return;
        }

        // Transaction
        this.pokedollars -= item.cost;
        this.checkSpecialQuests('money_spent'); // Important pour les qu√™tes "√âconome" ou "D√©pensier"
        
        // Ajout de l'objet
        this.addItem(item.itemId, item.amount);
        
        // Feedback
        logMessage(`Achat : ${item.amount}x ${item.name} pour ${item.cost}$`);
        
        // Mise √† jour des affichages
        this.updatePokeMartDisplay();
        this.updatePlayerStatsDisplay(); // Pour mettre √† jour l'argent dans le header
        this.updateItemsDisplay(); // Pour le sac √† dos
    }
	
showEggHatchModal(creature, rarity) {
    const modal = document.getElementById('eggHatchModal');
    const content = document.getElementById('eggHatchContent');
    if (!modal || !content) return;

    // 1. Appliquer les classes de "flash"
    content.className = "quest-completion-content"; // R√©initialiser
    if (creature.isShiny) {
        content.classList.add('shiny');
    } else if (creature.rarity === RARITY.LEGENDARY) {
        content.classList.add('legendary');
    }

    // 2. Construire le HTML du modal
    let title = "Un ≈íuf √©clot !";
    if (creature.isShiny) title = "‚ú® SHINY OBTENU ! ‚ú®";
    else if (creature.rarity === RARITY.LEGENDARY) title = "üëë L√âGENDAIRE OBTENU ! üëë";

    const spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, false);

    let talentHTML = '';
    if (creature.passiveTalent) {
        const talent = creature.getTalentInfo();
        talentHTML = `<div style="font-size: 14px; margin-top: 5px;"><strong>Talent:</strong> ${talent.name}</div>`;
    }

    let ultimateHTML = '';
    if (creature.ultimateAbility) {
        ultimateHTML = `<div style="font-size: 14px; margin-top: 5px;"><strong>Ultime:</strong> ${creature.ultimateAbility.name}</div>`;
    }

    content.innerHTML = `
        <div class="egg-hatch-title">${title}</div>
        <img src="${spriteUrl}" alt="${creature.name}" class="egg-hatch-sprite">
        <h3 style="font-size: 20px;">${creature.name}</h3>
        <div>
            <span class="type-badge type-${creature.type}">${creature.type}</span>
            ${creature.secondaryType ? `<span class="type-badge type-${creature.secondaryType}">${creature.secondaryType}</span>` : ''}
        </div>

        <div class="egg-hatch-stats">
            <div class="creature-stats">
                <strong>Stats de base :</strong><br>
                ‚öîÔ∏è ${creature.attack} | üõ°Ô∏è ${creature.defense} | üëü ${creature.speed} | ‚ù§Ô∏è ${creature.maxHp}
                <br>
                <span style='color:#007bff; font-weight:bold;'>üß¨ IVs: ${creature.ivHP} / ${creature.ivAttack} / ${creature.ivDefense} / ${creature.ivSpeed}</span>
                ${talentHTML}
                ${ultimateHTML}
            </div>
        </div>

        <button class="btn btn-save" onclick="game.closeEggHatchModal()">Super !</button>
    `;

    // 3. Afficher le modal
    modal.classList.add('show');
}

closeEggHatchModal() {
    const modal = document.getElementById('eggHatchModal');
    if (modal) {
        modal.classList.remove('show');
    }
    // C'est SEULEMENT ICI qu'on rafra√Æchit l'interface principale
    this.updateDisplay();
}

// ‚úÖ REMPLACEZ VOTRE FONCTION showCreatureModal PAR CELLE-CI


// UI : Affiche la liste des objets √©quipables
    showItemSelectModal(creatureIndex, location) {
        // 1. Nettoyage pr√©ventif
        const existingOverlay = document.getElementById('itemSelectOverlay');
        if (existingOverlay) existingOverlay.remove();

        // 2. Cr√©ation du Modal √† la vol√©e (Pas besoin de polluer index.html)
        const modal = document.createElement('div');
        modal.id = 'itemSelectOverlay';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); z-index: 10001; 
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(4px);
        `;
        
        // Fermeture au clic sur le fond
        modal.onclick = (e) => {
            if (e.target === modal) modal.remove();
        };

        let listHTML = '';
        let hasItems = false;

        // 3. G√©n√©ration de la liste des objets
        Object.keys(this.items).forEach(itemKey => {
            // On v√©rifie si on en a en stock ET si c'est bien un objet "Tenu" (d√©fini dans HELD_ITEMS)
            if (this.items[itemKey] > 0 && typeof HELD_ITEMS !== 'undefined' && HELD_ITEMS[itemKey]) { 
                hasItems = true;
                const itemDef = HELD_ITEMS[itemKey];
                
                // Ic√¥ne (Image ou Emoji)
                let iconDisplay = itemDef.icon || 'üéí';
                if (itemDef.img) {
                    iconDisplay = `<img src="${itemDef.img}" style="width:32px; height:32px; vertical-align:middle;">`;
                }
                
                listHTML += `
                    <div class="item-select-card" 
                         style="background: white; border: 1px solid #e2e8f0; border-radius: 10px; padding: 10px; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: all 0.2s;"
                         onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#3b82f6';"
                         onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#e2e8f0';"
                         onclick="game.equipItem('${itemKey}', ${creatureIndex}, '${location}'); document.getElementById('itemSelectOverlay').remove();">
                        
                        <div style="font-size: 24px;">${iconDisplay}</div>
                        
                        <div style="flex: 1; text-align: left;">
                            <div style="font-weight: bold; color: #333;">${itemDef.name} <span style="font-size: 10px; background: #e0f2fe; color: #0284c7; padding: 2px 6px; border-radius: 10px;">x${this.items[itemKey]}</span></div>
                            <div style="font-size: 11px; color: #666;">${itemDef.description}</div>
                        </div>
                        
                        <div style="font-weight: bold; color: #22c55e; font-size: 12px;">√âQUIPER</div>
                    </div>
                `;
            }
        });

        if (!hasItems) {
            listHTML = `
                <div style="text-align: center; padding: 30px; color: #64748b; background: #f8fafc; border-radius: 10px; border: 2px dashed #cbd5e1;">
                    <div style="font-size: 32px; margin-bottom: 10px;">üéí</div>
                    <div>Aucun objet √©quipable disponible.</div>
                    <div style="font-size: 11px; margin-top: 5px;">Trouvez des objets en Exp√©dition ou dans la Tour !</div>
                </div>
            `;
        }

        const content = `
            <div style="background: white; padding: 20px; border-radius: 15px; max-width: 450px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                    <h3 style="margin: 0; color: #333;">Choisir un Objet</h3>
                    <button onclick="document.getElementById('itemSelectOverlay').remove()" style="background: #ef4444; color: white; border: none; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-weight: bold;">√ó</button>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    ${listHTML}
                </div>
            </div>
        `;
        
        modal.innerHTML = content;
        document.body.appendChild(modal);
    }

    // LOGIQUE : √âquiper l'objet
    equipItem(itemKey, creatureIndex, location) {
        let creature;
        if (location === 'team') creature = this.playerTeam[creatureIndex];
        else if (location === 'storage') creature = this.storage[creatureIndex];
        else if (location === 'pension') creature = this.pension[creatureIndex];

        if (!creature) return;

        // S√©curit√© stock
        if (!this.items[itemKey] || this.items[itemKey] <= 0) {
            toast.error("Erreur", "Vous n'avez plus cet objet !");
            return;
        }

        // 1. Si d√©j√† un objet, on le retire d'abord (√©change)
        if (creature.heldItem) {
            this.items[creature.heldItem] = (this.items[creature.heldItem] || 0) + 1;
        }

        // 2. On prend le nouveau
        this.items[itemKey]--;
        creature.heldItem = itemKey;

        // 3. Feedback & Update
        const itemName = HELD_ITEMS[itemKey] ? HELD_ITEMS[itemKey].name : itemKey;
        toast.success("√âquip√© !", `${creature.name} tient maintenant : ${itemName}`);
        logMessage(`üéí ${creature.name} a √©t√© √©quip√© avec ${itemName}.`);

        this.updateItemsDisplay();
        this.showCreatureModal(creatureIndex, location); // Rafra√Æchir le modal pour voir l'objet
    }

    // LOGIQUE : Retirer l'objet
    unequipItem(creatureIndex, location) {
        let creature;
        if (location === 'team') creature = this.playerTeam[creatureIndex];
        else if (location === 'storage') creature = this.storage[creatureIndex];
        else if (location === 'pension') creature = this.pension[creatureIndex];

        if (!creature || !creature.heldItem) return;

        // 1. Remettre en stock
        const itemKey = creature.heldItem;
        this.items[itemKey] = (this.items[itemKey] || 0) + 1;
        
        // 2. Retirer de la cr√©ature
        creature.heldItem = null;

        // 3. Feedback & Update
        const itemName = HELD_ITEMS[itemKey] ? HELD_ITEMS[itemKey].name : itemKey;
        toast.info("Retir√©", `${itemName} remis dans le sac.`);
        
        this.updateItemsDisplay();
        this.showCreatureModal(creatureIndex, location); // Rafra√Æchir le modal
    }
	
  // UI : Affiche le d√©tail d'une cr√©ature (Version Corrig√©e avec Prisme)
    showCreatureModal(index, location) {
        let creature;
        if (location === 'team') creature = this.playerTeam[index];
        else if (location === 'storage') creature = this.storage[index];
        else if (location === 'pension') creature = this.pension[index];
        
        if (!creature) return;

        const modal = document.getElementById('creatureModal');
        const content = document.getElementById('creatureModalContent');
        if (!modal || !content) return;

        const spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, false);
        const maxLevel = 100 + (creature.prestige * 10);
        
        // --- PR√âPARATION DES DONN√âES (LOGIQUE JS) ---
        // On calcule tout ICI, AVANT de commencer √† √©crire le HTML

        // 1. Talent
        let talentHTML = '<div><strong>Talent:</strong> Aucun</div>';
        if (creature.passiveTalent) {
            const talent = creature.getTalentInfo();
            talentHTML = `<div style="border-left: 4px solid #a855f7; padding-left: 8px; margin-bottom: 5px;">
                <strong>Talent: ${talent.name}</strong><br>
                <span style="font-size: 12px; color: #555;">${talent.description}</span>
            </div>`;
        }
        
        // 2. Ultime
        let ultimateHTML = '<div><strong>Ultime:</strong> Aucun</div>';
        if (creature.ultimateAbility) {
            const ult = creature.ultimateAbility;
            ultimateHTML = `<div style="border-left: 4px solid #f59e0b; padding-left: 8px;">
                <strong>Ultime: ${ult.name}</strong> (${ult.chargeNeeded} charge)<br>
                <span style="font-size: 12px; color: #555;">${ult.description}</span>
            </div>`;
        }

        // 3. Objet Tenu
        let itemHTML = '';
        if (creature.heldItem) {
            const item = HELD_ITEMS[creature.heldItem];
            if (item) {
                itemHTML = `
                    <div class="held-item-slot equipped" onclick="game.unequipItem(${index}, '${location}')">
                        <div style="font-weight:bold; color:#667eea;">üéí ${item.name}</div>
                        <div style="font-size:11px;">${item.effect ? (item.description || 'Effet actif') : ''}</div>
                        <div style="font-size:10px; color:#ef4444; margin-top:5px;">(Cliquer pour retirer)</div>
                    </div>
                `;
            }
        } else {
            itemHTML = `
                <div class="held-item-slot" onclick="game.showItemSelectModal(${index}, '${location}')">
                    <div style="color:#999;">Emplacement d'objet vide</div>
                    <div style="font-size:11px; font-weight:bold;">+ √âquiper un objet</div>
                </div>
            `;
        }

        // 4. ‚úÖ BOUTON PRISME (Pr√©par√© ici)
        let ivButton = '';
        if (this.items['prism_iv'] && this.items['prism_iv'] > 0) {
            ivButton = `<button onclick="game.optimizeCreatureIVs(${index}, '${location}')" 
                style="font-size:10px; padding:2px 6px; background:linear-gradient(135deg, #a855f7, #ec4899); color:white; border:none; border-radius:4px; cursor:pointer; margin-left:5px;">
                üíé Optimiser
            </button>`;
        }

        // 5. Prestige
        const tokens = creature.prestigeTokens || 0;
        const bonuses = creature.prestigeBonuses || { hp: 0, attack: 0, defense: 0, speed: 0 };
        let tokenDisplay = '';
        if (tokens > 0) {
            tokenDisplay = `<div style="margin-bottom:15px; padding:8px; background:#fff3cd; border:1px solid #ffeeba; color:#856404; border-radius:8px; font-size:12px; text-align:center; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
                ‚≠ê <strong>${tokens} Jetons de Prestige</strong> disponibles !<br>Am√©liorez une stat ci-dessous.
            </div>`;
        }

        // Helper affichage ligne de stat
        const statLine = (label, value, statKey, icon) => {
            let btnHTML = '';
            if (tokens > 0) {
                btnHTML = `<button onclick="game.spendPrestigeToken(${index}, '${location}', '${statKey}')" 
                           style="padding:0 6px; font-size:10px; margin-left:5px; background:#22c55e; color:white; border:none; border-radius:4px; cursor:pointer; transition:0.2s;"
                           onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                           +5%
                           </button>`;
            }
            let bonusText = '';
            if (bonuses[statKey] > 0) {
                bonusText = `<span style="font-size:10px; color:#22c55e; font-weight:bold; margin-left:3px;">(+${bonuses[statKey] * 5}%)</span>`;
            }
            return `<div>${icon} <strong>${label}:</strong> ${formatNumber(value)} ${bonusText} ${btnHTML}</div>`;
        };

        // --- G√âN√âRATION HTML ---
        // Ici on utilise les variables pr√©par√©es (${ivButton}, ${talentHTML}...)
        
        let actionsHTML = this.generateCreatureActionsHTML(creature, index, location, maxLevel);

        content.innerHTML = `
            <div class="stats-header" style="border: none;">
                <h2 style="margin: 0;">${creature.name} ${creature.isShiny ? '‚ú®' : ''} ${creature.prestige > 0 ? `‚òÖ${creature.prestige}` : ''}</h2>
                <button class="stats-close" onclick="game.closeCreatureModal()">Fermer</button>
            </div>
            
            <div class="creature-modal-grid">
                <div>
                    <img src="${spriteUrl}" alt="${creature.name}" class="creature-modal-sprite">
                    <div style="text-align: center; margin-top: 10px;">
                        <span class="type-badge type-${creature.type}">${creature.type}</span>
                        ${creature.secondaryType ? `<span class="type-badge type-${creature.secondaryType}">${creature.secondaryType}</span>` : ''}
                        <span class="rarity-label ${creature.rarity}">${creature.rarity}</span>
                    </div>
                </div>
                
                <div>
                    ${tokenDisplay}

                    <div class="creature-modal-stats">
                        <strong>Niveau:</strong> ${creature.level} / ${maxLevel}<br>
                        
                        ${statLine('HP', creature.maxHp, 'hp', '‚ù§Ô∏è')}
                        ${statLine('Attaque', creature.attack, 'attack', '‚öîÔ∏è')}
                        ${statLine('D√©fense', creature.defense, 'defense', 'üõ°Ô∏è')}
                        ${statLine('Vitesse', creature.speed, 'speed', 'üëü')}
                        
                        <br>
                        <strong style="color: #007bff;">IVs:</strong> ${creature.ivHP}/${creature.ivAttack}/${creature.ivDefense}/${creature.ivSpeed} ${ivButton}<br>
                        <strong>Endurance:</strong> ${creature.currentStamina} / ${creature.maxStamina}
                    </div>
                    <hr style="border: 0; border-top: 1px solid #eee; margin: 15px 0;">
                    
                    <div class="creature-modal-info">
                        ${talentHTML}
                        ${ultimateHTML}
                        ${itemHTML}
                    </div>
                </div>

                <div class="creature-modal-actions">
                    ${actionsHTML.length > 0 ? actionsHTML : '<div>Aucune action disponible.</div>'}
                </div>
            </div>
        `;

        modal.classList.add('show');
    }

    // Helper pour ne pas surcharger la fonction principale
    generateCreatureActionsHTML(creature, index, location, maxLevel) {
        let actionsHTML = '';
        const maxTeamSize = 6 + this.getAccountTalentBonus('team_slot');
        const maxPensionSlots = this.getPensionSlots();
        const isTowerActive = this.towerState.isActive;
        const canUsePension = maxPensionSlots > 0; 

        if (location === 'team') {
            if (index !== this.activeCreatureIndex && creature.isAlive()) {
                actionsHTML += `<button class="btn" style="background: #ffd700; color: #333;" onclick="game.setActiveCreature(${index}); game.closeCreatureModal();">Activer</button>`;
            }
            if (this.playerTeam.length > 1) {
                actionsHTML += `<button class="btn" style="background: #007bff;" onclick="game.moveToStorage(${index}); game.closeCreatureModal();" ${isTowerActive ? 'disabled' : ''}>${isTowerActive ? 'VERROUILL√â' : 'Stocker'}</button>`;
            }
            if (canUsePension && this.pension.length < maxPensionSlots && this.playerTeam.length > 1) {
                actionsHTML += `<button class="btn" style="background: #ff69b4;" onclick="game.moveToPension(${index}, true); game.closeCreatureModal();" ${isTowerActive ? 'disabled' : ''}>${isTowerActive ? 'VERROUILL√â' : 'Pension'}</button>`;
            }
        } else if (location === 'storage') {
            if (this.playerTeam.length < maxTeamSize) {
                actionsHTML += `<button class="btn btn-save" onclick="game.moveToTeam(${index}); game.closeCreatureModal();" ${isTowerActive ? 'disabled' : ''}>${isTowerActive ? 'VERROUILL√â' : 'Vers √âquipe'}</button>`;
            }
            if (canUsePension && this.pension.length < maxPensionSlots) {
                actionsHTML += `<button class="btn" style="background: #ff69b4;" onclick="game.moveToPension(${index}, false); game.closeCreatureModal();">Pension</button>`;
            }
            if (this.activeExpeditions.length < this.maxExpeditionSlots) {
                actionsHTML += `<button class="btn" style="background: #0dcaf0; color: white;" onclick="game.showExpeditionSendModal(${index}); game.closeCreatureModal();">üó∫Ô∏è Envoyer</button>`;
            }
        } else if (location === 'pension') {
            if (this.playerTeam.length < maxTeamSize) {
                actionsHTML += `<button class="btn btn-save" onclick="game.moveFromPension(${index}, true); game.closeCreatureModal();" ${isTowerActive ? 'disabled' : ''}>${isTowerActive ? 'VERROUILL√â' : 'Vers √âquipe'}</button>`;
            }
            actionsHTML += `<button class="btn" style="background: #007bff;" onclick="game.moveFromPension(${index}, false); game.closeCreatureModal();">Stockage</button>`;
        }
        
        // √âvolution
        const evolutionData = EVOLUTIONS[creature.name];
        if (evolutionData && creature.level >= evolutionData.level && !evolutionData.condition) {
            const existingDuplicate = this.findCreatureByName(evolutionData.evolves_to, creature.isShiny);
            const label = existingDuplicate ? "üß¨ FUSIONNER" : "‚ú® √âVOLUER";
            const color = existingDuplicate ? "linear-gradient(135deg, #a855f7, #9333ea)" : "linear-gradient(135deg, #34d399, #059669)";
            actionsHTML += `<button class="btn" style="background: ${color}; color: white; animation: pulse-reward 2s infinite;" onclick="game.evolveCreature(${index}, '${location}');">${label}</button>`;
        }
        
        // Prestige
        const canPrestige = creature.level >= maxLevel;
        if (canPrestige) {
            const shardKey = getShardKey(creature.name, creature.rarity);
            const currentShards = this.shards[shardKey] || 0;
            const prestigeCost = this.getPrestigeCost(creature.prestige);
            
            if (currentShards >= prestigeCost) {
                actionsHTML += `<button class="btn" style="background: #ffd700; color: #333;" onclick="game.prestigeCreature(${index}, '${location}'); game.closeCreatureModal();">‚≠ê PRESTIGE (${prestigeCost})</button>`;
            } else {
                actionsHTML += `<button class="btn" disabled style="background: #ccc; color: #666;">‚≠ê PRESTIGE (${currentShards}/${prestigeCost})</button>`;
            }
        }

        // Reroll / Choix Talent
        if (creature.passiveTalent) {
            if (this.talentRerolls > 0) {
                actionsHTML += `<button class="btn" style="background: #a855f7; color: white;" onclick="game.useTalentReroll(${index}, '${location}')">üîÆ Reroll (${this.talentRerolls})</button>`;
            }
            if (this.talentChoices > 0) {
                actionsHTML += `<button class="btn" style="background: #f59e0b; color: white;" onclick="game.useTalentChoice(${index}, '${location}'); game.closeCreatureModal();">üåü Choisir (${this.talentChoices})</button>`;
            }
        }

        return actionsHTML;
    }

closeCreatureModal() {
    const modal = document.getElementById('creatureModal');
    if (modal) {
        modal.classList.remove('show');
    }
    // Mettre √† jour l'affichage principal au cas o√π une action a √©t√© effectu√©e
    this.updateDisplay();
}
   
   /**
     * Cherche si une cr√©ature existe d√©j√† dans toutes les collections (√©quipe, stockage, pension)
     * @param {string} nameToFind - Le nom du Pok√©mon (ex: "Charizard")
     * @param {boolean} isShiny - Le statut Shiny
     * @returns {Creature|null} La cr√©ature trouv√©e, ou null
     */
    findCreatureByName(nameToFind, isShiny) {
        const locations = [this.playerTeam, this.storage, this.pension];
        for (const location of locations) {
            const found = location.find(c => c.name === nameToFind && c.isShiny === isShiny);
            if (found) {
                return found; // Retourne la premi√®re cr√©ature trouv√©e
            }
        }
        return null; // Non trouv√©
    }
	

            updatePokedexDisplay() {
    const pokedexList = document.getElementById('pokedexList');
    const pokedexCount = document.getElementById('pokedexCount');
    const pokedexTotal = document.getElementById('pokedexTotal');
    
    if (!pokedexList) return;

    // S√âCURIT√â 1 : Initialiser si vide
    if (!this.pokedex) this.pokedex = {};

    const entries = Object.values(this.pokedex);
    
    if (pokedexCount) pokedexCount.textContent = entries.length;
    
    // S√âCURIT√â 2 : V√©rifier si la liste des IDs existe
    const hasIds = typeof POKEMON_SPRITE_IDS !== 'undefined';
    if (pokedexTotal) pokedexTotal.textContent = hasIds ? Object.keys(POKEMON_SPRITE_IDS).length : "???";
    
    pokedexList.innerHTML = '';
    
    if (entries.length === 0) {
        pokedexList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; grid-column: 1 / -1;">Aucun Pok√©mon d√©couvert. Lancez une r√©paration !</div>';
        return;
    }
    
    entries.forEach(entry => {
        // S√âCURIT√â 3 : Ignorer les entr√©es corrompues (null ou undefined)
        if (!entry || !entry.name) return;

        const card = document.createElement('div');
        card.className = "creature-card rarity-" + (entry.rarity || 'common');
        if (entry.hasShiny) card.className += " shiny";
        
        // Gestion de l'ID (Num√©ro)
        let formattedId = "???";
        if (hasIds) {
            const dexId = POKEMON_SPRITE_IDS[entry.name];
            if (dexId) formattedId = "#" + dexId.toString().padStart(3, '0');
        }

        // Gestion de l'image (Sprite)
        const spriteUrl = getPokemonSpriteUrl(entry.name, false); 

        const shinyIcon = entry.hasShiny ? '<span title="Shiny captur√©">‚ú®</span>' : '';
        
        // S√âCURIT√â 4 : Date valide
        let discoveryDate = "Inconnu";
        if (entry.firstDiscoveredAt) {
            discoveryDate = new Date(entry.firstDiscoveredAt).toLocaleDateString();
        }
        
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:5px;">
                <span style="font-size:10px; color:#666; font-weight:bold;">${formattedId}</span>
                ${shinyIcon}
            </div>
            
            <img src="${spriteUrl}" class="team-slot-sprite" style="width:64px; height:64px; margin:0 auto; display:block;" onerror="this.style.display='none'">
            
            <h4 style="font-size:14px; margin:5px 0;">${entry.name}</h4>
            
            

            <div style="margin-top: 10px; font-size: 11px; color: #555; border-top:1px solid rgba(0,0,0,0.1); padding-top:5px;">
                <div>Captur√©s : <strong>${entry.count || 1}</strong></div>
                ${entry.hasShiny ? `<div style="color:#d97706;">Dont Shinies : <strong>${entry.shinyCount || 1}</strong></div>` : ''}
                <div style="font-size:9px; color:#888; margin-top:2px;">${discoveryDate}</div>
            </div>
        `;
        
        pokedexList.appendChild(card);
    });
}

/**
 * Trouve la raret√© naturelle d'un Pok√©mon dans les constantes.
 */
getNaturalRarity(pokemonName) {
    // On parcourt les raret√©s (Legendary, Epic, Rare, Common)
    const rarities = [RARITY.LEGENDARY, RARITY.EPIC, RARITY.RARE, RARITY.COMMON];
    
    for (const rarity of rarities) {
        const pool = POKEMON_POOL[rarity];
        if (!pool) continue;
        
        // On cherche dans chaque type de ce pool
        for (const type in pool) {
            if (pool[type].includes(pokemonName)) {
                return rarity;
            }
        }
    }
    
    // Par d√©faut (ou si introuvable, ex: starter forc√©)
    return RARITY.COMMON;
}

/**
     
   /**
     * √âquipe un objet sur une cr√©ature (Version Corrig√©e)
     */
    equipItem(itemKey, creatureIndex, location) {
        try {
            let creature;
            if (location === 'team') creature = this.playerTeam[creatureIndex];
            else if (location === 'storage') creature = this.storage[creatureIndex];
            else if (location === 'pension') creature = this.pension[creatureIndex];

            // S√©curit√©s
            if (!creature) {
                console.error("Cr√©ature introuvable pour √©quipement");
                return;
            }
            
            // On s'assure que la quantit√© est un nombre
            let currentQty = parseInt(this.items[itemKey] || 0);

            if (currentQty > 0) {
                // 1. Si elle tient d√©j√† un objet, on le d√©s√©quipe d'abord (remise en stock)
                if (creature.heldItem) {
                    const oldItemKey = creature.heldItem;
                    this.items[oldItemKey] = parseInt(this.items[oldItemKey] || 0) + 1;
                }

                // 2. D√©cr√©menter l'objet s√©lectionn√©
                this.items[itemKey] = currentQty - 1;
                
                // Si le compte tombe √† 0 ou moins, on peut nettoyer la cl√© (optionnel mais propre)
                if (this.items[itemKey] <= 0) delete this.items[itemKey];

                // 3. Assigner l'objet
                creature.heldItem = itemKey;
                
                // 4. Feedback (avec s√©curit√©)
                const itemName = (HELD_ITEMS[itemKey] && HELD_ITEMS[itemKey].name) ? HELD_ITEMS[itemKey].name : itemKey;
                if (typeof toast !== 'undefined') {
                    toast.success("Objet √©quip√©", `${creature.name} tient maintenant : ${itemName}`);
                } else {
                    logMessage(`‚úÖ Objet √©quip√© : ${itemName}`);
                }
                
                // 5. Fermer le modal de la cr√©ature
                this.closeCreatureModal(); 
            }
        } catch (error) {
            console.error("Erreur dans equipItem:", error);
        } finally {
            // 6. Mettre √† jour l'affichage QUOI QU'IL ARRIVE
            this.updateDisplay();
        }
    }

    /**
     * D√©s√©quipe un objet (Version Corrig√©e)
     */
    unequipItem(creatureIndex, location) {
        try {
            let creature;
            if (location === 'team') creature = this.playerTeam[creatureIndex];
            else if (location === 'storage') creature = this.storage[creatureIndex];
            else if (location === 'pension') creature = this.pension[creatureIndex];

            if (creature && creature.heldItem) {
                const itemKey = creature.heldItem;
                
                // Remettre dans l'inventaire
                this.items[itemKey] = parseInt(this.items[itemKey] || 0) + 1;
                
                const itemName = (HELD_ITEMS[itemKey] && HELD_ITEMS[itemKey].name) ? HELD_ITEMS[itemKey].name : itemKey;
                
                // Retirer de la cr√©ature
                creature.heldItem = null;
                
                if (typeof toast !== 'undefined') {
                    toast.info("Objet retir√©", `${itemName} remis dans le sac.`);
                } else {
                    logMessage(`‚¨áÔ∏è Objet retir√© : ${itemName}`);
                }
                
                this.closeCreatureModal();
            }
        } catch (error) {
            console.error("Erreur dans unequipItem:", error);
        } finally {
            this.updateDisplay();
        }
    }
	
	
	  
	   // ============= SYST√àME DE QU√äTES =============

// LOGIQUE : G√©n√©rateur de Qu√™tes (Avec priorit√© Sc√©nario)
    generateQuest() {
        if (this.quests.length >= 10) return;

        // --- 1. V√âRIFICATION DES QU√äTES SC√âNARIO (PRIORITAIRE) ---
        // On v√©rifie si on doit donner la Canne ou le Surf
        
        // A. La Canne √† P√™che (D√®s la Zone 2)
        if (currentZone >= STORY_QUESTS.unlock_rod.triggerZone && !this.items['old_rod']) {
            // V√©rifie si la qu√™te n'est pas d√©j√† active ou compl√©t√©e (historique)
            const alreadyHas = this.quests.some(q => q.id === STORY_QUESTS.unlock_rod.id);
            if (!alreadyHas) {
                this.addStoryQuest(STORY_QUESTS.unlock_rod);
                return; // On ne g√©n√®re pas d'autre qu√™te pour l'instant
            }
        }

        // B. Le Surf (D√®s la Zone 10)
        if (currentZone >= STORY_QUESTS.unlock_surf.triggerZone && !this.items['surfboard']) {
            const alreadyHas = this.quests.some(q => q.id === STORY_QUESTS.unlock_surf.id);
            if (!alreadyHas) {
                this.addStoryQuest(STORY_QUESTS.unlock_surf);
                return;
            }
        }

        // --- 2. G√âN√âRATION AL√âATOIRE CLASSIQUE (CODE EXISTANT) ---
        
        // D√©terminer la difficult√©
        let difficulty = 'EASY';
        const totalCreatures = this.playerTeam.length + this.storage.length + this.pension.length;
        const prestigeCount = this.stats.prestigeCount || 0;
        const badgesCount = Object.values(this.badges).filter(b => b).length;
        
        if (prestigeCount >= 3 || badgesCount >= 5) {
            const roll = Math.random();
            if (roll < 0.3) difficulty = 'EXTREME';
            else if (roll < 0.6) difficulty = 'HARD';
            else difficulty = 'MEDIUM';
        } else if (totalCreatures > 50 || badgesCount >= 3) {
            const roll = Math.random();
            if (roll < 0.4) difficulty = 'HARD';
            else difficulty = 'MEDIUM';
        } else if (totalCreatures > 20) {
            const roll = Math.random();
            if (roll < 0.6) difficulty = 'MEDIUM';
            else difficulty = 'EASY';
        }
        
        // Choisir un type et template
        const questTypeKeys = Object.keys(QUEST_TYPES);
        const randomType = QUEST_TYPES[questTypeKeys[Math.floor(Math.random() * questTypeKeys.length)]];
        const templates = QUEST_TEMPLATES[randomType];
        
        if (!templates || templates.length === 0) return;
        
        const randomTemplate = templates[Math.floor(Math.random() * templates.length)];
        
        // Cr√©er la qu√™te
        const quest = new Quest(randomTemplate, 1, difficulty);
        quest.questType = randomType;
        
        this.quests.push(quest);
        this.updateQuestsDisplay();
        
        const diffInfo = QUEST_DIFFICULTIES[difficulty];
        logMessage(`${diffInfo.icon} Nouvelle qu√™te ${diffInfo.name} : ${quest.title}`);
    }

    // HELPER : Ajoute une qu√™te sc√©naris√©e sp√©cifique
    addStoryQuest(storyDef) {
        // On cr√©e une qu√™te manuellement bas√©e sur la d√©finition statique
        const quest = new Quest({
            title: storyDef.title,
            desc: storyDef.description,
            target: storyDef.target,
            trackingKey: storyDef.trackingKey
        }, 1, storyDef.difficulty);

        // On force les propri√©t√©s uniques
        quest.id = storyDef.id; // ID Fixe pour √©viter les doublons
        quest.rewards = storyDef.rewards; // R√©compenses sp√©cifiques (Item)
        quest.questType = 'STORY'; // Type sp√©cial pour l'affichage √©ventuel
        
        this.quests.push(quest);
        this.updateQuestsDisplay();
        
        toast.legendary("Qu√™te Sp√©ciale !", storyDef.title);
        logMessage(`üìú QU√äTE SC√âNARIO : ${storyDef.title}`);
    }

checkSpecialQuests(eventType, params = {}) {
        if (!this.quests) return;

        this.quests.forEach(quest => {
            if (!quest.accepted || quest.completed) return;

            let questWasJustCompleted = false;

            // --- GESTION DE LA PROGRESSION ---

            // 1. GESTION DES COMPTEURS SIMPLES
            const simpleCounters = [
                'combatsWon', 'bossDefeated', 'eggsOpened', 'creaturesObtained', 
                'newDiscoveriesDuringQuest', 
                'legendariesObtainedDuringQuest',
                 'statusInflicted', 'totalShards', 'shiniesObtained','fusion_completed'
            ];
            
            // ‚úÖ CORRECTIF : Normalisation des √©v√©nements
            // On fait correspondre l'√©v√©nement technique (creature_obtained) avec la cl√© de la qu√™te (creaturesObtained)
            let effectiveEvent = eventType;
            if (eventType === 'creature_obtained' && quest.trackingKey === 'creaturesObtained') {
                effectiveEvent = 'creaturesObtained';
            }

            if (quest.trackingKey === 'prestigeCount' && eventType === 'prestigeCount') {
                quest.current = (quest.current || 0) + 1;
            }
                    
            if (simpleCounters.includes(quest.trackingKey) && effectiveEvent === quest.trackingKey) {
                
                // ‚úÖ AJOUT : V√©rification du Type requis (pour la qu√™te Jumelles)
                if (quest.special === 'type_hunt' && quest.requiredType) {
                    const type1 = params.creatureType || '';
                    const type2 = params.secondaryType || '';
                    // Si le Pok√©mon n'est pas du bon type, on n'avance pas
                    if (type1 !== quest.requiredType && type2 !== quest.requiredType) {
                        return; 
                    }
                }

                quest.current = (quest.current || 0) + 1;
            }

            // 2. GESTION DES QU√äTES COMPLEXES
            switch (quest.trackingKey) {
                
                case 'totalPokedollarsEarned':
                    if (eventType === 'pokedollars_gained') {
                        const moneyGainedSinceStart = this.stats.totalPokedollarsEarned - (quest.startValue || 0);
                        quest.updateProgress(moneyGainedSinceStart);
                    }
                    break;

                case 'maxCreatureLevel':
                    if (eventType === 'level_up') {
                        const allCreatures = [...this.playerTeam, ...this.storage, ...this.pension];
                        const maxLevel = Math.max(0, ...allCreatures.map(c => c.level));
                        quest.updateProgress(maxLevel);
                    }
                    break;

                case 'maxTierEnemies':
                    if (eventType === 'tier_increased') {
                        const zone = ZONES[currentZone];
                        const maxTier = zone.maxTier || 50;
                        const progress = this.zoneProgress[currentZone];
                        const enemyTiers = progress?.enemyTiers ? Object.values(progress.enemyTiers) : [];
                        const enemiesAtMaxTier = enemyTiers.filter(tier => tier >= maxTier).length;
                        quest.updateProgress(enemiesAtMaxTier);
                    }
                    break;
                
                case 'winStreak':
                    if (eventType === 'combatsWon') {
                        this.sessionStats.currentWinStreak = (this.sessionStats.currentWinStreak || 0) + 1;
                        quest.updateProgress(this.sessionStats.currentWinStreak);
                    } else if (eventType === 'combat_lost') {
                        this.sessionStats.currentWinStreak = 0;
                        quest.updateProgress(0);
                    }
                    break;

                case 'perfectWins':
                    if (eventType === 'combatsWon' && params.noDeath) {
                        quest.current = (quest.current || 0) + 1;
                    } else if (eventType === 'combat_lost' || (eventType === 'combatsWon' && !params.noDeath)) {
                        quest.current = 0;
                    }
                    break;
                
                case 'currentMoney':
                    // Qu√™te "√âconome"
                    if (eventType === 'pokedollars_gained') {
                        const progress = this.pokedollars - (quest.startValue || 0);
                        quest.updateProgress(Math.max(0, progress));
                    } 
                    else if (eventType === 'money_spent') {
                        quest.startValue = this.pokedollars;
                        quest.current = 0;
                        quest.updateProgress(0);
                        if (typeof toast !== 'undefined') {
                            toast.warning("√âconome", "D√©pense d√©tect√©e ! La qu√™te repart √† z√©ro.");
                        }
                    }
                    break;
                
                case 'zonesUnlocked':
                    if(eventType === 'zone_unlocked') {
                        const unlockedZones = Object.keys(ZONES).filter(z => this.isZoneUnlocked(z)).length;
                        quest.updateProgress(unlockedZones);
                    }
                    break;
            }
            
            // Gestion sp√©cifique pour la qu√™te "√âleveur L√©gendaire"
            if (quest.special === 'legendary_counter' && eventType === 'legendary_obtained') {
                const current = (quest.current || 0) + 1;
                quest.updateProgress(current);
            }

            // Logique pour la qu√™te "Arc-en-Ciel"
            if ((quest.special === 'rainbow' || quest.trackingKey === 'newTypesDuringQuest') && eventType === 'creature_obtained') {
                if (!quest.typesObtained) {
                    quest.typesObtained = new Set();
                }
                if (params.creatureType) {
                    quest.typesObtained.add(params.creatureType);
                }
                if (params.secondaryType) {
                    quest.typesObtained.add(params.secondaryType);
                }
                quest.updateProgress(quest.typesObtained.size);
            }

            // --- V√âRIFICATION DE L'ACH√àVEMENT ---
            if (quest.current >= quest.target && !quest.completed) {
                quest.completed = true;
                questWasJustCompleted = true;
            }

            if (questWasJustCompleted) {
                this.showQuestCompletionModal(quest);
            }
        });

        this.updateQuestsDisplay();
    }


// LOGIQUE : Optimisation des IVs (Conserve le meilleur)
    optimizeCreatureIVs(creatureIndex, location) {
        // 1. V√©rification Item
        if (!this.items['prism_iv'] || this.items['prism_iv'] <= 0) {
            toast.error("Erreur", "Vous n'avez pas de Prisme d'Optimisation !");
            return;
        }

        // 2. R√©cup√©ration Cr√©ature
        let creature;
        if (location === 'team') creature = this.playerTeam[creatureIndex];
        else if (location === 'storage') creature = this.storage[creatureIndex];
        else if (location === 'pension') creature = this.pension[creatureIndex];

        if (!creature) return;

        // 3. Consommation
        this.items['prism_iv']--;

        // 4. Le "Roll" (Tirage)
        // On g√©n√®re 4 nouveaux IVs entre 0 et 31 (comme dans le constructeur)
        const newHP = Math.floor(Math.pow(Math.random(), 3) * 32);
        const newAtk = Math.floor(Math.pow(Math.random(), 3) * 32);
        const newDef = Math.floor(Math.pow(Math.random(), 3) * 32);
        const newSpd = Math.floor(Math.pow(Math.random(), 3) * 32);

        // 5. Comparaison et Application (On garde le meilleur !)
        let improvements = 0;
        
        if (newHP > creature.ivHP) { creature.ivHP = newHP; improvements++; }
        if (newAtk > creature.ivAttack) { creature.ivAttack = newAtk; improvements++; }
        if (newDef > creature.ivDefense) { creature.ivDefense = newDef; improvements++; }
        if (newSpd > creature.ivSpeed) { creature.ivSpeed = newSpd; improvements++; }

        // 6. Sauvegarde et Feedback
        creature.recalculateStats();
        creature.heal(); // On soigne les nouveaux PV max
        
        this.updateItemsDisplay();
        this.updateDisplay();
        
        // On rafra√Æchit le modal pour voir les nouveaux chiffres en direct
        this.showCreatureModal(creatureIndex, location);

        if (improvements > 0) {
            toast.success("Optimisation R√©ussie !", `üíé ${creature.name} a am√©lior√© ${improvements} stat(s) !`);
            logMessage(`üíé Le Prisme brille ! ${creature.name} devient plus fort (IVs am√©lior√©s).`);
        } else {
            toast.warning("Pas de changement", "Le Prisme n'a pas trouv√© de meilleur potentiel...");
            logMessage(`üíé Le potentiel de ${creature.name} √©tait d√©j√† sup√©rieur au Prisme.`);
        }
    }
	
	

// LOGIQUE : √âvolution S√©curis√©e (Pr√©serve Shiny, IVs, Prestige)
    evolveCreature(creatureIndex, location) {
        let creature;
        let containerArray;

        // 1. Identification de la cible
        if (location === 'team') {
            creature = this.playerTeam[creatureIndex];
            containerArray = this.playerTeam;
        } else if (location === 'storage') {
            creature = this.storage[creatureIndex];
            containerArray = this.storage;
        } else if (location === 'pension') {
            creature = this.pension[creatureIndex];
            containerArray = this.pension;
        }

        if (!creature) {
            console.error(`‚ùå Erreur √âvolution : Cr√©ature introuvable [${location}:${creatureIndex}]`);
            return;
        }

        // 2. V√©rification des conditions
        const evolutionData = EVOLUTIONS[creature.name];
        if (!evolutionData) return; // Pas d'√©volution
        
        // On bloque si c'est une √©volution par objet (g√©r√© par useItem)
        if (evolutionData.condition) {
            logMessage(`‚ÑπÔ∏è ${creature.name} a besoin d'un objet sp√©cial pour √©voluer.`);
            return;
        }

        if (creature.level < evolutionData.level) {
            logMessage(`‚õî ${creature.name} doit √™tre niveau ${evolutionData.level} pour √©voluer.`);
            return;
        }

        const oldName = creature.name;
        const newName = evolutionData.evolves_to;
        
        // 3. V√âRIFICATION DOUBLON (Fusion)
        // On regarde si on poss√®de D√âJ√Ä la forme √©volu√©e (avec le m√™me statut Shiny)
        const existingEvo = this.findCreatureByName(newName, creature.isShiny);

        if (existingEvo) {
            // CAS A : FUSION
            // On fusionne l'actuel (source) DANS celui qui existe d√©j√† (target)
            const result = this.processFusion(creature, existingEvo);

            // On supprime la cr√©ature qui vient d'√©voluer (elle a √©t√© absorb√©e)
            if (location === 'team') this.playerTeam.splice(creatureIndex, 1);
            else if (location === 'storage') this.storage.splice(creatureIndex, 1);
            else if (location === 'pension') this.pension.splice(creatureIndex, 1);

            let msg = `üß¨ FUSION √âVOLUTIVE ! ${oldName} absorb√© par ${existingEvo.name}.`;
            if (result.improved) msg += " Stats am√©lior√©es !";
            if (result.prestigeUp) msg += " Prestige transf√©r√© !";
            
            logMessage(msg);
            toast.success("Fusion R√©ussie", `+${result.shards} Shards` + (result.improved ? " & Boost Stats" : ""));
            
            // Mise √† jour UI globale car une cr√©ature a disparu
            this.updateDisplay();
            this.closeCreatureModal();
            return;
        } 
        
        // CAS B : √âVOLUTION (Mutation sur place)
        // C'est ici qu'on garde les propri√©t√©s (IV, Shiny...) car c'est le M√äME objet JS
        
        // Sauvegarde pour feedback
        const oldRarity = creature.rarity;
        
        // Modification des propri√©t√©s de base
        creature.name = newName;
        creature.type = this.findTypeForPokemon(newName);
        creature.secondaryType = POKEMON_SECONDARY_TYPES[newName] || null;
        
        // Mise √† jour de la raret√© (ex: Magicarpe Common -> L√©viator Epic)
        const newRarity = this.getNaturalRarity(newName);
        if (creature.rarity !== newRarity) {
            creature.rarity = newRarity;
            // Si on passe √† Epic/Legendary et qu'on n'a pas de talent, on en donne un !
            if (!creature.passiveTalent && (newRarity === RARITY.EPIC || newRarity === RARITY.LEGENDARY)) {
                creature.assignRandomTalent();
                logMessage(`‚ú® Nouveau talent d√©bloqu√© : ${PASSIVE_TALENTS[creature.passiveTalent].name} !`);
            }
        }

        // Recalcul complet des stats (Base stats changent + Raret√© change)
        creature.recalculateStats();
        creature.heal(); // Soin complet pour f√™ter √ßa

        // Mise √† jour Pok√©dex
        const pokedexKey = getShardKey(creature.name, creature.rarity); // Utilise le format Name_Rarity
        // Note: Pour le pok√©dex on utilise une cl√© plus compl√®te habituellement
        const dexKeyFull = creature.name + "_" + creature.type + "_" + creature.rarity;
        
        if (!this.pokedex[dexKeyFull]) {
            this.pokedex[dexKeyFull] = { 
                discovered: true, count: 1, 
                shinyCount: creature.isShiny ? 1 : 0, 
                hasShiny: creature.isShiny, 
                name: creature.name, type: creature.type, rarity: creature.rarity, 
                firstDiscoveredAt: Date.now()
            };
            this.checkSpecialQuests('new_discovery');
        } else {
            this.pokedex[dexKeyFull].count++;
            if (creature.isShiny) {
                this.pokedex[dexKeyFull].shinyCount = (this.pokedex[dexKeyFull].shinyCount || 0) + 1;
                this.pokedex[dexKeyFull].hasShiny = true;
            }
        }
        
        this.stats.evolutionsCount++;
        
        // Feedback Joueur
        let evoMsg = `üéâ √âVOLUTION ! ${oldName} devient ${newName} !`;
        if (creature.isShiny) evoMsg += " (‚ú® SHINY CONSERV√â)";
        if (creature.prestige > 0) evoMsg += ` (Prestige ${creature.prestige} conserv√©)`;
        
        logMessage(evoMsg);
        toast.success("√âvolution !", `${newName} rejoint vos rangs.`);

        // Si la cr√©ature √©volu√©e est dans l'√©quipe active, on update l'affichage combat
        if (location === 'team' && this.currentPlayerCreature === creature) {
            this.updateCombatDisplay();
        }

        this.updateDisplay();
        this.closeCreatureModal();
    }

/**
     * V√©rifie si des succ√®s sont d√©bloqu√©s en fonction d'une stat modifi√©e.
     * @param {string} changedStatKey - La cl√© de this.stats qui vient de changer (ex: 'combatsWon')
     */
    checkAchievements(changedStatKey) {
        // 1. On parcourt les d√©finitions constantes
        for (const [id, achievementDef] of Object.entries(ACHIEVEMENTS)) {
            
            // 2. Optimisation : On ne v√©rifie que les succ√®s li√©s √† la stat modifi√©e
            if (achievementDef.trackingKey !== changedStatKey) continue;

            // 3. Ignorer si d√©j√† compl√©t√© (Sauvegard√© dans this.achievementsCompleted)
            // Note : Assure-toi d'avoir initialis√© cet objet dans ton constructor
            if (this.achievementsCompleted && this.achievementsCompleted[id]) continue;

            // 4. R√âCUP√âRATION DE LA VALEUR ACTUELLE (Source de v√©rit√© = this.stats)
            const currentValue = this.stats[changedStatKey] || 0;

            // 5. V√âRIFICATION
            if (currentValue >= achievementDef.target) {
                this.unlockAchievement(id, achievementDef);
            }
        }
    }

    /**
     * D√©bloque un succ√®s, donne les r√©compenses et sauvegarde.
     * @param {string} id - L'identifiant unique du succ√®s (ex: 'shinyHunter_1')
     * @param {Object} def - La d√©finition du succ√®s (titre, r√©compenses...)
     */
    unlockAchievement(id, def) {
        // 1. Initialisation & S√©curit√©
        if (!this.achievementsCompleted) this.achievementsCompleted = {};
        if (!this.stats) this.stats = {}; // S√©curit√©
        
        // Si d√©j√† d√©bloqu√©, on arr√™te
        if (this.achievementsCompleted[id]) return;

        // 2. Marquer comme compl√©t√©
        this.achievementsCompleted[id] = true;
        this.achievementsCompleted[id + '_date'] = Date.now(); 

        // 3. DISTRIBUTION DES R√âCOMPENSES
        if (def.rewards) {
            const r = def.rewards;

            // --- A. Monnaies (Ressources directes) ---
            
            // POK√âDOLLARS (Monnaie principale)
            if (r.pokedollars) {
                this.pokedollars = (this.pokedollars || 0) + r.pokedollars; 
                this.stats.totalPokedollarsEarned = (this.stats.totalPokedollarsEarned || 0) + r.pokedollars;
            }

            // COMBAT TICKETS (Jetons Tour/Ar√®ne)
            if (r.combatTickets) {
                this.combatTickets = (this.combatTickets || 0) + r.combatTickets; 
            }

            // QUEST TOKENS (Monnaie Qu√™tes)
            if (r.questTokens) {
                this.questTokens = (this.questTokens || 0) + r.questTokens; 
            }

            // MARQUES DU TRIOMPHE (Monnaie √âlite/Tour)
            if (r.marquesDuTriomphe) {
                this.marquesDuTriomphe = (this.marquesDuTriomphe || 0) + r.marquesDuTriomphe; 
            }
            // C. Objets (Master Ball, Bonbons...)
            if (r.items) {
                if (!this.items) this.items = {}; 
                for (const [itemKey, qty] of Object.entries(r.items)) {
                    this.items[itemKey] = (this.items[itemKey] || 0) + qty;
                    logMessage(`üéí Obtenu : ${qty}x ${itemKey}`); 
                }
            }

            // D. ≈íufs (S√©curit√© || 0)
            if (r.eggs) {
                if (!this.eggs) {
                    this.eggs = { [RARITY.COMMON]: 0, [RARITY.RARE]: 0, [RARITY.EPIC]: 0, [RARITY.LEGENDARY]: 0 };
                }
                for (const [rarity, qty] of Object.entries(r.eggs)) {
                    this.eggs[rarity] = (this.eggs[rarity] || 0) + qty;
                    logMessage(`ü•ö Obtenu : ${qty}x ≈íuf ${rarity}`);
                }
            }
        }

        // 4. FEEDBACK VISUEL & Log
        const rewardText = this.formatRewardText(def.rewards);
        logMessage(`üèÜ SUCC√àS D√âBLOQU√â : ${def.title}`);
        
        if (window.showFloatingText) {
            window.showFloatingText("üèÜ SUCC√àS !", document.getElementById('playerSpriteContainer'), 'ft-crit');
        }
        if (typeof toast !== 'undefined') {
            toast.success(def.title, `R√©compense : ${rewardText}`);
        }

        // 5. MISE √Ä JOUR UI & SAUVEGARDE
        if (this.updateAchievementsDisplay) this.updateAchievementsDisplay();
        if (this.updateResources) this.updateResources(); 
        
        this.saveGame(); 
        
        // 6. CHECK EN CHA√éNE (UNIQUEMENT POUR L'ARGENT/STATS QUI VIENNENT D'√äTRE MODIFI√âES)
        // C'est pour d√©bloquer le Niveau 2, 3, etc. d'un coup (si on gagne 1M de Pok√©dollars)
        if (def.rewards && def.rewards.pokedollars) {
             this.checkAchievements('totalPokedollarsEarned');
        }
    }

    /**
     * Petit utilitaire pour afficher proprement les r√©compenses en texte
     */
    formatRewardText(rewards) {
        if (!rewards) return "";
        let parts = [];
        if (rewards.pokedollars) parts.push(`${formatNumber(rewards.pokedollars)}$`);
        if (rewards.tokens) parts.push(`${rewards.tokens} Tickets`);
        if (rewards.items) parts.push(`${Object.values(rewards.items).reduce((a,b)=>a+b,0)} Obj.`);
        if (rewards.eggs) parts.push(`${Object.values(rewards.eggs).reduce((a,b)=>a+b,0)} ≈íufs`);
        return parts.join(", ");
    }
// OPTIMISATION : Gestion du Timer Qu√™te (Blind√©e contre les bugs NaN)
    updateQuestTimer(deltaTime) {
        // 1. V√©rification de la limite
        if (this.quests.length >= 10) {
            this.updateQuestTimerDisplay(); // Affiche "PLEIN"
            return;
        }

        // 2. S√©curit√© Anti-Crash (R√©paration automatique)
        if (isNaN(this.nextQuestTimer) || this.nextQuestTimer === undefined) {
            console.warn("‚ö†Ô∏è Timer Qu√™te corrompu (NaN). R√©initialisation forc√©e.");
            this.nextQuestTimer = 60000; // Reset √† 1 minute
        }

        // 3. √âcoulement du temps (Utilise deltaTime si dispo, sinon calcul manuel)
        // (Comme on l'appelle dans updateLowFreqLogic ou la boucle, on g√®re les deux cas)
        if (typeof deltaTime === 'number') {
            this.nextQuestTimer -= deltaTime;
        } else {
            // Fallback (Ancienne m√©thode)
            const now = Date.now();
            const elapsed = now - this.lastQuestUpdate;
            this.lastQuestUpdate = now;
            this.nextQuestTimer -= elapsed;
        }
        
        // 4. G√©n√©ration
        if (this.nextQuestTimer <= 0) {
            this.generateQuest();
            
            // Nouveau timer al√©atoire (2 √† 8 minutes)
            // 120000ms = 2min, 360000ms = 6min (Total max 8min)
            this.nextQuestTimer = 120000 + (Math.random() * 360000);
            
            logMessage("üìú Une nouvelle qu√™te est disponible !");
        }
        
        this.updateQuestTimerDisplay();
    }
	
// UI : Affichage du Timer Qu√™te
    updateQuestTimerDisplay() {
        const timerElement = document.getElementById('nextQuestTime');
        if (!timerElement) return;
        
        // Cas 1 : Liste pleine
        if (this.quests.length >= 10) {
            timerElement.textContent = "MAX (10/10)";
            timerElement.style.color = "#ef4444"; // Rouge
            timerElement.style.fontWeight = "bold";
            timerElement.title = "Terminez ou refusez des qu√™tes pour en recevoir de nouvelles.";
            return;
        }
        
        // Cas 2 : Timer normal
        let seconds = Math.ceil(this.nextQuestTimer / 1000);
        if (seconds < 0) seconds = 0;
        
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        timerElement.textContent = `${minutes}m ${remainingSeconds.toString().padStart(2, '0')}s`;
        timerElement.style.color = "#333";
        timerElement.style.fontWeight = "normal";
    }

acceptQuest(questId) {
        // ‚úÖ FIX : Utilisation de == pour autoriser la comparaison String vs Number
        const quest = this.quests.find(q => q.id == questId);
        
        if (!quest || quest.accepted) return;

        quest.accepted = true;
        
        // Initialisation des valeurs de d√©part
        switch (quest.trackingKey) {
            case 'totalPokedollarsEarned':
                quest.startValue = this.stats.totalPokedollarsEarned || 0;
                break;
            case 'currentMoney':
                // On sauvegarde le montant actuel comme "Plancher"
                quest.startValue = this.pokedollars;
                quest.current = 0; // La progression commence √† 0
                break;
            default:
                quest.current = 0;
                break;
        }

        if (quest.special === 'rainbow' || quest.trackingKey === 'newTypesDuringQuest') {
            quest.typesObtained = new Set();
        }
        
        logMessage("‚úÖ Qu√™te accept√©e : " + quest.title);
        this.updateQuestsDisplay();
    }

refuseQuest(questId) {
        // ‚úÖ FIX : Comparaison souple ==
        const index = this.quests.findIndex(q => q.id == questId);
        if (index === -1) return;
        
        const quest = this.quests[index];
        this.quests.splice(index, 1);
        
        logMessage("‚ùå Qu√™te refus√©e : " + quest.title);
        this.updateQuestsDisplay();
    }

abandonQuest(questId) {
        // ‚úÖ FIX : Comparaison souple ==
        const index = this.quests.findIndex(q => q.id == questId);
        if (index === -1) return;
        
        const quest = this.quests[index];
        
        if (!quest.accepted || quest.completed) {
            logMessage("‚ùå Impossible d'abandonner cette qu√™te !");
            return;
        }
        
        if (!confirm(`√ätes-vous s√ªr de vouloir abandonner la qu√™te "${quest.title}" ?\nVotre progression sera perdue.`)) {
            return;
        }
        
        this.quests.splice(index, 1);
        
        logMessage("‚ùå Qu√™te abandonn√©e : " + quest.title);
        this.updateQuestsDisplay();
    }



// ========== CORRECTION DE showQuestCompletionModal() EXISTANTE ==========

showQuestCompletionModal(quest) {
    // Si une simulation est en cours, on ne montre pas la fen√™tre tout de suite pour √©viter les bugs
    if (typeof window.logMessage !== 'function' || window.logMessage.toString() === 'function() {}') {
        console.log("Affichage de la modal de qu√™te report√© (simulation en cours).");
        logMessage("üéâ Qu√™te termin√©e : " + quest.title + " ! R√©cup√©rez la r√©compense dans l'onglet Qu√™tes.");
        return;
    }

    console.log("Modal ouverte pour:", quest.title);
    
    const modal = document.getElementById('questCompletionModal');
    const infoDiv = document.getElementById('questCompletionInfo');
    const rewardsDiv = document.getElementById('questCompletionRewards');
    const claimBtn = document.getElementById('claimQuestBtn');

    if (!modal || !infoDiv || !rewardsDiv || !claimBtn) {
        console.error("Impossible de trouver les √©l√©ments de la modal de qu√™te !");
        return;
    }
    
    // --- Partie 1 : Remplir les informations ---
    infoDiv.innerHTML = `<h3 style="color: #333; margin-bottom: 10px;">${quest.title}</h3>
                         <p style="color: #666;">${quest.description}</p>`;
    
    let rewardsHTML = '';
    
    // ‚úÖ V√âRIFIER que rewards existe
    if (quest.rewards) {
        if (quest.rewards.pokedollars && quest.rewards.pokedollars > 0) {
            rewardsHTML += `<div class="quest-completion-reward">üí∞ ${formatNumber(quest.rewards.pokedollars)} Pok√©dollars</div>`;
        }
        if (quest.rewards.tokens && quest.rewards.tokens > 0) {
            rewardsHTML += `<div class="quest-completion-reward">üé´ ${quest.rewards.tokens} Jetons de Qu√™tes</div>`;
        }
        
        // ‚úÖ V√âRIFIER que eggs existe
        if (quest.rewards.eggs && typeof quest.rewards.eggs === 'object') {
            Object.entries(quest.rewards.eggs).forEach(([rarity, count]) => {
                if (count > 0) {
                    rewardsHTML += `<div class="quest-completion-reward">ü•ö ${count}x ≈íuf ${rarity}</div>`;
                }
            });
        }
        
        // ‚úÖ V√âRIFIER que boosts existe et est un array (ancien format)
        if (quest.rewards.boosts && Array.isArray(quest.rewards.boosts)) {
            quest.rewards.boosts.forEach(boost => {
                const boostNames = { xp: 'XP', money: 'Pok√©dollars', eggDrop: 'Drop ≈íufs' };
                const duration = Math.floor(boost.duration / 60000);
                rewardsHTML += `<div class="quest-completion-reward">‚ö° +${(boost.value * 100)}% ${boostNames[boost.type]} (${duration}min)</div>`;
            });
        }
    }
    
    rewardsDiv.innerHTML = rewardsHTML;

    // --- Partie 2 : Logique pour faire fonctionner le bouton ---
    
    // On stocke la qu√™te en attente pour savoir laquelle r√©clamer
    this.pendingQuestReward = quest;
    
    // On affiche la fen√™tre
    modal.classList.add('show');
    
    // On attache l'√©v√©nement de clic de mani√®re s√©curis√©e pour √©viter les doublons
    const newBtn = claimBtn.cloneNode(true);
    claimBtn.parentNode.replaceChild(newBtn, claimBtn);
    
    newBtn.addEventListener('click', () => {
        this.claimQuestReward();
    });
    
    logMessage("üéâ Qu√™te termin√©e : " + quest.title + " !");
}

// LOGIQUE : R√©cup√©ration des r√©compenses (CORRIG√âE : Ajout des Items)
    claimQuestReward() {
        if (!this.pendingQuestReward) return;
        
        const quest = this.pendingQuestReward;
        
        // 1. Distribution des R√©compenses
        if (quest.rewards) {
            // Argent
            if (quest.rewards.pokedollars && quest.rewards.pokedollars > 0) {
                this.pokedollars += quest.rewards.pokedollars;
                this.checkSpecialQuests('pokedollars_gained');
                this.checkAchievements('totalPokedollarsEarned');
				this.showUiFloatingText('headerStatMoney', `+${formatNumber(quest.rewards.pokedollars)}$`, 'ft-money');
        }
            
            
            // Jetons
            if (quest.rewards.tokens && quest.rewards.tokens > 0) {
                this.questTokens = (this.questTokens || 0) + quest.rewards.tokens;
				this.showUiFloatingText('headerStatTokens', `+${quest.rewards.tokens}üé´`, 'ft-token');
        }
            
            
            // ≈íufs
            if (quest.rewards.eggs) {
                Object.entries(quest.rewards.eggs).forEach(([rarity, count]) => {
                    if (count > 0) this.eggs[rarity] = (this.eggs[rarity] || 0) + count;
                });
            }
            
            // Boosts
            if (quest.rewards.boosts && Array.isArray(quest.rewards.boosts)) {
                quest.rewards.boosts.forEach(boost => this.addBoost(boost));
            }

            // ‚úÖ LE FIX EST ICI : GESTION DES OBJETS (CANNES, SURF, BALLS...)
            if (quest.rewards.items) {
                Object.entries(quest.rewards.items).forEach(([itemKey, count]) => {
                    // On utilise addItem qui g√®re d√©j√† le log et l'ajout √† l'inventaire
                    this.addItem(itemKey, count);
                });
            }
        }
        
        this.questsCompleted = (this.questsCompleted || 0) + 1;
        
        // 2. Nettoyage
        quest.claimed = true;
        const index = this.quests.findIndex(q => q.id === quest.id);
        if (index !== -1) {
            this.quests.splice(index, 1);
        }
        
        this.pendingQuestReward = null;
        
        // 3. Fermeture Modal
        const modal = document.getElementById('questCompletionModal');
        if (modal) modal.classList.remove('show');
        
        // 4. Mises √† jour UI
        this.updateQuestsDisplay();
        this.updateEggsDisplay();
        this.updatePlayerStatsDisplay();
        this.updateShopDisplay();
        this.updateItemsDisplay(); // Important pour voir la canne appara√Ætre
        
        // Mise √† jour imm√©diate des zones (pour afficher Magicarpe si on vient d'avoir la canne)
        if (typeof updateZoneInfo === 'function') updateZoneInfo();
    }

toggleCaptureMode() {
        this.captureModeEnabled = !this.captureModeEnabled;
        this.updateCaptureButtonDisplay();
    }

    updateCaptureButtonDisplay() {
        const btn = document.getElementById('captureModeBtn');
        const select = document.getElementById('captureTargetSelect');
        
        // --- DEBUGGING ---
        console.log("üîÑ Mise √† jour visuelle. Mode:", this.captureMode);
        
        if (!btn) {
            console.error("‚ùå ERREUR CRITIQUE : Le bouton avec l'ID 'captureModeBtn' est introuvable dans le HTML !");
            return;
        }
        // -----------------

        // Reset des styles pour √©viter les conflits
        btn.className = 'auto-select-btn'; // On garde la classe de base
        
        if (this.captureMode === 0) {
            // OFF (Gris)
            btn.textContent = "üï∏Ô∏è Capture : OFF";
            btn.style.background = "#e0e0e0";
            btn.style.color = "#666";
            btn.style.borderColor = "#ccc";
            if(select) select.style.display = 'none';
        } 
        else if (this.captureMode === 1) {
            // TOUS (Rouge)
            btn.textContent = "üï∏Ô∏è Capture : TOUS";
            btn.style.background = "linear-gradient(135deg, #ff6b6b, #ee5253)";
            btn.style.color = "white";
            btn.style.borderColor = "#ff6b6b";
            if(select) select.style.display = 'none';
        } 
        else if (this.captureMode === 2) {
            // CIBLE (Bleu)
            btn.textContent = "üéØ Capture : CIBLE";
            btn.style.background = "linear-gradient(135deg, #3b82f6, #2563eb)";
            btn.style.color = "white";
            btn.style.borderColor = "#3b82f6";
            if(select) select.style.display = 'block';
        }
    }

addBoost(boost) {
    const boostObj = {
        type: boost.type,
        value: boost.value,
        endTime: Date.now() + boost.duration
    };
    
    this.activeBoosts.push(boostObj);
    
    const boostNames = { xp: 'XP', money: 'Pok√©dollars', eggDrop: 'Drop ≈íufs', shiny: 'Shiny' };
    logMessage("‚ö° Boost activ√© : +" + (boost.value * 100) + "% " + boostNames[boost.type] + " !");
    
    this.updateBoostsDisplay();
}

// LOGIQUE : Tenter de faire appara√Ætre un Roamer pour le prochain combat
    rollRoamingEncounter() {
        // 1. Conditions : Pas en Tour, Pas en Ar√®ne
        if (this.towerState.isActive || this.arenaState.active) return;

        // 2. Probabilit√© (0.5% soit 1 chance sur 200 par combat)
        // Tu peux ajuster ce taux (ex: 0.002 pour 1/500)
        const roamingChance = 0.0005; 

        if (Math.random() < roamingChance) {
            // 3. Choix du Roamer
            const name = ROAMING_POKEMON[Math.floor(Math.random() * ROAMING_POKEMON.length)];
            
            // 4. On stocke l'info pour le prochain startCombat
            this.pendingRoamer = name;
            
            // 5. HYPE : On pr√©vient le joueur !
            toast.legendary("‚ö†Ô∏è ALERTE", `Une pr√©sence l√©gendaire approche... (${name})`);
            logMessage(`‚ö° L'air devient √©lectrique... Quelque chose approche !`);
        }
    }
	
updateBoosts() {
    const now = Date.now();
    const expiredBoosts = [];
    
    this.activeBoosts = this.activeBoosts.filter((boost, index) => {
        if (boost.endTime <= now) {
            expiredBoosts.push(boost);
            return false;
        }
        return true;
    });
    
    if (expiredBoosts.length > 0) {
        this.updateBoostsDisplay();
    }
}

openSynergyListModal() {
    const modal = document.getElementById('synergyListModal');
    const container = document.getElementById('synergyListContent');
    if (!modal || !container) return;

    const typeCounts = {};
    this.playerTeam.forEach(c => {
        typeCounts[c.type] = (typeCounts[c.type] || 0) + 1;
        if (c.secondaryType) {
            typeCounts[c.secondaryType] = (typeCounts[c.secondaryType] || 0) + 1;
        }
    });

    let html = '';

    // Dictionnaire d'ic√¥nes "Sprite" pour le texte (On garde ceux-l√† pour les pr√©requis)
    const typeIcons = {
        fire: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/fire.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        water: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/water.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        grass: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/grass.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        electric: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/electric.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        normal: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/normal.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        flying: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/flying.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        bug: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/bug.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        poison: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/poison.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        ground: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/ground.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        rock: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/rock.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        fighting: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/fighting.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        psychic: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/psychic.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        ghost: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/ghost.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        ice: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/ice.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        dragon: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/dragon.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        steel: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/steel.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        dark: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/dark.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">',
        fairy: '<img src="https://raw.githubusercontent.com/msikma/pokesprite/master/misc/types/gen8/fairy.png" class="type-icon-img" style="vertical-align:middle; width:16px; height:16px;">'
    };

    const sortedSynergies = Object.values(TEAM_SYNERGIES).sort((a, b) => {
        const checkActive = (syn) => {
            if (syn.all_required) return syn.types.every(t => (typeCounts[t] || 0) >= syn.min_count);
            return syn.types.some(t => (typeCounts[t] || 0) >= syn.min_count);
        };
        return (checkActive(b) ? 1 : 0) - (checkActive(a) ? 1 : 0);
    });

    sortedSynergies.forEach(synergy => {
        let progressHTML = "";
        let progressPercent = 0;
        let isActive = false;

        if (synergy.all_required) {
            let totalReq = synergy.types.length * synergy.min_count;
            let totalCur = synergy.types.reduce((sum, t) => sum + Math.min(typeCounts[t]||0, synergy.min_count), 0);
            progressPercent = (totalCur / totalReq) * 100;
            isActive = progressPercent >= 100;

            const parts = synergy.types.map(t => {
                const cur = typeCounts[t] || 0;
                const req = synergy.min_count;
                const color = cur >= req ? "#16a34a" : "#64748b";
                return `<span style="color:${color}; white-space:nowrap; display:inline-flex; align-items:center; gap:2px;">${typeIcons[t] || ''} ${cur}/${req}</span>`;
            });
            progressHTML = parts.join(' <span style="font-size:10px; color:#ccc;">+</span> ');

        } else {
            let currentMax = 0;
            synergy.types.forEach(t => {
                const count = typeCounts[t] || 0;
                if (count > currentMax) currentMax = count;
            });
            const displayCount = Math.min(currentMax, synergy.min_count);
            isActive = currentMax >= synergy.min_count;
            progressPercent = (displayCount / synergy.min_count) * 100;
            
            progressHTML = `<span>${displayCount} / ${synergy.min_count} Pok√©mon</span>`;
        }

        // --- ‚ùå SUPPRESSION DE LA VARIABLE ICONE ICI ---

        let shortDesc = synergy.message.split('!')[1] || synergy.message;
        shortDesc = shortDesc.replace(/[()]/g, '').trim();
        
        const separator = synergy.all_required ? ' ET ' : ' OU ';
        const reqString = synergy.types.map(t => `${typeIcons[t]||''} ${t.toUpperCase()}`).join(separator);
        const tooltipTitle = synergy.name;
        const tooltipDesc = `Requis : ${synergy.min_count}x (${reqString})<br><br>Effet : ${shortDesc}`;
        
        const safeTitle = tooltipTitle.replace(/'/g, "\\'");
        const safeDesc = tooltipDesc
            .replace(/'/g, "\\'")
            .replace(/"/g, "&quot;")
            .replace(/\n/g, "<br>");

        html += `
            <div class="synergy-list-card ${isActive ? 'active' : ''}"
                 onmouseenter="game.scheduleTooltip(event, '${safeTitle}', '${safeDesc}')"
                 onmouseleave="game.hideTooltip()">
                 
                <div class="synergy-list-info">
                    <div class="synergy-list-title">
                        ${synergy.name}
                        ${isActive ? '‚úÖ' : ''}
                    </div>
                    <div class="synergy-list-desc">${shortDesc}</div>
                    
                    <div class="synergy-progress" style="margin-top:5px; font-size:11px; line-height:1.5;">
                        ${progressHTML}
                    </div>
                    
                    <div style="width: 100%; height: 4px; background: #e5e7eb; border-radius: 2px; margin-top: 4px; overflow:hidden;">
                        <div style="width: ${progressPercent}%; height: 100%; background: ${isActive ? '#22c55e' : '#9ca3af'}; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
    modal.classList.add('show');
}
	
updateBoostsDisplay() {
    const boostsDiv = document.getElementById('activeBoosts');
    const boostsList = document.getElementById('boostsList');
    
    if (this.activeBoosts.length === 0) {
        boostsDiv.style.display = 'none';
        return;
    }
    
    boostsDiv.style.display = 'block';
    boostsList.innerHTML = '';
    
    const boostNames = { xp: 'XP', money: 'Pok√©dollars', eggDrop: 'Drop ≈íufs', shiny: 'Shiny' };
    
    this.activeBoosts.forEach(boost => {
        const timeLeft = boost.endTime - Date.now();
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        
        const boostItem = document.createElement('div');
        boostItem.className = 'boost-item';
        boostItem.innerHTML = `
            <span class="boost-name">‚ö° +${(boost.value * 100)}% ${boostNames[boost.type]}</span>
            <span class="boost-timer">${minutes}:${seconds < 10 ? '0' : ''}${seconds}</span>
        `;
        boostsList.appendChild(boostItem);
    });
}


/**
     * Met √† jour l'affichage du Recycleur (avec DEBUGGING)
     */
    updateRecyclerDisplay() {
        
        const shardListDiv = document.getElementById('recyclerShardList');
        const shopDiv = document.getElementById('recyclerDustShop');
        const dustCountSpan = document.getElementById('essenceDustCount');

        if (!shardListDiv || !shopDiv || !dustCountSpan) {
            console.error("ERREUR DEBUG RECYCLEUR : Un des √©l√©ments HTML est introuvable !");
            return;
        }

        dustCountSpan.textContent = formatNumber(this.essenceDust);

        shardListDiv.innerHTML = '<div class="recycler-header">Vos Shards</div>';
        let shardsFound = 0;
        
        // Fonction d'aide (inchang√©e)
        const getFamilyRarity = (familyName) => {
            try {
                for (const typeKey in POKEMON_POOL[RARITY.COMMON]) {
                    if (POKEMON_POOL[RARITY.COMMON][typeKey].includes(familyName)) {
                        return RARITY.COMMON;
                    }
                }
                for (const typeKey in POKEMON_POOL[RARITY.RARE]) {
                    if (POKEMON_POOL[RARITY.RARE][typeKey].includes(familyName)) {
                        return RARITY.RARE;
                    }
                }
                for (const typeKey in POKEMON_POOL[RARITY.EPIC]) {
                    if (POKEMON_POOL[RARITY.EPIC][typeKey].includes(familyName)) {
                        return RARITY.EPIC;
                    }
                }
                 for (const typeKey in POKEMON_POOL[RARITY.LEGENDARY]) {
                    if (POKEMON_POOL[RARITY.LEGENDARY][typeKey].includes(familyName)) {
                        return RARITY.LEGENDARY;
                    }
                }
            } catch (e) {
                console.error("ERREUR DEBUG RECYCLEUR dans getFamilyRarity:", e);
                return RARITY.COMMON; // Fallback en cas d'erreur
            }
            return RARITY.COMMON;
        };

        

        Object.entries(this.shards).forEach(([shardKey, count]) => {
            
            if (count > 0) {
                shardsFound++;
                
                const familyName = shardKey;
                const rarity = getFamilyRarity(familyName);

                
                
                const dustValue = count * (DUST_CONVERSION_RATES[rarity] || 1);

                shardListDiv.innerHTML += `
                    <div class="recycler-item">
                        <div>
                            <span class="recycler-item-name">${familyName}
                                <span class="rarity-label ${rarity}">${rarity}</span>
                            </span>
                            <div style="font-size: 12px; color: #666;">
                                x${count} ‚ûú üí† ${dustValue}
                            </div>
                        </div>
                        <button class="recycler-btn" onclick="game.recycleShards('${shardKey}', '${rarity}')">
                            Recycler
                        </button>
                    </div>
                `;
            }
        });

        

        if (shardsFound === 0) {
            shardListDiv.innerHTML += '<p style="font-size: 12px; color: #666;">Aucun shard √† recycler.</p>';
        }

        // ... (partie "Boutique de Poussi√®re" inchang√©e) ...
        shopDiv.innerHTML = '<div class="recycler-header">Boutique de Poussi√®re</div>';
        Object.values(DUST_SHOP_ITEMS).forEach(item => {
            if (item.id === 'shiny_egg') return; 

            const canAfford = this.essenceDust >= item.cost;
            shopDiv.innerHTML += `
                <div class="dust-shop-item">
                    <div>
                        <div class="shop-item-name" style="color: #a855f7;">${item.name}</div>
                        <div class="shop-item-description" style="font-size: 11px;">${item.description}</div>
                        <div class="shop-item-cost" style="font-size: 16px; margin: 5px 0 0 0;">üí† ${formatNumber(item.cost)}</div>
                    </div>
                    <button class="btn shop-buy-btn" onclick="game.buyDustItem('${item.id}')" ${!canAfford ? 'disabled' : ''}>
                        Acheter
                    </button>
                </div>
            `;
        });
    }

/**
 * Recycle les shards d'un type en Poussi√®re d'Essence
 */
recycleShards(shardKey, rarity) {
    const count = this.shards[shardKey] || 0;
    if (count === 0) return;

    const rate = DUST_CONVERSION_RATES[rarity] || 1;
    const dustGained = count * rate;

    this.essenceDust += dustGained;
    this.shards[shardKey] = 0;

    logMessage(`‚ôªÔ∏è ${count} Shards de ${shardKey} recycl√©s en üí† ${dustGained} Poussi√®re !`);
    toast.success("Shards Recycl√©s !", `+${dustGained} üí† Poussi√®re d'Essence`);

    this.updateRecyclerDisplay();
    this.updateStorageDisplay(); // Mettre √† jour les compteurs de shards sur les cartes
    this.updateTeamDisplay();
    this.updatePensionDisplay();
}

buyDustItem(itemId) {
        const item = DUST_SHOP_ITEMS[itemId];
        if (!item) return;

        // V√©rification condition sp√©ciale (Badge)
        if (item.requiredBadge && !this.hasBadge(item.requiredBadge)) {
            logMessage(`üîí Verrouill√© ! Vous devez poss√©der le badge : ${ACCOUNT_TALENTS[item.requiredBadge].name}`);
            return;
        }

        // V√©rification si d√©j√† poss√©d√© (Unique)
        if (itemId === 'auto_catcher' && this.hasAutoCatcher) {
            logMessage("Vous poss√©dez d√©j√† ce module !");
            return;
        }

        if (this.essenceDust < item.cost) {
            logMessage("Pas assez de Poussi√®re d'Essence !");
            return;
        }

        this.essenceDust -= item.cost;

        // Effets
        if (itemId === 'talent_reroll') {
            this.talentRerolls++;
            logMessage(`üîÆ Achat : Cristal (+1). Total: ${this.talentRerolls}`);
        } 
        else if (itemId === 'talent_choice') {
            this.talentChoices++;
            logMessage(`üåü Achat : Orbe (+1). Total: ${this.talentChoices}`);
        }
        else if (itemId === 'auto_catcher') {
            this.hasAutoCatcher = true;
            toast.legendary("SYST√àME UPGRADE", "Module Porygon-Z install√© ! Configurez-le dans le menu Extras.");
            logMessage("ü§ñ Module Auto-Catch activ√© !");
            this.updateAutoCatcherUI(); // On cr√©e cette fonction juste apr√®s
        }

        this.updateRecyclerDisplay();
        this.updatePlayerStatsDisplay(); // Pour mettre √† jour l'affichage si besoin
    }



updateExpeditionsDisplay() {
    // 1. Slots
    const slotsUI = document.getElementById('expeditionSlots');
    if (slotsUI) {
        slotsUI.textContent = `${this.activeExpeditions.length}/${this.maxExpeditionSlots}`;
    }

    // 2. Liste Disponible
    if (typeof this.updateAvailableExpeditionsList === 'function') {
        this.updateAvailableExpeditionsList();
    }

    // 3. Liste Active
    const activeContainer = document.getElementById('activeExpeditionsContainer');
    if (!activeContainer) return;

    activeContainer.innerHTML = '';

    if (this.activeExpeditions.length === 0) {
        activeContainer.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px; font-style: italic; border: 2px dashed #e2e8f0; border-radius: 10px;">Aucune exp√©dition en cours...</p>';
        return;
    }

    const now = Date.now();

    this.activeExpeditions.forEach((exp, index) => {
        const expeditionDef = EXPEDITION_DEFINITIONS[exp.expeditionId];
        if (!expeditionDef) return; // Ignore si la mission n'existe plus

        // --- S√âCURISATION DES DONN√âES ---
        let creatureName = "Inconnu";
        let spriteUrl = "";
        let levelText = "";

        try {
            if (exp.squadData && exp.squadData.length > 0) {
                // CAS ESCOUADE
                const leaderData = exp.squadData[0];
                if (!leaderData) throw new Error("Donn√©es Leader manquantes"); // S√©curit√©

                const leader = Creature.deserialize(leaderData);
                creatureName = leader.name;
                levelText = `(Niv ${leader.level})`;
                spriteUrl = getPokemonSpriteUrl(leader.name, leader.isShiny);
                
                if (exp.squadData.length > 1) {
                    creatureName += ` +${exp.squadData.length - 1}`;
                }
            } else if (exp.creatureData) {
                // CAS SOLO (Ancien format)
                const creature = Creature.deserialize(exp.creatureData);
                creatureName = creature.name;
                levelText = `(Niv ${creature.level})`;
                spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny);
            } else {
                // DONN√âES CORROMPUES -> On ignore cet affichage pour ne pas planter
                console.warn("Exp√©dition corrompue ignor√©e (index " + index + ")");
                return;
            }
        } catch (e) {
            console.error("Erreur affichage exp√©dition:", e);
            return; // On saute cet √©l√©ment qui plante
        }
        // --------------------------------

        const card = document.createElement('div');
        const timeLeft = exp.endTime - now;
        let statusClass = '';
        let actionHTML = '';
        let progressHTML = '';

        if (timeLeft > 0) {
            // EN COURS
            statusClass = 'accepted';
            const { hours, minutes, seconds } = formatTime(timeLeft);
            const totalDuration = expeditionDef.duration;
            const elapsed = totalDuration - timeLeft;
            const percent = Math.min(100, (elapsed / totalDuration) * 100);

            progressHTML = `
                <div class="quest-progress-container" style="margin: 10px 0;">
                    <div class="quest-progress-bar">
                        <div class="quest-progress-fill" style="width: ${percent}%"></div>
                    </div>
                    <div class="quest-progress-text" style="font-size:10px; color:#64748b;">Reste: ${hours}h ${minutes}m ${seconds}s</div>
                </div>
            `;

            actionHTML = `<button class="quest-btn" disabled style="background: #cbd5e1; color: #64748b; cursor: wait; width:100%;">
                ‚è≥ En cours...
            </button>`;
        } else {
            // TERMIN√âE
            statusClass = 'completed';
            progressHTML = `
                <div class="quest-progress-container" style="margin: 10px 0;">
                    <div class="quest-progress-bar">
                        <div class="quest-progress-fill" style="width: 100%; background: #22c55e;"></div>
                    </div>
                    <div class="quest-progress-text" style="color:#22c55e; font-weight:bold;">Termin√©e !</div>
                </div>
            `;

            actionHTML = `<button class="quest-btn quest-btn-claim" onclick="game.claimExpedition(${index})">
                üéÅ R√©cup√©rer les r√©compenses
            </button>`;
        }

        card.className = `quest-card ${statusClass}`;
        
        card.innerHTML = `
            <div class="quest-header">
                <div class="quest-title" style="display:flex; align-items:center; gap:10px;">
                    <img src="${spriteUrl}" style="width:32px; height:32px; vertical-align:middle;">
                    <span>${expeditionDef.name}</span>
                </div>
            </div>
            <div class="quest-description">
                <strong>${creatureName}</strong> ${levelText} explorent cette zone.
            </div>
            ${progressHTML}
            ${actionHTML}
        `;
        
        activeContainer.appendChild(card);
    });
}
// AJOUTER DANS LA CLASSE GAME

// AJOUTER DANS LA CLASSE GAME

// Dans la classe Game

updateAvailableExpeditionsList() {
    const container = document.getElementById('availableExpeditionsList');
    if (!container) return;

    container.innerHTML = '';

    // (Affichage du timer inchang√©...)
    if (this.availableExpeditions.length < this.maxAvailableExpeditions) {
        const minutes = Math.floor(this.expeditionTimer / 60000);
        const seconds = Math.floor((this.expeditionTimer % 60000) / 1000);
        container.innerHTML = `<div style="text-align:center; font-size:12px; color:#666; margin-bottom:10px;">
            Prochaine mission dans : <strong>${minutes}m ${seconds}s</strong>
        </div>`;
    } else {
        container.innerHTML = `<div style="text-align:center; font-size:12px; color:#e74c3c; margin-bottom:10px;">
            Tableau des missions complet ! (6/6)
        </div>`;
    }

    if (this.availableExpeditions.length === 0) {
        container.innerHTML += '<p style="text-align:center; color:#999;">Aucune mission disponible.</p>';
        return;
    }

    this.availableExpeditions.forEach(inst => {
        const exp = EXPEDITION_DEFINITIONS[inst.defId];
        if (!exp) return;

        const card = document.createElement('div');
        card.className = 'quest-card';
        
        // Loot icons (inchang√©)
        let lootIcons = "";
        if (exp.rewardPool.items) {
            lootIcons = Object.keys(exp.rewardPool.items)
                .map(k => ALL_ITEMS[k] ? ALL_ITEMS[k].icon : 'üì¶')
                .slice(0, 3).join(' ');
        }

        // --- NOUVEAU BLOC D'AFFICHAGE DES REQUIS ---
        let reqText = "";
        if (exp.rewardPool.requirements && exp.rewardPool.requirements.length > 0) {
            const badges = exp.rewardPool.requirements.map(req => {
                if (req.type === 'type') {
                    // Badge de type color√©
                    return `<span class="type-badge type-${req.value}" style="font-size:10px; padding:2px 6px;">${req.value}</span>`;
                }
                if (req.type === 'talent') {
                    // Badge gris pour le talent
                    // On essaie de trouver le nom propre du talent
                    const talentName = PASSIVE_TALENTS[req.value] ? PASSIVE_TALENTS[req.value].name : req.value;
                    return `<span style="background:#4b5563; color:white; border-radius:4px; padding:2px 6px; font-size:10px;">‚òÖ ${talentName}</span>`;
                }
                return '';
            }).join(' ');
            
            reqText = `<div style="margin-top:8px; display:flex; align-items:center; gap:5px; flex-wrap:wrap;">
                <span style="font-size:11px; font-weight:bold; color:#333;">Requis:</span> ${badges}
            </div>`;
        }
        // -------------------------------------------

        const canLaunch = this.activeExpeditions.length < this.maxExpeditionSlots;

        card.innerHTML = `
            <div class="quest-header">
                <div class="quest-title">${exp.name}</div>
                <div class="quest-badge badge-medium">Nv ${exp.requiredLevel}+</div>
            </div>
            <div class="quest-description">
                ${exp.description}
                ${reqText}
            </div>
            <div class="quest-rewards" style="justify-content: space-between; margin-top:5px;">
                <span style="font-size:12px; color:#666;">üïí ${formatTimeString(exp.duration)}</span>
                <span>${lootIcons}</span>
            </div>
            <button class="quest-btn btn-accept" 
                onclick="game.showCreatureSelectForExpedition('${inst.uid}', '${inst.defId}')"
                ${canLaunch ? '' : 'disabled style="background:#ccc; cursor:not-allowed;"'}>
                ${canLaunch ? 'Choisir une √©quipe' : 'Actifs (3/3)'}
            </button>
        `;
        
        container.appendChild(card);
    });
}
// Dans la classe Game

showMasteryModal() {
    const modal = document.getElementById('masteryModal');
    const grid = document.getElementById('masteryListGrid');
    if (!modal || !grid) return;

    grid.innerHTML = '';

    // 1. V√©rification de s√©curit√© (si l'objet n'existe pas encore)
    if (!this.expeditionMastery) this.expeditionMastery = {};

    // 2. Parcourir tous les biomes d√©finis
    Object.keys(BIOME_DISPLAY).forEach(biomeKey => {
        const xp = this.expeditionMastery[biomeKey] || 0;
        const displayInfo = BIOME_DISPLAY[biomeKey];

        // 3. Calculer le niveau actuel
        let currentLevel = 1;
        let nextLevelXP = BIOME_MASTERY_LEVELS[2].xpRequired;
        let prevLevelXP = 0;
        let bonusDesc = "Aucun bonus";

        // On cherche le niveau le plus haut atteint
        for (let lvl = 5; lvl >= 1; lvl--) {
            if (xp >= BIOME_MASTERY_LEVELS[lvl].xpRequired) {
                currentLevel = lvl;
                bonusDesc = BIOME_MASTERY_LEVELS[lvl].desc;
                
                // D√©finir les bornes pour la barre de progression
                if (lvl < 5) {
                    prevLevelXP = BIOME_MASTERY_LEVELS[lvl].xpRequired;
                    nextLevelXP = BIOME_MASTERY_LEVELS[lvl + 1].xpRequired;
                } else {
                    // Niveau Max
                    prevLevelXP = BIOME_MASTERY_LEVELS[5].xpRequired;
                    nextLevelXP = xp; // Barre pleine
                }
                break;
            }
        }

        // 4. Calcul du pourcentage
        let percent = 0;
        if (currentLevel < 5) {
            percent = ((xp - prevLevelXP) / (nextLevelXP - prevLevelXP)) * 100;
        } else {
            percent = 100; // Max
        }

        // 5. Cr√©ation de la carte
        const card = document.createElement('div');
        card.style.cssText = `
            background: #f8f9fa; border: 1px solid #e2e8f0; border-radius: 10px; 
            padding: 15px; display: flex; align-items: center; gap: 15px; margin-bottom:10px;
        `;

        card.innerHTML = `
            <div style="font-size: 32px; background:white; width:50px; height:50px; display:flex; align-items:center; justify-content:center; border-radius:50%; box-shadow:0 2px 5px rgba(0,0,0,0.1);">
                ${displayInfo.icon}
            </div>
            
            <div style="flex: 1;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                    <strong style="font-size:16px; color:#333;">${displayInfo.name}</strong>
                    <span style="font-size:12px; font-weight:bold; color:#8b5cf6;">Niveau ${currentLevel}</span>
                </div>
                
                <div style="width: 100%; height: 8px; background: #ddd; border-radius: 4px; overflow: hidden; margin-bottom: 5px;">
                    <div style="width: ${percent}%; height: 100%; background: linear-gradient(90deg, #8b5cf6, #6d28d9); transition: width 0.3s;"></div>
                </div>
                
                <div style="display:flex; justify-content:space-between; font-size:11px; color:#666;">
                    <span>XP: ${xp} / ${currentLevel < 5 ? nextLevelXP : 'MAX'}</span>
                    <span style="color:#16a34a; font-weight:bold;">${bonusDesc}</span>
                </div>
            </div>
        `;

        grid.appendChild(card);
    });

    modal.classList.add('show');
}
showCreatureSelectForExpedition(expeditionUid, expeditionId) {
    const expeditionDef = EXPEDITION_DEFINITIONS[expeditionId];
    if (!expeditionDef) return;

    this.tempSquad = []; 
    const teamSize = expeditionDef.teamSize || 1;

    // 1. Filtrer et Trier (Code inchang√©)
    const candidates = this.storage.map((creature, index) => {
        const meetsReqs = this.meetsExpeditionRequirements(creature, expeditionDef);
        return {
            creature: creature,
            index: index,
            individualScore: this.calculateIndividualScore(creature, expeditionDef),
            compatible: creature.level >= expeditionDef.requiredLevel && creature.currentStamina > 0 && meetsReqs
        };
    }).filter(c => c.compatible);

    candidates.sort((a, b) => b.individualScore - a.individualScore);

    // 2. Nettoyage de s√©curit√©
    const existingModal = document.getElementById('creatureSelectModal');
    if (existingModal) document.body.removeChild(existingModal);

    // 3. Construction du Modal
    const modal = document.createElement('div');
    modal.id = 'creatureSelectModal';
    modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000;`;

    // ‚úÖ AJOUT : Fermer en cliquant sur le fond noir
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    const content = document.createElement('div');
    content.style.cssText = `background: white; padding: 20px; border-radius: 15px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative;`;

    let html = `<h3 style="margin-top:0; color:#333;">${expeditionDef.name}</h3>`;
    html += `<p style="color:#666; font-size:12px;">S√©lectionnez <strong><span id="squadCount">0</span>/${teamSize}</strong> Pok√©mon.</p>`;
    
    // Zone de liste
    html += `<div id="squadList" style="display:grid; gap:10px; padding-bottom: 80px;">`; 
    
    if (candidates.length === 0) {
        let reqsHTML = "Aucune restriction";
        if (expeditionDef.rewardPool.requirements) {
            reqsHTML = expeditionDef.rewardPool.requirements.map(r => {
                if (r.type === 'type') return `Type <strong>${r.value}</strong>`;
                if (r.type === 'talent') return `Talent <strong>${r.value}</strong>`;
                return '';
            }).join(" OU ");
        }
        html += `<div style="text-align:center; padding:20px; color:#ef4444;">Aucun Pok√©mon compatible.<br><small>${reqsHTML}</small></div>`;
    } else {
        candidates.forEach(cand => {
            const c = cand.creature;
            const spriteUrl = getPokemonSpriteUrl(c.name, c.isShiny);
            const divId = `cand-${cand.index}`;

            html += `
                <div id="${divId}" 
                     onclick="game.toggleSquadSelection(${cand.index}, ${teamSize}, '${divId}', '${expeditionId}')" 
                     style="display:flex; align-items:center; gap:10px; padding:10px; border:1px solid #e2e8f0; border-radius:8px; cursor:pointer; transition:0.2s; background:white;">
                    
                    <img src="${spriteUrl}" style="width:48px; height:48px;">
                    
                    <div style="flex:1;">
                        <div style="font-weight:bold; font-size:14px;">${c.name} <span style="font-size:11px; color:#666;">Niv.${c.level}</span></div>
                        <div style="font-size:11px; color:#666;">Puissance: ${formatNumber(cand.individualScore)}</div>
                    </div>
                </div>
            `;
        });
    }
    html += `</div>`;

    // Footer avec bouton lancer
    html += `
        <div id="launchButtonContainer" class="squad-counter" style="display:flex; justify-content:space-between; width:90%; max-width:400px;">
            <div style="display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#ccc;">CHANCES DE R√âUSSITE</span>
                <span id="squadSuccessText" style="font-weight:bold; font-size:16px; color:#ef4444;">0%</span>
            </div>
            <button id="btnLaunchExpedition" class="btn" disabled 
                style="background:#ccc; color:white; border:none; padding:8px 20px; border-radius:20px; font-weight:bold; transition:0.3s;"
                onclick="game.finalizeSquadStart('${expeditionUid}', '${expeditionId}')">
                S√âLECTIONNER (${teamSize})
            </button>
        </div>
    `;

    // Bouton Annuler en bas
    html += `<button onclick="document.body.removeChild(document.getElementById('creatureSelectModal'))" 
             style="width:100%; padding:12px; margin-top:10px; background:#f1f5f9; color:#64748b; border:none; border-radius:8px; cursor:pointer;">
             Annuler
             </button>`;

    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);
}

/**
 * Tente de changer de cr√©ature automatiquement si l'option est activ√©e.
 */
triggerAutoSelect() {
    if (this.autoSelectEnabled && this.currentEnemy) {
        const bestIndex = this.findBestCreatureForEnemy();
        if (bestIndex !== -1 && bestIndex !== this.activeCreatureIndex) {
            this.setActiveCreature(bestIndex);
        }
    }
}

/**
     * Calcule et met √† jour la stat this.stats.teamPower.
     * Cette valeur est le SUM des stats de combat de toutes les cr√©atures actives.
     * @returns {number} La nouvelle puissance totale de l'√©quipe.
     */
    updateTeamPowerStat() {
        // La puissance totale est la somme de (HP + Attaque + D√©fense + Vitesse) de chaque membre
        const currentPower = this.playerTeam.reduce((sum, creature) => {
            // Assurez-vous que les cr√©atures ont leurs stats recalcul√©es (maxHp, attack, defense, speed)
            return sum + creature.maxHp + creature.attack + creature.defense + creature.speed;
        }, 0);

        // Mettre √† jour la stat centrale
        this.stats.teamPower = currentPower;

        // D√©clencher la v√©rification des succ√®s li√©s √† cette stat
        this.checkAchievements('teamPower');
        
        return currentPower;
    }

/**
 * G√®re le clic sur un Pok√©mon (S√©lection/D√©s√©lection) et met √† jour le pourcentage.
 */
toggleSquadSelection(storageIndex, maxSize, divId, expeditionId) {
    const div = document.getElementById(divId);
    if (!div) return;

    const indexInSquad = this.tempSquad.indexOf(storageIndex);

    // 1. Logique Ajout / Retrait
    if (indexInSquad === -1) {
        if (this.tempSquad.length >= maxSize) {
            if (typeof toast !== 'undefined') toast.warning("√âquipe compl√®te", `Max ${maxSize} Pok√©mon.`);
            return;
        }
        this.tempSquad.push(storageIndex);
        div.classList.add('squad-selected');
    } else {
        this.tempSquad.splice(indexInSquad, 1);
        div.classList.remove('squad-selected');
    }

    // 2. Mise √† jour des compteurs
    const countSpan = document.getElementById('squadCount');
    if (countSpan) countSpan.textContent = this.tempSquad.length;

    // 3. ‚úÖ CALCUL DU POURCENTAGE EN TEMPS R√âEL
    const expeditionDef = EXPEDITION_DEFINITIONS[expeditionId];
    let currentRate = 0;

    if (this.tempSquad.length > 0 && expeditionDef) {
        // On reconstitue l'escouade temporaire avec les objets Cr√©ature
        const tempCreatures = this.tempSquad.map(idx => this.storage[idx]);
        currentRate = this.calculateTeamSuccessRate(tempCreatures, expeditionDef);
    }

    // 4. Mise √† jour de l'Affichage du Score
    const successText = document.getElementById('squadSuccessText');
    const percent = Math.floor(currentRate * 100);
    
    if (successText) {
        successText.textContent = `${percent}%`;
        
        // Changement de couleur dynamique
        if (percent >= 100) successText.style.color = "#22c55e"; // Vert
        else if (percent >= 70) successText.style.color = "#f59e0b"; // Orange
        else successText.style.color = "#ef4444"; // Rouge
    }

    // 5. Gestion du Bouton Lancer
    const btnLaunch = document.getElementById('btnLaunchExpedition');
    if (btnLaunch) {
        if (this.tempSquad.length === maxSize) {
            btnLaunch.disabled = false;
            btnLaunch.style.background = "#22c55e";
            btnLaunch.style.cursor = "pointer";
            btnLaunch.textContent = "LANCER !";
        } else {
            btnLaunch.disabled = true;
            btnLaunch.style.background = "#ccc";
            btnLaunch.style.cursor = "not-allowed";
            const remaining = maxSize - this.tempSquad.length;
            btnLaunch.textContent = `CHOISIR ENCORE ${remaining}`;
        }
    }
}

/**
 * Fonction appel√©e par le bouton "LANCER" une fois l'√©quipe compl√®te.
 * Elle ferme le modal et lance l'exp√©dition.
 */
finalizeSquadStart(expeditionUid, expeditionId) {
    if (this.tempSquad.length === 0) return;
    
    // 1. Fermer le modal
    const modal = document.getElementById('creatureSelectModal');
    if (modal) document.body.removeChild(modal);
    
    // 2. Lancer l'exp√©dition avec le tableau d'index
    // Note : startExpedition a √©t√© modifi√©e pr√©c√©demment pour accepter un tableau
    this.startExpedition(this.tempSquad, expeditionUid, expeditionId);
    
    // 3. Reset
    this.tempSquad = [];
}

calculateIndividualScore(creature, expeditionDef) {
    // Le score est simplement la somme des stats
    // Plus besoin de v√©rifier les bonus ici, car seuls les √©ligibles sont calcul√©s
    return creature.maxHp + creature.attack + creature.defense + creature.speed;
}

// Calcule le succ√®s global de l'√©quipe (utilis√© pour le r√©sultat)
calculateTeamSuccessRate(squad, expeditionDef) {
    let totalScore = 0;
    
    squad.forEach(creature => {
        totalScore += this.calculateIndividualScore(creature, expeditionDef);
    });

    // Le score est la somme des puissances vs la difficult√© totale
    let difficulty = expeditionDef.difficulty || 100;
    let successRate = totalScore / difficulty;

    return Math.max(0.1, Math.min(1.5, successRate));
}
/**
 * Affiche le modal de s√©lection d'exp√©dition
 */
showExpeditionSendModal(storageIndex) {
    const creature = this.storage[storageIndex];
    if (!creature) return;

    // 1. Nettoyage de s√©curit√© : Supprimer le modal s'il existe d√©j√†
    const existingModal = document.getElementById('expeditionSendModal');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    // 2. Cr√©ation du modal (Fond sombre)
    const modal = document.createElement('div');
    modal.id = 'expeditionSendModal';
    modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000;`;

    // ‚úÖ LOGIQUE DE FERMETURE (Clic sur le fond uniquement)
    modal.addEventListener('click', function(e) {
        // Si l'√©l√©ment cliqu√© est le fond (modal) lui-m√™me, on ferme
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    });

    // 3. Cr√©ation du contenu (Bo√Æte blanche)
    const content = document.createElement('div');
    content.style.cssText = `background: white; padding: 30px; border-radius: 15px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 0 20px rgba(0,0,0,0.5); position: relative;`;

    // Stats de la cr√©ature pour l'info
    const creatureScore = creature.maxHp + creature.attack + creature.defense + creature.speed;

    let html = `<h2 style="margin-bottom: 10px; color:#333;">Envoyer ${creature.name}</h2>`;
    html += `<div style="margin-bottom:20px; font-size:13px; color:#666;">
                Niveau: <strong>${creature.level}</strong> | 
                Puissance: <strong>${formatNumber(creatureScore)}</strong> | 
                Endurance: <span style="color:${creature.currentStamina > 0 ? '#22c55e' : '#ef4444'}">${creature.currentStamina}/${creature.maxStamina}</span>
             </div>`;
    html += '<div style="display: grid; gap: 10px;">';

    Object.values(EXPEDITION_DEFINITIONS).forEach(exp => {
        const canSend = creature.level >= exp.requiredLevel && creature.currentStamina > 0;
        const duration = formatTimeString(exp.duration);
        
        // Calcul visuel du succ√®s
        const successRate = this.calculateExpeditionSuccessRate(creature, exp);
        const successPercent = Math.min(100, Math.floor(successRate * 100));
        
        // Couleur de la barre de succ√®s
        let barColor = '#ef4444'; // Rouge
        if (successRate >= 1.0) barColor = '#22c55e'; // Vert (100%+)
        else if (successRate >= 1) barColor = '#f59e0b'; // Orange

        let bonusHTML = '';
        if (exp.rewardPool.requirements) { // Correction : requirements au lieu de bonuses
            exp.rewardPool.requirements.forEach(req => {
                let isApplied = false;
                if (req.type === 'type' && (creature.type === req.value || creature.secondaryType === req.value)) isApplied = true;
                if (req.type === 'talent' && creature.passiveTalent === req.value) isApplied = true;

                if (isApplied) {
                    // Affichage simple du bonus
                    const label = req.type === 'type' ? req.value : (PASSIVE_TALENTS[req.value]?.name || req.value);
                    bonusHTML += `<span style="color: #16a34a; font-weight: bold; font-size:11px; margin-right:5px;">‚úì ${label}</span>`;
                }
            });
        }

        // Affichage des items potentiels
        let lootIcons = "";
        if (exp.rewardPool.items) {
            lootIcons = Object.keys(exp.rewardPool.items).map(k => ALL_ITEMS[k] ? ALL_ITEMS[k].icon : 'üì¶').join(' ');
        }

        html += `
            <button 
                onclick="game.startExpedition(${storageIndex}, null, '${exp.id}')"
                style="
                    padding: 12px; background: ${canSend ? '#f8f9fa' : '#e9ecef'};
                    border: 2px solid ${canSend ? '#e2e8f0' : '#ccc'}; border-radius: 10px; 
                    cursor: ${canSend ? 'pointer' : 'not-allowed'}; text-align: left;
                    opacity: ${canSend ? '1' : '1'}; position: relative;
                    transition: all 0.2s;
                "
                onmouseover="this.style.borderColor='#667eea'"
                onmouseout="this.style.borderColor='${canSend ? '#e2e8f0' : '#ccc'}'"
                ${canSend ? '' : 'disabled'}
            >
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <strong style="font-size: 15px; color:#333;">${exp.name}</strong>
                    <span style="font-size: 12px; background:#e2e8f0; padding:2px 6px; border-radius:4px;">üïí ${duration}</span>
                </div>
                
                <div style="font-size: 12px; color: #666; margin: 4px 0;">${exp.description}</div>
                
                <div style="display:flex; align-items:center; gap:10px; margin-top:8px;">
                    <div style="flex-grow:1; height:6px; background:#ddd; border-radius:3px; overflow:hidden;">
                        <div style="width:${successPercent}%; height:100%; background:${barColor};"></div>
                    </div>
                    <span style="font-size:11px; font-weight:bold; color:${barColor}; width:40px; text-align:right;">${successPercent}%</span>
                </div>

                <div style="margin-top: 5px;">${bonusHTML}</div>
                <div style="position:absolute; bottom:10px; right:10px; font-size:14px;">${lootIcons}</div>
            </button>
        `;
    });

    html += `</div><button onclick="document.body.removeChild(document.getElementById('expeditionSendModal'))"
             style="margin-top: 20px; padding: 12px; background: #ef4444; color: white; border: none;
             border-radius: 8px; cursor: pointer; width: 100%; font-weight:bold;">Annuler</button>`;

    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);
}

// ‚úÖ AJOUTER CES DEUX FONCTIONS DANS LA CLASSE GAME

            showBadge(elementId, show) {
                const badge = document.getElementById(elementId);
                if (!badge) return; // Ne plante pas si l'√©l√©ment n'existe pas
                
                // Si on doit l'afficher et qu'il n'y a pas d√©j√† un badge
                if (show && badge.innerHTML === '') {
                    badge.innerHTML = '<div class="notification-badge"></div>';
                } 
                // Si on doit le cacher
                else if (!show) {
                    badge.innerHTML = '';
                }
            }

            updateExtrasBadge() {
                // V√©rifie si N'IMPORTE QUEL onglet a un badge
                const questBadge = document.getElementById('questsTabBadge')?.innerHTML !== '';
                const expBadge = document.getElementById('expeditionsTabBadge')?.innerHTML !== '';
                
                // Met √† jour le badge principal sur "Extras"
                this.showBadge('extrasBadge', questBadge || expBadge);
            }
			
			// ‚úÖ AJOUTER CETTE NOUVELLE FONCTION DANS LA CLASSE GAME

            checkCompletedNotifications() {
                // V√©rifier les Qu√™tes et Succ√®s
                const completedQuest = this.quests.some(q => q.completed && !q.claimed);
                const completedAchiev = Object.values(this.achievements).some(a => a.completed && !a.claimed);
                this.showBadge('questsTabBadge', completedQuest || completedAchiev);

                // V√©rifier les Exp√©ditions
                const completedExp = this.activeExpeditions.some(e => Date.now() >= e.endTime);
                this.showBadge('expeditionsTabBadge', completedExp);

                // Mettre √† jour le badge "Extras" global
                this.updateExtrasBadge();
            }
			
			/**
 * Calcule le taux de r√©ussite (0.0 √† 1.0+) bas√© sur la difficult√©
 */
/**
 * Calcule le taux de r√©ussite (0.0 √† 1.0+) bas√© sur la difficult√©
 */
calculateExpeditionSuccessRate(creature, expeditionDef) {
    const creatureScore = creature.maxHp + creature.attack + creature.defense + creature.speed;
    
    let difficulty = expeditionDef.difficulty || 100;
    
    // Calcul simple : Score / Difficult√©
    let successRate = creatureScore / difficulty;

    return Math.max(0.1, Math.min(1.5, successRate));
}

updateExpeditionTimer(deltaTime) {
    // 1. Si la liste des missions disponibles est PLEINE (6/6)
    if (this.availableExpeditions.length >= this.maxAvailableExpeditions) {
        // ON BLOQUE LE TIMER : On le force √† rester au maximum (ex: 5 minutes).
        // Cela signifie que le temps ne s'√©coule pas tant que c'est plein.
        // Quand vous lib√©rerez une place, le timer commencera √† descendre de 5:00.
        this.expeditionTimer = this.EXPEDITION_GEN_TIME;
        return; 
    }

    // 2. Sinon (s'il reste de la place), le temps s'√©coule
    this.expeditionTimer -= deltaTime;

    // 3. Quand le timer arrive √† 0
    if (this.expeditionTimer <= 0) {
        this.generateRandomExpedition();
        // On remet le timer au d√©but pour la prochaine
        this.expeditionTimer = this.EXPEDITION_GEN_TIME;
    }
}

/**
 * V√©rifie si une cr√©ature remplit les conditions strictes (Type/Talent) de la mission.
 * @returns {boolean} True si compatible (ou aucune restriction), False sinon.
 */
meetsExpeditionRequirements(creature, expeditionDef) {
    // Si pas de requirements, tout le monde peut entrer
    if (!expeditionDef.rewardPool || !expeditionDef.rewardPool.requirements || expeditionDef.rewardPool.requirements.length === 0) {
        return true;
    }

    // V√©rifie si une des conditions est remplie
    return expeditionDef.rewardPool.requirements.some(req => {
        if (req.type === 'type') {
            return creature.type === req.value || creature.secondaryType === req.value;
        }
        if (req.type === 'talent') {
            return creature.passiveTalent === req.value;
        }
        return false;
    });
}

generateRandomExpedition() {
    if (this.availableExpeditions.length >= this.maxAvailableExpeditions) return;

    // 1. Choisir une d√©finition au hasard depuis constants.js
    const keys = Object.keys(EXPEDITION_DEFINITIONS);
    const randomKey = keys[Math.floor(Math.random() * keys.length)];
    
    // 2. Cr√©er une instance unique
    // On ajoute un ID unique (uid) pour distinguer deux missions identiques (ex: 2x For√™t)
    const newExpedition = {
        uid: Date.now() + Math.random(), 
        defId: randomKey,
        generatedAt: Date.now()
    };

    this.availableExpeditions.push(newExpedition);
    
    // Notification discr√®te
    if (typeof toast !== 'undefined') {
        toast.info("Nouvelle Mission", "Une nouvelle exp√©dition est disponible !");
    }
    
    this.updateExpeditionsDisplay();
}

/**
 * Lance une exp√©dition (Compatible Solo et Escouade).
 * @param {number|number[]} storageIndices - Index unique OU Tableau d'index.
 */
startExpedition(storageIndices, expeditionUid, expeditionId) {
    // 1. V√©rification des slots
    if (this.activeExpeditions.length >= this.maxExpeditionSlots) {
        logMessage("‚ùå Slots d'exp√©dition pleins !");
        return;
    }

    // 2. V√©rification de la mission
    const missionIndex = this.availableExpeditions.findIndex(e => e.uid == expeditionUid);
    if (missionIndex === -1) {
        logMessage("‚ùå Cette exp√©dition n'est plus disponible.");
        this.updateAvailableExpeditionsList();
        return;
    }

    const expeditionDef = EXPEDITION_DEFINITIONS[expeditionId];
    if (!expeditionDef) return;

    // 3. Normalisation : On s'assure d'avoir toujours un tableau
    let indicesArray = Array.isArray(storageIndices) ? storageIndices : [storageIndices];
    
    // 4. V√©rifications et Constitution de l'Escouade
    const squad = [];
    
    // On trie les index par ordre d√©croissant pour les supprimer du stockage sans d√©caler les autres
    // (Tr√®s important quand on en supprime plusieurs d'un coup)
    indicesArray.sort((a, b) => b - a);

    for (let idx of indicesArray) {
        const creature = this.storage[idx];
        if (!creature) continue;

        // V√©rif Niveau
        if (creature.level < expeditionDef.requiredLevel) {
            toast.error("Niveau insuffisant", `${creature.name} n'a pas le niveau requis.`);
            return;
        }
        // V√©rif Endurance
        if (creature.currentStamina < 1) {
            toast.error("Trop fatigu√©", `${creature.name} a besoin de repos.`);
            return;
        }

        squad.push(creature);
    }

    if (squad.length === 0) return; // S√©curit√©

    // 5. Calcul du Succ√®s Global
    // (Utilise la fonction calculateTeamSuccessRate que vous avez d√©j√†)
    const successRate = this.calculateTeamSuccessRate(squad, expeditionDef);

    // 6. Traitement : Retrait du stockage et Co√ªt Endurance
    // On le fait maintenant que tout est valid√©
    for (let idx of indicesArray) {
        const c = this.storage[idx];
        c.currentStamina = 0; // Vide l'endurance
        this.storage.splice(idx, 1); // Retire du stockage
    }

    // 7. Gestion de la Ma√Ætrise (R√©duction de temps)
    let duration = expeditionDef.duration;
    if (typeof EXPEDITION_BIOMES !== 'undefined') {
        const biome = EXPEDITION_BIOMES[expeditionId];
        if (biome && this.expeditionMastery) {
            const xp = this.expeditionMastery[biome] || 0;
            let timeReduction = 0;
            // Calcul du bonus selon le niveau de ma√Ætrise
            if (typeof BIOME_MASTERY_LEVELS !== 'undefined') {
                for (let lvl = 5; lvl >= 1; lvl--) {
                    if (xp >= BIOME_MASTERY_LEVELS[lvl].xpRequired) {
                        timeReduction = BIOME_MASTERY_LEVELS[lvl].bonus;
                        break;
                    }
                }
            }
            if (timeReduction > 0) {
                duration = Math.floor(duration * (1 - timeReduction));
            }
        }
    }

    // 8. Cr√©ation de l'exp√©dition active
    const expedition = {
        // On sauvegarde les donn√©es de TOUTE l'√©quipe
        squadData: squad.map(c => c.serialize()), 
        expeditionId: expeditionId,
        startTime: Date.now(),
        endTime: Date.now() + duration,
        successRateSnapshot: successRate
    };

    // 9. Lancement final
    this.availableExpeditions.splice(missionIndex, 1); // Retire de la liste "Disponibles"
    this.activeExpeditions.push(expedition); // Ajoute aux "Actives"

    // 10. Feedback UI
    const names = squad.map(c => c.name).join(', ');
    let chanceStr = successRate >= 1 ? " (Succ√®s Garanti)" : ` (${Math.floor(successRate*100)}%)`;
    
    logMessage(`üó∫Ô∏è D√©part : ${names} vers ${expeditionDef.name}${chanceStr}`);
    
    if (typeof toast !== 'undefined') {
        toast.info("Exp√©dition Lanc√©e", `Retour dans ${formatTimeString(duration)}.`);
    }

    // Fermeture des modales (compatibilit√© avec les deux versions)
    const selectModal = document.getElementById('creatureSelectModal');
    if (selectModal) document.body.removeChild(selectModal);
    
    const oldModal = document.getElementById('expeditionSendModal');
    if (oldModal) document.body.removeChild(oldModal);

    this.updateStorageDisplay();
    this.updateExpeditionsDisplay();
}
/**
 * R√©cup√®re les r√©compenses d'une exp√©dition termin√©e.
 */
claimExpedition(index) {
    const expedition = this.activeExpeditions[index];
    // V√©rification de s√©curit√© basique
    if (!expedition || Date.now() < expedition.endTime) {
        console.warn("Tentative de r√©cup√©ration d'une exp√©dition non termin√©e ou inexistante.");
        return;
    }

    // 1. Identifier la d√©finition
    const expeditionDef = EXPEDITION_DEFINITIONS[expedition.expeditionId];
    if (!expeditionDef) {
        logMessage("‚ùå Erreur critique : D√©finition d'exp√©dition introuvable.");
        this.activeExpeditions.splice(index, 1);
        this.updateExpeditionsDisplay();
        return;
    }

    // 2. Reconstituer l'Escouade (Gestion de la r√©trocompatibilit√©)
    let squad = [];
    try {
        if (expedition.squadData && Array.isArray(expedition.squadData)) {
            // Nouvelle version (Escouade)
            squad = expedition.squadData.map(data => Creature.deserialize(data));
        } else if (expedition.creatureData) {
            // Ancienne version (Solo)
            squad = [Creature.deserialize(expedition.creatureData)];
        } else {
            throw new Error("Aucune donn√©e de cr√©ature trouv√©e.");
        }
    } catch (e) {
        console.error("Erreur lors de la r√©cup√©ration de l'escouade :", e);
        // On supprime l'exp√©dition buggu√©e pour d√©bloquer le slot
        this.activeExpeditions.splice(index, 1);
        this.updateExpeditionsDisplay();
        return;
    }

    // 3. Calcul des R√©compenses
    // On utilise le snapshot de r√©ussite calcul√© au d√©part (ou 1.0 par d√©faut)
    const successRate = expedition.successRateSnapshot || 1.0;
    // On utilise le premier membre comme "Leader" pour d'√©ventuels bonus de type
    const leader = squad[0]; 
    
    const rewards = this.calculateExpeditionRewards(expeditionDef, leader, successRate);

    // 4. Traitement du Retour (Soin / Blessure)
    squad.forEach(creature => {
        if (rewards.performance === 'FAILURE') {
            creature.currentHp = 1; // Revient bless√© en cas d'√©chec critique
        } else {
            creature.heal(); // Revient soign√© sinon
        }
        this.storage.push(creature);
    });

    // 6. Ma√Ætrise
    const biome = EXPEDITION_BIOMES[expedition.expeditionId];
    
    // --- D√âBUT S√âCURIT√â ---
    // Si l'objet n'existe pas (vielle sauvegarde), on le cr√©e √† la vol√©e
    if (!this.expeditionMastery) {
        this.expeditionMastery = {};
    }
    // --- FIN S√âCURIT√â ---

    if (biome) {
        this.expeditionMastery[biome] = (this.expeditionMastery[biome] || 0) + 1;
    }

    // 6. Distribution des Gains
    let rewardMessages = [];
    let title = "Retour d'Exp√©dition";
    let toastType = "success";

    // Titre selon performance
    if (rewards.performance === 'CRITICAL') {
        title = "üåü SUCC√àS CRITIQUE !";
        toastType = "legendary"; // (Si vous avez ce style CSS, sinon 'success')
        rewardMessages.push("Performance exceptionnelle ! (Butin x2)");
    } else if (rewards.performance === 'FAILURE') {
        title = "‚ö†Ô∏è √âchec...";
        toastType = "warning";
        rewardMessages.push("L'exp√©dition a mal tourn√©...");
    }

    // Argent
    if (rewards.pokedollars > 0) {
        this.pokedollars += rewards.pokedollars;
        this.stats.totalPokedollarsEarned += rewards.pokedollars;
        this.checkAchievements('totalPokedollarsEarned');
        this.checkSpecialQuests('pokedollars_gained');
        rewardMessages.push(`üí∞ ${formatNumber(rewards.pokedollars)}$`);
    }

    // Jetons
    if (rewards.tokens > 0) {
        this.questTokens += rewards.tokens;
        rewardMessages.push(`üé´ ${rewards.tokens} Jetons`);
    }

    // Shards (Attribu√©s au Leader pour simplifier)
    if (rewards.shards > 0) {
        const shardKey = getShardKey(leader.name, leader.rarity);
        this.shards[shardKey] = (this.shards[shardKey] || 0) + rewards.shards;
        rewardMessages.push(`üíé ${rewards.shards} Shards (${leader.name})`);
        this.checkSpecialQuests('totalShards');
    }

    // ≈íufs
    if (rewards.eggs) {
        Object.entries(rewards.eggs).forEach(([rarity, amount]) => {
            this.eggs[rarity] = (this.eggs[rarity] || 0) + amount;
            rewardMessages.push(`ü•ö ${amount}x ${rarity}`);
        });
    }

    // Objets
    if (rewards.items) {
        Object.entries(rewards.items).forEach(([itemKey, amount]) => {
            this.addItem(itemKey, amount);
            // Tenter de r√©cup√©rer le nom propre de l'item
            const itemName = (typeof ALL_ITEMS !== 'undefined' && ALL_ITEMS[itemKey]) ? ALL_ITEMS[itemKey].name : itemKey;
            rewardMessages.push(`üì¶ ${amount}x ${itemName}`);
        });
    }

    // 7. Nettoyage et Affichage
    this.activeExpeditions.splice(index, 1);
    
    const names = squad.map(c => c.name).join(', ');
    logMessage(`‚úÖ ${names} de retour. ${rewardMessages.join(', ')}`);

    if (typeof toast !== 'undefined') {
        toast.show({
            title: title,
            message: rewardMessages.join(', '),
            type: toastType,
            duration: 6000
        });
    }

    // Mises √† jour UI
    this.updateStorageDisplay();
    this.updateExpeditionsDisplay();
    this.updateEggsDisplay();
    this.updateShopDisplay();
    this.updatePlayerStatsDisplay(); // Pour l'argent
}

/**
 * Calcule le butin final bas√© sur la d√©finition et le taux de succ√®s.
 */
calculateExpeditionRewards(expeditionDef, creature, successRate) {
    let performance = 'NORMAL';
    const roll = Math.random(); // 0.0 √† 1.0

    // Logique de r√©sultat
    // Si > 100% succ√®s, chance de critique (ex: 1.2 = 20% chance critique)
    if (successRate > 1.0 && roll < (successRate - 1.0)) {
        performance = 'CRITICAL';
    } 
    // Si succ√®s < 100%, risque d'√©chec (ex: 0.8 = 20% chance √©chec)
    else if (roll > successRate) {
        performance = 'FAILURE';
    }

    const rewards = { pokedollars: 0, tokens: 0, shards: 0, eggs: {}, items: {}, performance: performance };
    const pool = expeditionDef.rewardPool;

    // Multiplicateur de butin
    let lootMultiplier = 1;
    
    // Bonus de Type/Talent (Appliqu√© au loot aussi)
    if (pool.requirements) { // Ou pool.bonuses selon votre version pr√©c√©dente
       // On simplifie ici : si succ√®s √©lev√©, c'est que les conditions √©taient remplies
    }

    if (performance === 'FAILURE') lootMultiplier = 0.25;
    if (performance === 'CRITICAL') lootMultiplier = 2.0;

    // --- G√âN√âRATION ---

    // Argent
    if (pool.pokedollars) {
        const base = Math.floor(Math.random() * (pool.pokedollars.max - pool.pokedollars.min) + pool.pokedollars.min);
        rewards.pokedollars = Math.floor(base * lootMultiplier);
    }

    // Jetons
    if (pool.tokens && performance !== 'FAILURE') {
        if (Math.random() < pool.tokens.chance) {
            const base = Math.floor(Math.random() * (pool.tokens.max - pool.tokens.min) + pool.tokens.min);
            rewards.tokens = Math.floor(base * lootMultiplier);
        }
    }

    // Shards
    if (pool.shards && Math.random() < pool.shards.chance) {
        rewards.shards = Math.max(1, Math.floor(pool.shards.amount * lootMultiplier));
    }

    // ≈íufs
    if (pool.eggs && performance !== 'FAILURE') {
        Object.entries(pool.eggs).forEach(([rarity, eggInfo]) => {
            let chance = eggInfo.chance * (performance === 'CRITICAL' ? 1.5 : 1);
            if (Math.random() < chance) {
                rewards.eggs[rarity] = (rewards.eggs[rarity] || 0) + eggInfo.amount;
            }
        });
    }

    // Objets
    if (pool.items && performance !== 'FAILURE') {
        Object.entries(pool.items).forEach(([itemKey, itemInfo]) => {
            let chance = itemInfo.chance * (performance === 'CRITICAL' ? 1.5 : 1);
            if (Math.random() < chance) {
                rewards.items[itemKey] = (rewards.items[itemKey] || 0) + itemInfo.amount;
            }
        });
    }

    return rewards;
}

getActiveBoostMultiplier(type) {
    let multiplier = 0;
    
    this.activeBoosts.forEach(boost => {
        if (boost.type === type) {
            multiplier += boost.value;
        }
    });
    
    return multiplier;
}
getStatBoostMultiplier(stat) {
    let multiplier = 0;
    
    this.activeStatBoosts.forEach(boost => {
        if (boost.stat === 'all') {
            multiplier += boost.value;
        } else if (boost.stat === stat) {
            multiplier += boost.value;
        }
    });
    
    return multiplier;
}

// ========== updateQuestsDisplay() - VERSION FINALE CORRIG√âE ==========

// UI : Affichage des qu√™tes (Version Finale - Fix ID Types)
    updateQuestsDisplay() {
        const questContainer = document.getElementById('questContainer');
        const questCount = document.getElementById('questCount');
        const questTokens = document.getElementById('questTokens');
        const questCompleted = document.getElementById('questCompleted');
        
        if (!questContainer) return;
        
        if (questCount) questCount.textContent = this.quests.length;
        if (questTokens) questTokens.textContent = this.questTokens;
        if (questCompleted) questCompleted.textContent = this.questsCompleted;
        
        questContainer.innerHTML = '';
        
        if (this.quests.length === 0) {
            questContainer.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 30px; font-style: italic;">Aucune qu√™te disponible.<br>Revenez plus tard !</div>';
            return;
        }
        
        const displayableQuests = this.quests.filter(q => !q.claimed);
        
        displayableQuests.forEach(quest => {
            const card = document.createElement('div');
            card.className = 'quest-card';
            
            if (quest.accepted && !quest.completed) card.classList.add('accepted');
            if (quest.completed) card.classList.add('completed');
            
            let badgeClass = 'badge-easy';
            let badgeText = 'Facile';
            
            if (quest.questType === 'STORY') {
                badgeClass = 'badge-extreme';
                badgeText = 'Sc√©nario';
                card.style.borderLeft = "4px solid #f59e0b";
            } else {
                if (quest.difficulty === 'MEDIUM') { badgeClass = 'badge-medium'; badgeText = 'Moyen'; }
                if (quest.difficulty === 'HARD') { badgeClass = 'badge-hard'; badgeText = 'Difficile'; }
                if (quest.difficulty === 'EXTREME') { badgeClass = 'badge-extreme'; badgeText = 'Extr√™me'; }
            }
            
            const current = quest.current || 0;
            const target = quest.target || 1;
            const percent = Math.min(100, (current / target) * 100);
            
            let rewardsHTML = '';
            if (quest.rewards) {
                if (quest.rewards.pokedollars) rewardsHTML += `<span class="quest-reward-item">üí∞ ${formatNumber(quest.rewards.pokedollars)}</span>`;
                if (quest.rewards.tokens) rewardsHTML += `<span class="quest-reward-item">üé´ ${quest.rewards.tokens}</span>`;
                
                if (quest.rewards.items) {
                    Object.entries(quest.rewards.items).forEach(([key, count]) => {
                        const itemDef = ALL_ITEMS[key] || { name: key, icon: 'üì¶' };
                        rewardsHTML += `<span class="quest-reward-item">${itemDef.icon} ${count}x ${itemDef.name}</span>`;
                    });
                }

                if (quest.rewards.eggs) {
                    Object.entries(quest.rewards.eggs).forEach(([rarity, count]) => {
                        if(count > 0) rewardsHTML += `<span class="quest-reward-item">ü•ö ${count}x ${rarity}</span>`;
                    });
                }
            }
            
            let actionsHTML = '';
            
            // ‚úÖ FIXES ICI :
            // 1. Les IDs sont pass√©s comme cha√Ænes ('${quest.id}')
            // 2. Pour le bouton CLAIM, on utilise '==' dans le find() pour matcher string/number
            
            if (!quest.accepted) {
                actionsHTML = `
                    <div class="quest-actions">
                        <button class="quest-btn btn-accept" onclick="game.acceptQuest('${quest.id}')">Accepter</button>
                        <button class="quest-btn btn-refuse" onclick="game.refuseQuest('${quest.id}')">Refuser</button>
                    </div>
                `;
            } else if (quest.completed) {
                actionsHTML = `
                    <button class="quest-btn btn-claim" onclick="game.showQuestCompletionModal(game.quests.find(q => q.id == '${quest.id}'))">
                        üéÅ R√©cup√©rer
                    </button>
                `;
            } else {
                actionsHTML = `
                    <button class="quest-btn btn-refuse" style="width:100%;" onclick="game.abandonQuest('${quest.id}')">
                        Abandonner
                    </button>
                `;
            }

            card.innerHTML = `
                <div class="quest-header">
                    <div class="quest-title">${quest.title}</div>
                    <div class="quest-badge ${badgeClass}">${badgeText}</div>
                </div>
                
                <div class="quest-description">${quest.description}</div>
                
                <div class="quest-progress-container">
                    <div class="quest-progress-bar">
                        <div class="quest-progress-fill" style="width: ${percent}%"></div>
                    </div>
                    <div class="quest-progress-text">${formatNumber(current)} / ${formatNumber(target)}</div>
                </div>
                
                <div class="quest-rewards">${rewardsHTML}</div>
                
                ${actionsHTML}
            `;
            
            questContainer.appendChild(card);
        });
    }

// S√âCURIT√â : Sauvegarde avec protection anti-corruption
    saveGame() {
        // 1. Contr√¥le d'int√©grit√© AVANT de toucher au LocalStorage
        if (!this.playerTeam || !Array.isArray(this.playerTeam) || this.playerTeam.length === 0) {
            console.error("‚õî SAUVEGARDE BLOQU√âE : L'√©quipe du joueur est vide ou corrompue !");
            if (typeof toast !== 'undefined') {
                toast.error("Erreur Sauvegarde", "Donn√©es corrompues d√©tect√©es. Sauvegarde annul√©e pour prot√©ger votre progression.");
            }
            return false;
        }

        if (isNaN(this.pokedollars) || this.pokedollars < 0) {
            console.warn("‚ö†Ô∏è Correction auto : Pok√©dollars n√©gatifs ou NaN remis √† 0.");
            this.pokedollars = 0;
        }

        // 2. Pr√©paration des donn√©es compl√®tes
        const gameData = {
            // -- √âquipes --
            playerTeam: this.playerTeam.map(creature => creature.serialize()),
            storage: this.storage.map(creature => creature.serialize()),
            pension: this.pension.map(creature => creature.serialize()),
            
            // -- Stats & Ressources --
            playerMainStats: { ...this.playerMainStats },
            eggs: { ...this.eggs },
            shards: { ...this.shards },
            pokedollars: this.pokedollars,
            talentRerolls: this.talentRerolls,
            talentChoices: this.talentChoices,
            essenceDust: this.essenceDust,
            combatTickets: this.combatTickets,
            marquesDuTriomphe: this.marquesDuTriomphe,
            questTokens: this.questTokens,
            
            // -- Progression --
            pokedex: { ...this.pokedex },
            upgrades: { ...this.upgrades },
            towerRecord: this.towerRecord,
            stats: { ...this.stats },
            badges: { ...this.badges },
            
            achievementsCompleted: { ...this.achievementsCompleted },
            currentZone: currentZone,
			maxReachedZone: maxReachedZone,

            // -- Exp√©ditions --
            availableExpeditions: this.availableExpeditions,
            expeditionTimer: this.expeditionTimer,
            expeditionMastery: this.expeditionMastery,
            activeExpeditions: this.activeExpeditions,
            maxExpeditionSlots: this.maxExpeditionSlots,

            // -- Param√®tres & √âtats --
            activeCreatureIndex: this.activeCreatureIndex,
            sortBy: this.sortBy,
			pauseOnRare: this.pauseOnRare,
            sortOrder: this.sortOrder,
            autoSelectEnabled: this.autoSelectEnabled,
            isPensionCollapsed: this.isPensionCollapsed,
            captureMode: this.captureMode,
            captureTarget: this.captureTargets,
            
            // -- Objets & Buffs --
            items: this.items,
            activeVitamins: this.activeVitamins,
            activeStatBoosts: this.activeStatBoosts,
            activeBoosts: this.activeBoosts,
            permanentBoosts: this.permanentBoosts,
			hasAutoCatcher: this.hasAutoCatcher,
            autoCatcherSettings: this.autoCatcherSettings,
            
            // -- Zone Progress (Copie propre) --
            zoneProgress: Object.keys(this.zoneProgress).reduce((acc, zoneId) => {
                acc[zoneId] = {
                    pokemonTiers: { ...this.zoneProgress[zoneId].pokemonTiers },
                    bossesDefeated: this.zoneProgress[zoneId].bossesDefeated,
                    epicsDefeated: this.zoneProgress[zoneId].epicsDefeated
                };
                return acc;
            }, {}),
            
            // -- Qu√™tes (Copie l√©g√®re) --
            quests: this.quests.map(quest => ({
                id: quest.id,
                type: quest.type,
                questType: quest.questType,
                title: quest.title,
                description: quest.description,
                target: quest.target,
                current: quest.current,
                startValue: quest.startValue,
                trackingKey: quest.trackingKey,
                difficulty: quest.difficulty,
                special: quest.special,
                specialParams: quest.specialParams,
                accepted: quest.accepted,
                completed: quest.completed,
                claimed: quest.claimed,
                rewards: quest.rewards
            })),
            
            questsCompleted: this.questsCompleted,
            nextQuestTimer: this.nextQuestTimer,
            lastQuestUpdate: this.lastQuestUpdate,
            
            // -- Timers Syst√®me --
            lastSaveTime: Date.now(),
            saveTime: Date.now(),
            
            // -- Ar√®ne --
            arenaState: {
                active: this.arenaState.active,
                arenaId: this.arenaState.arenaId,
                currentChampionIndex: this.arenaState.currentChampionIndex,
                startTime: this.arenaState.startTime
            }
        };
        
        try {
            const json = JSON.stringify(gameData);
            localStorage.setItem('creatureGameSave', json);
            
            // Log discret
            // console.log("Sauvegarde OK (" + (json.length / 1024).toFixed(2) + " KB)");

            // Feedback visuel sur le bouton
            const btn = document.getElementById('btnSave');
            if(btn) {
                btn.classList.add('save-active');
                setTimeout(() => btn.classList.remove('save-active'), 1000);
            }
            return true;
        } catch (error) {
            console.error("ERREUR FATALE SAUVEGARDE :", error);
            if (typeof toast !== 'undefined') {
                toast.error("Erreur Critique", "Impossible de sauvegarder (Quota de stockage d√©pass√© ?).");
            }
            return false;
        }
    }

loadGame() {
    try {
        const savedData = localStorage.getItem('creatureGameSave');
        if (!savedData) return false;
        
        const gameData = JSON.parse(savedData);
        
        this.playerTeam = gameData.playerTeam.map(data => Creature.deserialize(data));
		
		this.captureMode = gameData.captureMode || 0;
this.captureTargets = gameData.captureTargets || null;
// Initialiser l'affichage apr√®s chargement
this.updateCaptureButtonDisplay();
this.updateCaptureTargetList();
        
        // Charger le stockage
        this.storage = [];
        if (gameData.storage) {
            this.storage = gameData.storage.map(data => Creature.deserialize(data));
        }
        
        // Charger la pension
        this.pension = [];
        if (gameData.pension) {
            this.pension = gameData.pension.map(data => Creature.deserialize(data));
        }
        
		this.expeditionMastery = gameData.expeditionMastery || { 
        FOREST: 0, CAVE: 0, CITY: 0, DARK: 0, VOLCANO: 0, 
        ICE: 0, SKY: 0 
    };
	
	if (gameData.pauseOnRare !== undefined) this.pauseOnRare = gameData.pauseOnRare;
	
	this.hasAutoCatcher = gameData.hasAutoCatcher || false;
            if (gameData.autoCatcherSettings) {
                this.autoCatcherSettings = gameData.autoCatcherSettings;
            }
	
		// Charger les exp√©ditions disponibles
this.availableExpeditions = gameData.availableExpeditions || [];
this.expeditionTimer = gameData.expeditionTimer || this.EXPEDITION_GEN_TIME;
this.maxExpeditionSlots = 3; // Force la mise √† jour √† 3

        // Charger les stats et ressources
        this.playerMainStats = { ...gameData.playerMainStats };
        this.eggs = { ...gameData.eggs };
        this.shards = gameData.shards || {};
        this.pokedollars = gameData.pokedollars || 0;
		this.talentRerolls = gameData.talentRerolls || 0;
        this.talentChoices = gameData.talentChoices || 0;
        this.pokedex = gameData.pokedex || {};
        this.badges = gameData.badges || {};
		this.essenceDust = gameData.essenceDust || 0;
		this.activeExpeditions = gameData.activeExpeditions || [];
        this.maxExpeditionSlots = gameData.maxExpeditionSlots || 1;

        // V√©rifier les exp√©ditions termin√©es hors ligne
        const now = Date.now();
        let completedOffline = 0;
        this.activeExpeditions.forEach(exp => {
            if (now >= exp.endTime) {
                completedOffline++;
            }
        });
        if (completedOffline > 0) {
            logMessage(`üåç ${completedOffline} exp√©dition(s) se sont termin√©es pendant votre absence !`);
        }
        
        // Charger les am√©liorations
        if (gameData.upgrades) {
            Object.keys(this.upgrades).forEach(key => {
                if (gameData.upgrades[key]) {
                    this.upgrades[key].level = gameData.upgrades[key].level || 0;
                }
            });
        }
		this.achievements = gameData.achievements || {};
        
        // Charger les qu√™tes
        if (gameData.quests) {
            this.quests = gameData.quests.map(questData => {
                const template = {
                    title: questData.title,
                    desc: questData.description,
                    target: [questData.target],
                    trackingKey: questData.trackingKey,
                    special: questData.special
                };
                
                const quest = new Quest(template, 1, questData.difficulty || 'EASY');
                quest.id = questData.id;
                quest.type = questData.type;
                quest.questType = questData.questType || questData.type;
                quest.current = questData.current || 0;
                quest.startValue = questData.startValue || 0;
                quest.accepted = questData.accepted || false;
                quest.completed = questData.completed || false;
                quest.claimed = questData.claimed || false;
                quest.rewards = questData.rewards;
                
                if (questData.specialParams) {
                    quest.specialParams = questData.specialParams;
                }
                
                return quest;
            });
        }

        this.questTokens = gameData.questTokens || 0;
        this.questsCompleted = gameData.questsCompleted || 0;
        this.nextQuestTimer = gameData.nextQuestTimer || 60000;
        this.lastQuestUpdate = gameData.lastQuestUpdate || Date.now();

        // Charger Tour de Combat
        this.combatTickets = gameData.combatTickets || 0;
        this.marquesDuTriomphe = gameData.marquesDuTriomphe || 0;
        this.towerRecord = gameData.towerRecord || 0;
        this.towerState = {
            isActive: false,
            currentFloor: 0,
            currentEnemyIndex: 0,
            enemyTeam: []
        };
        
        // Charger les boosts
        if (gameData.activeBoosts) {
            this.activeBoosts = gameData.activeBoosts.filter(boost => {
                return boost.endTime > Date.now();
            });
        }

       if (gameData.permanentBoosts) {
            this.permanentBoosts = gameData.permanentBoosts;
            
            // ‚úÖ AJOUT DE S√âCURIT√â :
            // S'assure que pensionSlots existe, sinon le met √† 0
            this.permanentBoosts.pensionSlots = this.permanentBoosts.pensionSlots || 0;
        } else {
            // Initialisation par d√©faut si pas de sauvegarde
            this.permanentBoosts = { xp: 0, team_contribution: 0, pensionSlots: 0 };
        }
        
        // Charger les objets/artefacts
        this.items = gameData.items || {};

        // Charger les vitamines actives
        this.activeVitamins = gameData.activeVitamins || {
            hp: 0,
            attack: 0,
            defense: 0,
            speed: 0,
            all: 0
        };

        // Charger les boosts temporaires de stats
        if (gameData.activeStatBoosts) {
            this.activeStatBoosts = gameData.activeStatBoosts.filter(boost => {
                return boost.endTime > Date.now();
            });
        } else {
            this.activeStatBoosts = [];
        }
        
        // Charger les param√®tres de jeu
        this.activeCreatureIndex = gameData.activeCreatureIndex || 0;
        this.sortBy = gameData.sortBy || 'none';
        this.sortOrder = gameData.sortOrder || 'desc';
        this.autoSelectEnabled = gameData.autoSelectEnabled || false;
        
        // Charger les statistiques
        if (gameData.stats) {
                // On garde les valeurs par d√©faut du constructeur (this.stats) et on applique la sauvegarde par dessus
                this.stats = { ...this.stats, ...gameData.stats };
            }
            this.achievementsCompleted = gameData.achievementsCompleted || {};
        
        // Charger la progression des zones (avec migration)
        if (gameData.zoneProgress) {
            Object.keys(ZONES).forEach(zoneId => {
                if (gameData.zoneProgress[zoneId]) {
                    // Si l'ancienne structure (enemyTiers) est trouv√©e
                    if (gameData.zoneProgress[zoneId].enemyTiers) {
                        // On initialise la nouvelle structure
                        this.zoneProgress[zoneId] = {
                            pokemonTiers: {}, // L'ancienne progression des tiers est perdue
                            bossesDefeated: 0,
                            epicsDefeated: 0
                        };
                    } else {
                        // C'est d√©j√† la nouvelle structure
                        this.zoneProgress[zoneId] = gameData.zoneProgress[zoneId];
                    }
                } else {
                    // Initialiser pour les nouvelles zones
                    this.zoneProgress[zoneId] = { pokemonTiers: {}, bossesDefeated: 0, epicsDefeated: 0 };
                }
            });
        }
        
        

        // V√©rifier l'index de cr√©ature active
        if (this.activeCreatureIndex >= this.playerTeam.length) {
            this.activeCreatureIndex = 0;
        }
        
        // R√©appliquer le tri si n√©cessaire
        if (this.sortBy !== 'none' && this.storage.length > 0) {
            this.sortStorage(this.sortBy);
        }
        
        // Charger la zone actuelle
        if (gameData.currentZone) {
            currentZone = gameData.currentZone;
            document.getElementById('zoneSelect').value = currentZone;
            updateZoneInfo();
        }
		
		if (gameData.maxReachedZone) {
            maxReachedZone = gameData.maxReachedZone;
        } else {
            // R√©tro-compatibilit√© pour les vieilles sauvegardes
            maxReachedZone = currentZone;
        }
        
        // Charger les badges
        if (gameData.badges) {
            this.badges = { ...gameData.badges };
        }

        // R√©initialiser l'ar√®ne si un combat √©tait en cours
        if (gameData.arenaState && gameData.arenaState.active) {
            this.resetArenaState();
        }

        this.applyAccountTalents();
        this.initAchievements();
        
        // ‚úÖ SCAN R√âTROACTIF (Niveau Max)
            // On v√©rifie si le joueur a d√©j√† un Pok√©mon haut niveau mais que la stat n'est pas √† jour
            let maxLvlFound = 0;
            this.playerTeam.forEach(c => { if (c.level > maxLvlFound) maxLvlFound = c.level; });
            if (this.storage) this.storage.forEach(c => { if (c.level > maxLvlFound) maxLvlFound = c.level; });

            if (maxLvlFound > (this.stats.highestLevelReached || 0)) {
                this.stats.highestLevelReached = maxLvlFound;
                // On d√©clenche le succ√®s r√©troactivement au prochain tick ou ici directement
                setTimeout(() => this.checkAchievements('highestLevelReached'), 1000);
            }
            
        // Gestion du temps hors ligne
        if (gameData.lastSaveTime) {
            const offlineTime = Date.now() - gameData.lastSaveTime;
            const offlineSeconds = Math.floor(offlineTime / 1000);
            
            if (offlineSeconds > 0) {
                // R√©g√©n√©rer l'endurance
                for (const creature of this.playerTeam) {
                    creature.currentStamina = creature.maxStamina;
                    creature.heal();
                }
                
                const minutes = Math.floor(offlineSeconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    logMessage("Progression hors ligne : " + hours + "h " + (minutes % 60) + "m appliquee !");
                } else if (minutes > 0) {
                    logMessage("Progression hors ligne : " + minutes + " minutes appliquee !");
                } else {
                    logMessage("Progression hors ligne : " + offlineSeconds + " secondes appliquee !");
                }
            }
            
            // Progression des qu√™tes hors ligne
            if (offlineTime > 0 && this.nextQuestTimer > 0) {
                this.nextQuestTimer = Math.max(0, this.nextQuestTimer - offlineTime);
                
                let questsGenerated = 0;
                while (this.quests.length < 10 && this.nextQuestTimer <= 0) {
                    this.generateQuest();
                    questsGenerated++;
                    const randomTime = (Math.random() * 480000) + 120000;
                    this.nextQuestTimer = randomTime;
                }
                
                if (questsGenerated > 0) {
                    logMessage(questsGenerated + " qu√™te(s) g√©n√©r√©e(s) pendant votre absence !");
                }
            }
        }
        // Forcer la mise √† jour visuelle du bouton Capture
    setTimeout(() => {
        this.updateCaptureButtonDisplay();
        if (this.captureMode === 2) {
            this.updateCaptureTargetList();
        }
    }, 100);
        return true;
    } catch (error) {
        console.error('Erreur de chargement:', error);
        return false;
    }
}
	
	
	// UI : Menu des Donn√©es (Mise √† jour avec Option Pause Rare)
    openSaveManager() {
        const modal = document.getElementById('saveManagerModal');
        if (modal) {
            modal.classList.add('show');
            
            // ‚úÖ MISE √Ä JOUR DES BOUTONS D'OPTION
            this.updateOptionButtons();
        }
    }

    // Nouvelle fonction pour g√©rer les couleurs des boutons
    updateOptionButtons() {
        const btnFusion = document.getElementById('optSmartFusion');
        const btnPause = document.getElementById('optPauseRare');

        if (btnFusion) {
            btnFusion.textContent = this.smartFusion ? "ON" : "OFF";
            btnFusion.style.background = this.smartFusion ? "#22c55e" : "#94a3b8"; // Vert ou Gris
            btnFusion.style.color = "white";
        }

        if (btnPause) {
            btnPause.textContent = this.pauseOnRare ? "PAUSE" : "KILL";
            btnPause.style.background = this.pauseOnRare ? "#22c55e" : "#ef4444"; // Vert ou Rouge (Danger)
            btnPause.style.color = "white";
        }
    }
    
    // SYSTEM : Fermer le modal
    closeSaveManager() {
        const modal = document.getElementById('saveManagerModal');
        if (modal) modal.classList.remove('show');
    }

// --- GESTION DES FEN√äTRES (STATS & BONUS) ---

    // --- GESTION DES STATS (Ton code int√©gr√©) ---

    openStatsModal() {
        const modal = document.getElementById('statsModal');
        if (!modal) {
            console.error("‚ùå Erreur : Div statsModal introuvable");
            return;
        }
        
        // 1. On affiche le modal
        modal.classList.add('show');
        
        // 2. On lance ta fonction de calcul et d'affichage
        this.updateStatsUI();
    }

    closeStatsModal() {
        const modal = document.getElementById('statsModal');
        if (modal) modal.classList.remove('show');
    }

    // Ta fonction showStats(), transform√©e en m√©thode de classe
    updateStatsUI() {
        const display = document.getElementById('statsDisplay');
        if (!display) return;

        // --- 1. TES CALCULS (Adapt√©s avec 'this') ---
        const currentPlayTime = this.stats.totalPlayTime + (Date.now() - this.stats.startTime);
        const hours = Math.floor(currentPlayTime / 3600000);
        const minutes = Math.floor((currentPlayTime % 3600000) / 60000);
        const seconds = Math.floor((currentPlayTime % 60000) / 1000);

        const totalCombats = this.stats.combatsWon + this.stats.combatsLost;
        const winRate = totalCombats > 0 
            ? ((this.stats.combatsWon / totalCombats) * 100).toFixed(1) 
            : 0;

        const totalCreatures = this.playerTeam.length + this.storage.length + this.pension.length;
        
        const shinyRate = this.stats.eggsOpened > 0
            ? ((this.stats.shiniesObtained / this.stats.eggsOpened) * 100).toFixed(3)
            : 0;

        // R√©cup√©ration s√©curis√©e de la zone (variable globale ou propri√©t√© de classe)
        const zoneId = (typeof currentZone !== 'undefined') ? currentZone : 0;
        const zoneName = (typeof ZONES !== 'undefined' && ZONES[zoneId]) ? ZONES[zoneId].name : "Zone Inconnue";
        
        // Badges (S√©curit√© si l'objet badges n'est pas encore init)
        const badgesCount = this.badges ? Object.values(this.badges).filter(b => b).length : 0;
        const maxLevel = this.playerTeam.length > 0 ? Math.max(...this.playerTeam.map(c => c.level)) : 0;


        // --- 2. TON HTML EXACT (Inject√©) ---
        display.innerHTML = `
            <h3 style="color: #667eea; margin-bottom: 15px;">Combat</h3>
            <div class="stats-grid">
                <div class="stat-box highlight">
                    <div class="stat-title">Combats Gagnes</div>
                    <div class="stat-number">${formatNumber(this.stats.combatsWon)}</div>
                    <div class="stat-subtitle">Taux de victoire: ${winRate}%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Combats Perdus</div>
                    <div class="stat-number">${formatNumber(this.stats.combatsLost)}</div>
                </div>
                <div class="stat-box highlight">
                    <div class="stat-title">Boss Vaincus</div>
                    <div class="stat-number">${formatNumber(this.stats.bossDefeated)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Epic Vaincus</div>
                    <div class="stat-number">${formatNumber(this.stats.epicDefeated)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Degats Infliges</div>
                    <div class="stat-number">${formatNumber(this.stats.totalDamageDealt)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Degats Recus</div>
                    <div class="stat-number">${formatNumber(this.stats.totalDamageTaken)}</div>
                </div>
            </div>

            <h3 style="color: #667eea; margin: 25px 0 15px 0;">Creatures</h3>
            <div class="stats-grid">
                <div class="stat-box highlight">
                    <div class="stat-title">Creatures Possedees</div>
                    <div class="stat-number">${totalCreatures}</div>
                    <div class="stat-subtitle">Equipe: ${this.playerTeam.length} | Pension: ${this.pension.length} | Stockage: ${this.storage.length}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Creatures Obtenues</div>
                    <div class="stat-number">${formatNumber(this.stats.creaturesObtained)}</div>
                </div>
                <div class="stat-box highlight">
                    <div class="stat-title">Shinies Obtenus</div>
                    <div class="stat-number">${this.stats.shiniesObtained}</div>
                    <div class="stat-subtitle">Taux: ${shinyRate}%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Oeufs Ouverts</div>
                    <div class="stat-number">${formatNumber(this.stats.eggsOpened)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Evolutions</div>
                    <div class="stat-number">${formatNumber(this.stats.evolutionsCount)}</div>
                </div>
                <div class="stat-box highlight">
                    <div class="stat-title">Prestiges</div>
                    <div class="stat-number">${formatNumber(this.stats.prestigeCount)}</div>
                </div>
            </div>

            <h3 style="color: #667eea; margin: 25px 0 15px 0;">Ar√®nes</h3>
            <div class="stats-grid">
                <div class="stat-box highlight">
                    <div class="stat-title">Ar√®nes Compl√©t√©es</div>
                    <div class="stat-number">${this.stats.arenasWon || 0}/8</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Badges Obtenus</div>
                    <div class="stat-number">${badgesCount}/8</div>
                </div>
            </div>

            <h3 style="color: #667eea; margin: 25px 0 15px 0;">Progression</h3>
            <div class="stats-grid">
                <div class="stat-box highlight">
                    <div class="stat-title">Temps de Jeu</div>
                    <div class="stat-number">${hours}h ${minutes}m ${seconds}s</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Pokedollars Total</div>
                    <div class="stat-number">${formatNumber(this.pokedollars)}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Zone Actuelle</div>
                    <div class="stat-number">${zoneId}</div>
                    <div class="stat-subtitle">${zoneName}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Niveau Max Equipe</div>
                    <div class="stat-number">${maxLevel}</div>
                </div>
            </div>
        `;
    }
	
	// DANS LA CLASSE GAME
    toggleSecondaryContent() {
        const content = document.getElementById('secondaryContent');
        const icon = document.getElementById('toggleIcon');
        
        if (!content || !icon) return;
        
        if (content.style.display === 'none' || content.style.display === '') {
            content.style.display = 'block';
            icon.textContent = '‚ñº';
        } else {
            content.style.display = 'none';
            icon.textContent = '‚ñ≤';
            
            // Mise √† jour (Note le 'this')
            setTimeout(() => {
                const activeTab = document.querySelector('.tab-content.active');
                if (activeTab && activeTab.id === 'itemsTab') {
                    // Assure-toi que ces m√©thodes existent ou adapte les noms
                    if (this.updateItemsDisplay) this.updateItemsDisplay();
                    if (this.updateStatBoostsDisplay) this.updateStatBoostsDisplay();
                }
            }, 50);
        }
    }
	
	// --- GESTION DES BONUS ---

    openBonusModal() {
        const modal = document.getElementById('bonusModal');
        if (modal) {
            modal.classList.add('show');
            this.updateBonusUI(); // On affiche le contenu
        } else {
            console.error("‚ùå Erreur : <div id='bonusModal'> introuvable.");
        }
    }

    closeBonusModal() {
        const modal = document.getElementById('bonusModal');
        if (modal) modal.classList.remove('show');
    }

    // Fonction pour g√©n√©rer l'interface des Bonus (Placeholder joli)
    // AFFICHE LES BONUS ET BUFFS (Adaptation de ton code showAccountBuffs)
    updateBonusUI() {
        const display = document.getElementById('bonusDisplay');
        if (!display) return;
        
        // 1. BOUTIQUE (Placeholder pour l'instant, tu pourras remettre tes boutons d'achat ici)
        let html = '<h3 style="color: #8b5cf6; margin-bottom: 15px;">üõçÔ∏è Boutique</h3>';
        html += '<div class="stats-grid" style="margin-bottom:30px;">';
        html += '<div class="stat-box"><div class="stat-title">Bient√¥t disponible</div><div class="stat-subtitle">La boutique ouvrira prochainement</div></div>';
        html += '</div>';

        // 2. TALENTS D'AR√àNE (BADGES)
        html += '<h3 style="color: #667eea; margin-bottom: 15px;">üèÜ Talents d\'Ar√®ne (Badges)</h3>';
        html += '<div class="stats-grid">';
        
        let badgeCount = 0;
        // V√©rifie si ACCOUNT_TALENTS existe, sinon utilise un objet vide pour √©viter le crash
        const talents = (typeof ACCOUNT_TALENTS !== 'undefined') ? ACCOUNT_TALENTS : {};
        
        Object.entries(talents).forEach(([key, talent]) => {
            if (this.hasBadge && this.hasBadge(key)) {
                badgeCount++;
                html += `
                    <div class="stat-box highlight">
                        <div class="stat-title">‚úÖ ${talent.name}</div>
                        <div class="stat-subtitle">${talent.description}</div>
                    </div>
                `;
            }
        });
        
        if (badgeCount === 0) {
            html += '<div class="stat-box"><div class="stat-title">Aucun badge obtenu</div></div>';
        }
        html += '</div>';
        
        // 3. AM√âLIORATIONS (POK√âDOLLARS)
        html += '<h3 style="color: #667eea; margin: 25px 0 15px 0;">üí∞ Am√©liorations (Pok√©dollars)</h3>';
        html += '<div class="stats-grid">';
        
        let hasUpgrades = false;
        
    
        
        // Boost XP
        if (this.upgrades.expBoost.level > 0) {
            hasUpgrades = true;
            const expMultiplier = ((this.getExpMultiplier() - 1) * 100).toFixed(0);
            html += `
                <div class="stat-box">
                    <div class="stat-title">üìö Boost d'Exp√©rience</div>
                    <div class="stat-number">Niveau ${this.upgrades.expBoost.level}</div>
                    <div class="stat-subtitle">+${expMultiplier}% XP (base)</div>
                </div>`;
        }
        
        // Drop ≈ìufs
        if (this.upgrades.eggDrop.level > 0) {
            hasUpgrades = true;
            const eggBonus = (this.getEggDropBonus() * 100).toFixed(0);
            html += `
                <div class="stat-box">
                    <div class="stat-title">ü•ö Chasseur d'≈íufs</div>
                    <div class="stat-number">Niveau ${this.upgrades.eggDrop.level}</div>
                    <div class="stat-subtitle">+${eggBonus}% chance de drop</div>
                </div>`;
        }
        
        // Autres upgrades (Stamina, Shards, etc...)
        // J'ai compact√© pour l'exemple, mais tu peux remettre tous tes ifs ici
        // en rempla√ßant game. par this.
        
        if (!hasUpgrades) {
            html += '<div class="stat-box"><div class="stat-title">Aucune am√©lioration achet√©e</div></div>';
        }
        html += '</div>';
        
        // 4. R√âSUM√â TOTAL DES BONUS
        html += '<h3 style="color: #667eea; margin: 25px 0 15px 0;">üìä R√©sum√© des Bonus Totaux</h3>';
        html += '<div class="stats-grid">';
        
        // S√©curisation des m√©thodes (au cas o√π elles n'existent pas encore)
        const hpBonus = (this.getAccountTalentBonus ? this.getAccountTalentBonus('hp_mult') : 0) * 100;
        const damageBonus = (this.getAccountTalentBonus ? this.getAccountTalentBonus('damage_mult') : 0) * 100;
        const moneyBonus = (this.getAccountTalentBonus ? this.getAccountTalentBonus('pokedollars_mult') : 0) * 100;
        
        if (hpBonus > 0) {
            html += `<div class="stat-box highlight"><div class="stat-title">‚ù§Ô∏è HP Max</div><div class="stat-number">+${hpBonus.toFixed(0)}%</div></div>`;
        }
        if (damageBonus > 0) {
            html += `<div class="stat-box highlight"><div class="stat-title">‚öîÔ∏è D√©g√¢ts</div><div class="stat-number">+${damageBonus.toFixed(0)}%</div></div>`;
        }
        if (moneyBonus > 0) {
            html += `<div class="stat-box highlight"><div class="stat-title">üí∞ Argent</div><div class="stat-number">+${moneyBonus.toFixed(0)}%</div></div>`;
        }
        
        html += '</div>';

        // Injection Finale
        display.innerHTML = html;
    
    }
	
    // S√âCURIT√â : Exporter la sauvegarde (T√©l√©chargement)
    exportSaveFile() {
        // 1. On force une sauvegarde fra√Æche d'abord
        if (!this.saveGame()) return; // Si la save √©choue (donn√©es corrompues), on n'exporte pas
        
        // 2. R√©cup√©ration du JSON string
        const saveData = localStorage.getItem('creatureGameSave');
        if (!saveData) {
            toast.error("Erreur", "Aucune donn√©e √† exporter.");
            return;
        }

        // 3. Cr√©ation du Blob et T√©l√©chargement
        const blob = new Blob([saveData], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        
        // Nom du fichier avec la date : save_2023-10-25_14h30.json
        const date = new Date();
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = date.getHours() + "h" + date.getMinutes();
        a.href = url;
        a.download = `pokeweb_save_${dateStr}_${timeStr}.json`;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        toast.success("Export R√©ussi", "Fichier de sauvegarde t√©l√©charg√© !");
    }

    // S√âCURIT√â : Importer une sauvegarde (Upload + Validation)
    importSaveFile() {
        // 1. Cr√©ation de l'input file invisible
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json'; // Accepte uniquement les JSON
        
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            
            reader.onload = event => {
                const content = event.target.result;
                try {
                    // 2. Validation : Est-ce du JSON valide ?
                    const parsedData = JSON.parse(content);
                    
                    // 3. Sanity Check : Est-ce une sauvegarde de NOTRE jeu ?
                    // On v√©rifie quelques cl√©s essentielles
                    if (!parsedData.playerTeam || !parsedData.pokedollars || !parsedData.stats) {
                        throw new Error("Format de sauvegarde invalide (Cl√©s manquantes).");
                    }

                    // 4. Application
                    localStorage.setItem('creatureGameSave', content);
                    
                    toast.success("Import R√©ussi", "Le jeu va recharger...");
                    
                    // 5. Reload pour appliquer proprement (√©vite les bugs de state)
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                    
                } catch (err) {
                    console.error("Erreur Import :", err);
                    toast.error("Fichier Invalide", "Ce fichier n'est pas une sauvegarde compatible.");
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click(); // Ouvre la fen√™tre de s√©lection de fichier
    }
	
	
updateShopDisplay() {
    const shopContainer = document.getElementById('shopContainer');
    const shopTokens = document.getElementById('shopTokens');
    
    if (!shopContainer) return;
    
    shopTokens.textContent = this.questTokens;
    shopContainer.innerHTML = '';
    
    Object.entries(SHOP_ITEMS).forEach(([key, item]) => {
        const card = document.createElement('div');
        card.className = 'shop-item';
        
        // --- NOUVELLE LOGIQUE DE CO√õT INCR√âMENTAL ---
        let currentCost = item.cost;
        let isMaxed = false;
        let levelInfo = "";

        // Si l'item a un co√ªt incr√©mental (tableau)
        if (Array.isArray(item.cost)) {
            // On calcule le niveau actuel bas√© sur les boosts permanents poss√©d√©s
            // Note : Cela compte aussi les slots achet√©s dans la Tour (ce qui est logique pour un co√ªt croissant)
            let storedValue = 0;
            if (item.effect.type === 'pensionSlot') storedValue = this.permanentBoosts.pensionSlots || 0;
            else if (item.effect.type === 'permanentXP') storedValue = (this.permanentBoosts.xp || 0) * 20; // Approx pour l'XP

            const currentLevel = Math.floor(storedValue / item.effect.value);
            
            if (currentLevel >= item.maxLevel) {
                isMaxed = true;
                currentCost = 0; // ou le dernier prix
            } else {
                currentCost = item.cost[currentLevel] || item.cost[item.cost.length - 1];
            }
            
            levelInfo = ` <span style="font-size:11px; color:#666;">(Niv ${currentLevel}/${item.maxLevel})</span>`;
        }
        // ---------------------------------------------
        
        const canAfford = !isMaxed && this.questTokens >= currentCost;
        
        let extraInfo = '';
        if (item.type === 'permanent' && item.effect.type === 'permanentXP') {
            const currentBonus = (this.permanentBoosts.xp * 100).toFixed(0);
            extraInfo = `<div style="font-size: 11px; color: #666; margin-top: 5px;">Actuel : +${currentBonus}% XP</div>`;
        }
        if (item.type === 'permanent' && item.effect.type === 'pensionSlot') {
            extraInfo = `<div style="font-size: 11px; color: #666; margin-top: 5px;">Slots bonus : ${this.permanentBoosts.pensionSlots}</div>`;
        }
        
        const buttonText = isMaxed ? "MAXIMIS√â" : (canAfford ? 'Acheter' : 'Pas assez de jetons');
        const costText = isMaxed ? "" : `üé´ ${currentCost} Jetons`;

        const iconHTML = this.getItemIconHTML(item);

card.innerHTML = `
    <div class="shop-item-name" style="display:flex; align-items:center; gap:10px;">
        ${iconHTML}
        <span>${item.name}${levelInfo}</span>
    </div>
    <div class="shop-item-description">${item.description}</div>
    ${extraInfo}
    <div class="shop-item-cost">${costText}</div>
    <button class="shop-buy-btn" onclick="game.buyShopItem('${key}')" ${!canAfford ? 'disabled' : ''}>
        ${buttonText}
    </button>
`;
        
        shopContainer.appendChild(card);
    });
}

buyShopItem(itemKey) {
    const item = SHOP_ITEMS[itemKey];
    if (!item) {
        logMessage("‚ùå Objet inconnu !");
        return;
    }

    // --- NOUVEAU CALCUL DU CO√õT ---
    let cost = item.cost;
    if (Array.isArray(item.cost)) {
        let storedValue = 0;
        // R√©cup√©rer la valeur actuelle pour d√©terminer le niveau
        if (item.effect.type === 'pensionSlot') storedValue = this.permanentBoosts.pensionSlots || 0;
        else if (item.effect.type === 'permanentXP') storedValue = (this.permanentBoosts.xp || 0) * 20;

        const currentLevel = Math.floor(storedValue / item.effect.value);

        if (item.maxLevel && currentLevel >= item.maxLevel) {
            logMessage("‚ùå Niveau maximum atteint pour cet objet !");
            return;
        }
        
        // S√©curit√© si on d√©passe la taille du tableau
        cost = item.cost[currentLevel] || item.cost[item.cost.length - 1];
    }
    // -----------------------------

    if (this.questTokens < cost) {
        logMessage(`‚ùå Pas assez de Jetons ! (${this.questTokens}/${cost})`);
        return;
    }

    // D√©duire le co√ªt (calcul√© dynamiquement)
    this.questTokens -= cost;
    logMessage(`Achat : ${item.name} pour ${cost} Jetons.`);

                // G√©rer le type d'objet
                switch(item.type) {
                    case 'boost':
                        this.addBoost(item);
                        break;
                    case 'egg':
                        this.eggs[item.rarity] = (this.eggs[item.rarity] || 0) + item.amount;
                        logMessage(`‚úÖ Vous avez re√ßu ${item.amount}x ≈íuf ${item.rarity} !`);
                        this.updateEggsDisplay();
                        break;

                    // ‚úÖ AJOUT : Gestion des objets (Balles, etc.)
                    case 'item':
                        this.addItem(item.item, item.amount); 
                        break;

                    case 'permanent':
                        const effectType = item.effect.type;
                        
                        if (effectType === 'permanentXP') {
                            this.permanentBoosts.xp = (this.permanentBoosts.xp || 0) + item.effect.value;
                            logMessage(`‚úÖ Gain d'XP permanent augment√© de ${item.effect.value * 100}% !`);
                        
                        } else if (effectType === 'pensionSlot') {
                            this.permanentBoosts.pensionSlots = (this.permanentBoosts.pensionSlots || 0) + item.effect.value;
                            logMessage("‚úÖ +1 emplacement de pension permanent !");
                        }
                        break;
                    default:
                        logMessage(`‚ö†Ô∏è Type d'objet inconnu: ${item.type}`);
                }

                // Rafra√Æchir les affichages
                this.updateShopDisplay();
                this.updateBoostsDisplay();
                this.updatePensionDisplay(); 
                this.updateItemsDisplay(); // ‚úÖ AJOUT : Rafra√Æchir l'inventaire des objets
            }
            sortPokedex(sortBy) {
    // S√©curit√©
    if (!this.pokedex) this.pokedex = {};
    
    // 1. Gestion de l'inversion de l'ordre
    if (this.pokedexSortBy === sortBy) {
        // Si on clique sur le m√™me, on inverse
        this.pokedexSortOrder = (this.pokedexSortOrder === 'asc') ? 'desc' : 'asc';
    } else {
        // Si on change de crit√®re, on remet un ordre logique par d√©faut
        this.pokedexSortBy = sortBy;
        // Par d√©faut : 'asc' pour ID/Nom, 'desc' pour Raret√©/Compte
        this.pokedexSortOrder = (sortBy === 'rarity' || sortBy === 'count') ? 'desc' : 'asc';
    }

    const pokedexArray = Object.values(this.pokedex);
    const order = this.pokedexSortOrder === 'asc' ? 1 : -1;

    // 2. Mise √† jour visuelle des boutons (Classe active + Fl√®che CSS)
    ['id', 'name', 'rarity', 'count', 'type'].forEach(type => {
        const btn = document.getElementById('sort-pokedex-' + type);
        if (btn) {
            btn.classList.remove('active', 'asc', 'desc'); // Nettoyage complet
        }
    });
    
    const activeBtn = document.getElementById('sort-pokedex-' + sortBy);
    if (activeBtn) {
        activeBtn.classList.add('active');
        // Ajoute une classe pour que le CSS affiche la fl√®che (si vous avez le CSS correspondant)
        activeBtn.classList.add(this.pokedexSortOrder);
        
        // Fallback texte si pas de CSS : Ajout d'une fl√®che temporaire
        // (Optionnel si vous avez d√©j√† le CSS .sort-btn.active::after)
        // activeBtn.innerHTML = activeBtn.innerHTML.split(' ')[0] + (order === 1 ? ' ‚Üë' : ' ‚Üì');
    }
    
    // 3. Le Tri
    pokedexArray.sort((a, b) => {
        let valA, valB;

        switch(sortBy) {
            case 'id':
                const ids = (typeof POKEMON_SPRITE_IDS !== 'undefined') ? POKEMON_SPRITE_IDS : {};
                valA = ids[a.name] || 9999;
                valB = ids[b.name] || 9999;
                return (valA - valB) * order;
                
            case 'name':
                return a.name.localeCompare(b.name) * order;
                
            case 'rarity':
                const rarityOrder = {'common': 1, 'rare': 2, 'epic': 3, 'legendary': 4};
                valA = rarityOrder[a.rarity] || 0;
                valB = rarityOrder[b.rarity] || 0;
                return (valA - valB) * order;
                
            case 'count':
                return (a.count - b.count) * order;
                
            case 'type':
                return a.type.localeCompare(b.type) * order;
                
            default:
                return 0;
        }
    });
    
    // 4. Reconstruction
    this.pokedex = {};
    pokedexArray.forEach(entry => {
        const key = entry.name + "_" + entry.type + "_" + entry.rarity + (entry.hasShiny ? "_shiny" : "");
        this.pokedex[key] = entry;
    });
    
    this.updatePokedexDisplay();
}

            

updatePlayerStatsDisplay() {
    // Appliquer les boosts
    const hpWithBoost = this.getPlayerMaxHp();
    const attackWithBoost = Math.floor(this.playerMainStats.attack * (1 + this.getStatBoostMultiplier('attack')));
    const defenseWithBoost = Math.floor(this.playerMainStats.defense * (1 + this.getStatBoostMultiplier('defense')));
    const speedWithBoost = Math.floor(this.playerMainStats.speed * (1 + this.getStatBoostMultiplier('speed')));
    
    // --- 1. Mettre √† jour les Stats de Combat ---
    // Note : On cible maintenant .stat-pill-value au lieu de .stat-value
    document.getElementById('headerStatHP').querySelector('.stat-value').innerText = formatNumber(hpWithBoost);
    document.getElementById('headerStatAtk').querySelector('.stat-value').innerText = formatNumber(attackWithBoost);
    document.getElementById('headerStatDef').querySelector('.stat-value').innerText = formatNumber(defenseWithBoost);
    document.getElementById('headerStatSpd').querySelector('.stat-value').innerText = formatNumber(speedWithBoost);

    // Recalcul des gains (inchang√©)
    const pensionStats = this.calculatePensionStats();
    const baseContribution = 0.10;
    const towerBonus = this.permanentBoosts.team_contribution || 0;
    const teamContributionRate = baseContribution + towerBonus;
    const vitaminBonus = {
        hp: 1 + (this.activeVitamins.hp || 0) + (this.activeVitamins.all || 0),
        attack: 1 + (this.activeVitamins.attack || 0) + (this.activeVitamins.all || 0),
        defense: 1 + (this.activeVitamins.defense || 0) + (this.activeVitamins.all || 0),
        speed: 1 + (this.activeVitamins.speed || 0) + (this.activeVitamins.all || 0)
    };
    const totalHPGain = ((this.playerTeamStats.hp * teamContributionRate) + pensionStats.hp) * vitaminBonus.hp;
    const totalAttackGain = ((this.playerTeamStats.attack * teamContributionRate) + pensionStats.attack) * vitaminBonus.attack;
    const totalDefenseGain = ((this.playerTeamStats.defense * teamContributionRate) + pensionStats.defense) * vitaminBonus.defense;
    const totalSpeedGain = ((this.playerTeamStats.speed * teamContributionRate) + pensionStats.speed) * vitaminBonus.speed;

    // Affichage des gains
    document.getElementById('playerHPGain').textContent = `+${formatNumber(totalHPGain)}/s`;
    document.getElementById('playerAttackGain').textContent = `+${formatNumber(totalAttackGain)}/s`;
    document.getElementById('playerDefenseGain').textContent = `+${formatNumber(totalDefenseGain)}/s`;
    document.getElementById('playerSpeedGain').textContent = `+${formatNumber(totalSpeedGain)}/s`;

    // --- 2. Mettre √† jour les Ressources ---
    // Note : On cible maintenant .resource-val
    document.getElementById('headerStatMoney').querySelector('.resource-val').innerText = formatNumber(this.pokedollars);
    document.getElementById('headerStatTokens').querySelector('.resource-val').innerText = formatNumber(this.questTokens);
    document.getElementById('headerStatMarques').querySelector('.resource-val').innerText = formatNumber(this.marquesDuTriomphe);
}

 // OPTIMISATION : Affichage Combat (Dirty Checking Avanc√©)
    updateCombatDisplay() {
        if (!this.ui) this.initUiCache();
        const ui = this.ui; 

        // --- 1. JOUEUR ---
        if (this.currentPlayerCreature) {
            const creature = this.currentPlayerCreature;
            let maxHp = this.arenaState.active ? creature.maxHp : this.getPlayerMaxHp();
            let currentHp = this.arenaState.active ? creature.currentHp : (creature.mainAccountCurrentHp ?? maxHp);
            
            // S√©curit√© NaN
            if (isNaN(maxHp) || maxHp === 0) maxHp = 1;
            const hpRatio = Math.max(0, Math.min(1, currentHp / maxHp));

            // Statuts
            const statusIcon = creature.hasStatusEffect() && STATUS_ICONS[creature.statusEffect.type] ? STATUS_ICONS[creature.statusEffect.type] : '';
            if (ui.playerStatus && ui.playerStatus.innerHTML !== statusIcon) ui.playerStatus.innerHTML = statusIcon;
            
            // Sprite (Optimisation : Ne toucher au SRC que si diff√©rent)
            const playerSpriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, true);
            if(ui.playerSprite) {
                // getAttribute est plus rapide que lire .src qui renvoie l'URL absolue compl√®te
                const currentSrc = ui.playerSprite.getAttribute('src');
                if (currentSrc !== playerSpriteUrl) {
                    ui.playerSprite.src = playerSpriteUrl;
                }
            }
            
            // Textes (Dirty Checking via le helper updateTextContent)
            this.updateTextContent(ui.playerName, creature.name + (creature.hasStatusEffect() ? ` [${creature.getStatusEffectName()}]` : ""));
            this.updateTextContent(ui.playerLevel, `Niv. ${creature.level} ${creature.prestige > 0 ? `‚òÖ${creature.prestige}` : ''}`);
            
            // Barres (GPU)
            this.updateTransformScaleX(ui.playerHpFill, hpRatio);
            this.updateTextContent(ui.playerHpText, `${formatNumber(currentHp)} / ${formatNumber(maxHp)}`);

            // Stats
            const stats = this.getEffectiveStats();
            const statsText = `‚öîÔ∏è ${formatNumber(stats.attack)} | üõ°Ô∏è ${formatNumber(stats.defense)} | üëü ${formatNumber(stats.speed)}`;
            if(ui.playerStats && ui.playerStats.innerHTML !== statsText) ui.playerStats.innerHTML = statsText;

            // ATB
            const pThreshold = creature.actionThreshold || 10000;
            const rawAtbRatio = creature.actionGauge / pThreshold;
            this.updateTransformScaleX(ui.playerATB, Math.min(1, rawAtbRatio));

            // Stack ATB (Couleur)
            const turnsStored = Math.floor(rawAtbRatio);
            const barColor = turnsStored > 1 ? '#eab308' : '#3b82f6';
            if (ui.playerATB.style.backgroundColor !== barColor) { // Evite le repaint si couleur identique
                ui.playerATB.style.backgroundColor = barColor;
            }

            // ULTIME (Optimisation visuelle)
            if (ui.ultBtn && creature) {
                const ult = creature.ultimateAbility;
                const ultRatio = ult ? Math.min(1, creature.ultimateCharge / ult.chargeNeeded) : 0;
                this.updateTransformScaleX(ui.ultFill, ultRatio);
                
                const isActive = creature.ultimateActive;
                const isReady = ult && creature.ultimateCharge >= ult.chargeNeeded;
                
                // Gestion des classes CSS (plus performant que le style inline)
                if (isActive) {
                    if (!ui.ultBtn.classList.contains('active')) {
                        ui.ultBtn.disabled = true;
                        ui.ultBtn.classList.add('active');
                        ui.ultBtn.classList.remove('ready');
                        this.updateTextContent(ui.ultText, "‚ö° ACTIF");
                    }
                } else if (isReady) {
                    if (!ui.ultBtn.classList.contains('ready')) {
                        ui.ultBtn.disabled = false;
                        ui.ultBtn.classList.add('ready');
                        ui.ultBtn.classList.remove('active');
                        this.updateTextContent(ui.ultText, "‚òÖ PR√äT !");
                    }
                } else {
                    if (ui.ultBtn.classList.contains('ready') || ui.ultBtn.classList.contains('active')) {
                        ui.ultBtn.disabled = true;
                        ui.ultBtn.classList.remove('ready', 'active');
                    }
                    // Mise √† jour du pourcentage seulement si n√©cessaire
                    const pctText = Math.floor(ultRatio * 100) + "%";
                    this.updateTextContent(ui.ultText, pctText);
                }
            }
        }

        // --- 2. ENNEMI ---
        if ((this.combatState === 'starting' || this.combatState === 'fighting' || this.combatState === 'capture') && this.currentEnemy) {
            const enemy = this.currentEnemy;
            let maxHp = enemy.maxHp || 1; 
            const enemyHpRatio = Math.max(0, Math.min(1, enemy.currentHp / maxHp));

            const enemyStatusIcon = enemy.hasStatusEffect() && STATUS_ICONS[enemy.statusEffect.type] ? STATUS_ICONS[enemy.statusEffect.type] : '';
            if(ui.enemyStatus && ui.enemyStatus.innerHTML !== enemyStatusIcon) ui.enemyStatus.innerHTML = enemyStatusIcon;

            const enemySpriteUrl = getPokemonSpriteUrl(enemy.name, enemy.isShiny, false);
            if(ui.enemySprite) {
                const currentSrc = ui.enemySprite.getAttribute('src');
                if (currentSrc !== enemySpriteUrl) {
                    ui.enemySprite.src = enemySpriteUrl;
                }
                if(ui.enemySprite.style.opacity !== '1') ui.enemySprite.style.opacity = '1';
            }

            let eName = enemy.name;
            if (enemy.isBoss) eName = "[BOSS] " + eName;
            if (enemy.isEpic) eName = "[EPIC] " + eName;
            if (enemy.tier > 0) eName += ` [T${enemy.tier}]`;
            
            this.updateTextContent(ui.enemyName, eName + (enemy.hasStatusEffect() ? ` [${enemy.getStatusEffectName()}]` : ""));
            this.updateTextContent(ui.enemyLevel, `Niv. ${enemy.level}`);
            
            this.updateTransformScaleX(ui.enemyHpFill, enemyHpRatio);
            
            const rawEnemyAtb = enemy.actionGauge / (enemy.actionThreshold || 10000);
            this.updateTransformScaleX(ui.enemyATB, Math.min(1, rawEnemyAtb));
            
            this.updateTextContent(ui.enemyHpText, `${formatNumber(enemy.currentHp)} / ${formatNumber(maxHp)}`);
            
            const eStatsText = `‚öîÔ∏è ${formatNumber(enemy.attack)} | üõ°Ô∏è ${formatNumber(enemy.defense)} | üëü ${formatNumber(enemy.speed)}`;
            if(ui.enemyStats && ui.enemyStats.innerHTML !== eStatsText) ui.enemyStats.innerHTML = eStatsText;

        } else {
            // MODE ATTENTE (Reset UI)
            const placeholderUrl = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png";
            if(ui.enemySprite) {
                 const currentSrc = ui.enemySprite.getAttribute('src');
                 if (currentSrc !== placeholderUrl) ui.enemySprite.src = placeholderUrl;
                 if (ui.enemySprite.style.opacity !== '0.3') ui.enemySprite.style.opacity = '0.3';
            }
            this.updateTextContent(ui.enemyName, "En attente...");
            this.updateTextContent(ui.enemyLevel, "Niveau -");
            this.updateTransformScaleX(ui.enemyHpFill, 0);
            this.updateTransformScaleX(ui.enemyATB, 0);
            this.updateTextContent(ui.enemyHpText, "- / -");
            if(ui.enemyStats) ui.enemyStats.innerHTML = "‚öîÔ∏è - | üõ°Ô∏è - | üëü -";
            if(ui.effectiveness) ui.effectiveness.classList.remove('show');
        }

        // --- BOUTONS (Optimisation classes) ---
        const inCombat = (this.combatState === 'starting' || this.combatState === 'fighting') && this.currentEnemy;
        const alive = this.playerTeam ? this.playerTeam.filter(c => c.isAlive()).length : 0;

        if (ui.autoSelectBtn) {
            if (alive > 1) {
                if(ui.autoSelectBtn.disabled !== !inCombat) ui.autoSelectBtn.disabled = !inCombat;
                const targetOpacity = inCombat ? '1' : '0.5';
                if(ui.autoSelectBtn.style.opacity !== targetOpacity) ui.autoSelectBtn.style.opacity = targetOpacity;
                
                const hasActive = ui.autoSelectBtn.classList.contains('auto-active');
                if (this.autoSelectEnabled && !hasActive) ui.autoSelectBtn.classList.add('auto-active');
                else if (!this.autoSelectEnabled && hasActive) ui.autoSelectBtn.classList.remove('auto-active');
            } else {
                if(!ui.autoSelectBtn.disabled) ui.autoSelectBtn.disabled = true;
                if(ui.autoSelectBtn.style.opacity !== '0.3') ui.autoSelectBtn.style.opacity = '0.3';
            }
        }

        if (ui.forfeitBtn) {
            ui.forfeitBtn.classList.remove('hidden');
            if(ui.forfeitBtn.disabled !== !inCombat) ui.forfeitBtn.disabled = !inCombat;
            const targetOpacity = inCombat ? '1' : '0.5';
            if(ui.forfeitBtn.style.opacity !== targetOpacity) ui.forfeitBtn.style.opacity = targetOpacity;
        }
    }

updateTowerBuffsDisplay() {
        const container = document.getElementById('towerBuffsContainer');
        if (!container) return;

        // 1. Si la tour n'est pas active, on cache tout
        if (!this.towerState.isActive || !this.towerState.buffs) {
            container.style.display = 'none';
            return;
        }

        // 2. Si active, on affiche
        container.style.display = 'flex';
        container.innerHTML = '<div style="width:100%; text-align:center; font-size:10px; color:#666; margin-bottom:5px;">RELIQUES ACTIVES</div>';
        
        const buffs = this.towerState.buffs;
        let hasBuffs = false;

        // Helper pour cr√©er un badge
        const createChip = (text, type, icon) => {
            const chip = document.createElement('div');
            chip.className = `tower-buff-chip buff-${type}`;
            chip.innerHTML = `${icon} ${text}`;
            container.appendChild(chip);
            hasBuffs = true;
        };
		// Vitesse
        if (buffs.speed_mult && buffs.speed_mult !== 1) {
            const val = Math.round((buffs.speed_mult - 1) * 100);
            createChip(`SPD +${val}%`, 'speed', 'üëü'); // Cr√©ez un style .buff-speed si vous voulez (bleu ciel)
        }

        // Esquive
        if (buffs.dodge_chance > 0) {
            const val = Math.round(buffs.dodge_chance * 100);
            createChip(`DODGE ${val}%`, 'special', 'üëª');
        }

        // Renvoi
        if (buffs.reflect_percent > 0) {
            const val = Math.round(buffs.reflect_percent * 100);
            createChip(`THORNS ${val}%`, 'def', 'üåµ');
        }

        // Pr√©dateur
        if (buffs.status_dmg_bonus > 0) {
            const val = Math.round(buffs.status_dmg_bonus * 100);
            createChip(`PREDATOR +${val}%`, 'atk', 'üêØ');
        }

// PV Max
        if (buffs.max_hp_mult && buffs.max_hp_mult !== 1) {
            const val = Math.round((buffs.max_hp_mult - 1) * 100);
            createChip(`HP +${val}%`, 'life', 'ü§é');
        }

        // R√©g√©n√©ration
        if (buffs.regen_percent > 0) {
            const val = Math.round(buffs.regen_percent * 100);
            createChip(`REGEN ${val}%`, 'life', 'üíç');
        }

       
        // --- Analyse des Stats ---

        // Attaque
        if (buffs.attack_mult && buffs.attack_mult !== 1) {
            const val = Math.round((buffs.attack_mult - 1) * 100);
            const sign = val > 0 ? '+' : '';
            createChip(`ATK ${sign}${val}%`, 'atk', '‚öîÔ∏è');
        }

        // D√©fense
        if (buffs.defense_mult && buffs.defense_mult !== 1) {
            const val = Math.round((buffs.defense_mult - 1) * 100);
            const sign = val > 0 ? '+' : '';
            createChip(`DEF ${sign}${val}%`, 'def', 'üõ°Ô∏è');
        }

        // Critique
        if (buffs.crit_chance > 0) {
            const val = Math.round(buffs.crit_chance * 100);
            createChip(`CRIT ${val}%`, 'crit', 'üéØ');
        }

        // Vol de Vie
        if (buffs.lifesteal > 0) {
            const val = Math.round(buffs.lifesteal * 100);
            createChip(`DRAIN ${val}%`, 'life', 'ü©∏');
        }

        // ‚úÖ C'EST ICI LA CORRECTION (On v√©rifie execute_percent)
        if (buffs.execute_percent && buffs.execute_percent > 0) {
            const val = Math.round(buffs.execute_percent * 100);
            createChip(`EXECUTE +${val}%`, 'special', 'ü™ì');
        }

        // Message si aucun buff
        if (!hasBuffs) {
            container.innerHTML += '<div style="font-size:11px; color:#999; font-style:italic;">Aucun effet actif</div>';
        }
    }

            updateDisplay() {
                this.updateTeamDisplay();
                this.updateStorageDisplay();
                this.updatePensionDisplay();
                this.updateEggsDisplay();
                this.updateUpgradesDisplay();
                this.updateCombatDisplay();
				this.updateTowerBuffsDisplay();
                this.updatePokedexDisplay();
				 this.updateArenasDisplay();
				 this.displayActiveTalents();
				 this.updateAchievementsDisplay();
				 this.updateQuestsDisplay();
				 this.updateItemsDisplay();
    this.updateStatBoostsDisplay();
				 this.updateTowerDisplay();
				 this.updateTowerShopDisplay();
this.updateShopDisplay();
this.updatePensionVisibility();
this.updateBoostsDisplay();
this.updateExpeditionsDisplay();

            }

            getTypeEffectiveness(attackerType, defenderType) {
                return TYPE_EFFECTIVENESS[attackerType] && TYPE_EFFECTIVENESS[attackerType][defenderType] || 1;
            }

            getEffectivenessText(effectiveness) {
    if (effectiveness > 1) {
        return { text: "‚ñ≤ Super Efficace", color: "#22c55e", class: "super-effective" };
    } else if (effectiveness < 1) {
        return { text: "‚ñº Pas Efficace", color: "#ef4444", class: "not-effective" };
    } else {
        return { text: "-", color: "#666", class: "normal-effective" };
    }
}

            findBestCreatureForEnemy() {
                if (!this.currentEnemy || this.playerTeam.length === 0) return -1;
                
                let bestIndex = -1;
                let bestEffectiveness = 0;
                let bestStats = 0;
                
                for (let i = 0; i < this.playerTeam.length; i++) {
                    const creature = this.playerTeam[i];
                    if (!creature.isAlive()) continue;
                    
                    const effectiveness = this.getTypeEffectiveness(creature.type, this.currentEnemy.type);
                    const statsSum = creature.attack + creature.defense + creature.speed;
                    
                    if (effectiveness > bestEffectiveness || 
                        (effectiveness === bestEffectiveness && statsSum > bestStats)) {
                        bestIndex = i;
                        bestEffectiveness = effectiveness;
                        bestStats = statsSum;
                    }
                }
                
                return bestIndex;
            }

            selectBestCreature() {
                const bestIndex = this.findBestCreatureForEnemy();
                
                if (bestIndex === -1) {
                    logMessage("Aucune creature vivante trouvee !");
                    return;
                }
                
                if (bestIndex === this.activeCreatureIndex) {
                    logMessage("La creature active est deja optimale !");
                    return;
                }
                
                const bestCreature = this.playerTeam[bestIndex];
                const effectiveness = this.getTypeEffectiveness(bestCreature.type, this.currentEnemy.type);
                
                this.setActiveCreature(bestIndex);
                
                let message = bestCreature.name + " selectionne automatiquement !";
                if (effectiveness > 1) {
                    message += " (Avantage de type!)";
                } else if (effectiveness < 1) {
                    message += " (Meilleure option disponible)";
                }
                
                logMessage(message);
            }

            toggleAutoSelect() {
        this.autoSelectEnabled = !this.autoSelectEnabled;
        
        const btn = document.getElementById('autoSelectBtn');
        if (btn) {
            if (this.autoSelectEnabled) {
                btn.classList.add('auto-active');
                logMessage("Auto-s√©lection activ√©e !");
            } else {
                btn.classList.remove('auto-active');
                logMessage("Auto-s√©lection d√©sactiv√©e !");
            }
        }
    }

            forfeitCombat() {
        // 1. Cas Tour de Combat : Abandon strat√©gique
        if (this.towerState.isActive) {
            if (confirm("Voulez-vous quitter la Tour ?\nVous conserverez toutes les Marques gagn√©es jusqu'ici.")) {
                logMessage("üè≥Ô∏è Vous d√©cidez de quitter la Tour avec vos gains.");
                this.endTowerRun(true); // true = Abandon volontaire
            }
            return;
        }

        // 2. Cas Ar√®ne
        if (this.arenaState.active) {
            this.loseArena("Abandon");
            return;
        }

        // 3. Cas Capture en cours
        if (document.getElementById('captureModal').classList.contains('show')) {
            this.skipCapture();
            return;
        }
        
        // 4. Cas Combat Standard (Zone)
        if (this.combatState !== 'fighting' && this.combatState !== 'starting') {
            logMessage("Aucun combat en cours !");
            return;
        }
        
        this.combatState = 'waiting';
        this.lastCombatTime = Date.now();
        this.currentEnemy = null;
        
        logMessage("Combat abandonn√© ! Prochain combat dans quelques secondes...");
        this.updateCombatDisplay();
    }

           prestigeCreature(creatureIndex, location) {
        let creature;

        // 1. Identifier la cr√©ature selon l'endroit
        if (location === 'pension') {
            creature = this.pension[creatureIndex];
        } else if (location === 'storage') {
            creature = this.storage[creatureIndex];
        } else {
            // Par d√©faut, ou si location === 'team'
            creature = this.playerTeam[creatureIndex];
        }
        
        if (!creature) {
            console.error("Erreur Prestige : Cr√©ature introuvable √† l'index " + creatureIndex + " dans " + location);
            return;
        }
        
        const maxLevel = 100 + (creature.prestige * 10);
        if (creature.level < maxLevel) {
            logMessage(creature.name + " doit etre niveau " + maxLevel + " pour prestige !");
            return;
        }
        
        const shardKey = getShardKey(creature.name, creature.rarity);
        const shardsNeeded = this.getPrestigeCost(creature.prestige); 
        
        const currentShards = this.shards[shardKey] || 0;
        
        if (currentShards < shardsNeeded) {
            logMessage("Pas assez de shards ! (" + currentShards + "/" + shardsNeeded + ")");
            return;
        }
        
        this.shards[shardKey] -= shardsNeeded;
        creature.prestige++;
		// ‚úÖ GAIN DU TOKEN
        if (!creature.prestigeTokens) creature.prestigeTokens = 0;
        creature.prestigeTokens++; 
        
        creature.level = 1;
        creature.exp = 0;
        creature.expToNext = creature.getExpToNext();
        
        creature.recalculateStats();
        creature.heal();
        creature.currentStamina = creature.maxStamina;
        creature.level = 1;
        creature.exp = 0;
        creature.expToNext = creature.getExpToNext();
        
        creature.recalculateStats();
        creature.heal();
        creature.currentStamina = creature.maxStamina;
        
        this.stats.prestigeCount++;
        this.updateTeamPowerStat();
        this.checkSpecialQuests('prestigeCount');
        this.checkAchievements('prestigeCount');
        this.checkAchievements('team_changed');

        const shinyText = creature.isShiny ? " ‚ú®SHINY‚ú®" : "";
        logMessage("PRESTIGE ! " + creature.name + shinyText + " monte au prestige " + creature.prestige + " ! (+20% stats, +50 stamina max)");
		logMessage(`‚≠ê PRESTIGE ! ${creature.name} gagne +1 Jeton de Prestige !`);
        toast.success("Prestige R√©ussi !", `${creature.name} est pass√© Prestige ${creature.prestige} !`);
        
        this.calculateTeamStats();
        this.updateTeamDisplay();
        this.updateStorageDisplay();
        this.updatePensionDisplay();
        // Mise √† jour des compteurs de shards du recycleur si ouvert
        if (document.getElementById('shop-recycleur').classList.contains('active')) {
            this.updateRecyclerDisplay();
        }
    }

// LOGIQUE : D√©pense d'un jeton de prestige
    spendPrestigeToken(creatureIndex, location, stat) {
        let creature;
        if (location === 'team') creature = this.playerTeam[creatureIndex];
        else if (location === 'storage') creature = this.storage[creatureIndex];
        else if (location === 'pension') creature = this.pension[creatureIndex];

        if (!creature) return;

        if (creature.prestigeTokens > 0) {
            creature.prestigeTokens--;
            
            if (!creature.prestigeBonuses) creature.prestigeBonuses = { hp: 0, attack: 0, defense: 0, speed: 0 };
            creature.prestigeBonuses[stat]++;
            
            creature.recalculateStats();
            
            // Feedback
            const statNames = { hp: 'PV', attack: 'ATK', defense: 'DEF', speed: 'VIT' };
            logMessage(`üí™ ${creature.name} : +5% ${statNames[stat]} permanent !`);
            
            // Rafra√Æchir le modal pour voir le changement imm√©diat
            this.showCreatureModal(creatureIndex, location);
            
            // Rafra√Æchir les affichages globaux
            this.updateDisplay();
        }
    }
	
            moveToTeam(creatureIndex) {
    const maxTeamSize = 6 + this.getAccountTalentBonus('team_slot');
    
    if (this.playerTeam.length >= maxTeamSize) {
        logMessage("Equipe pleine ! (" + this.playerTeam.length + "/" + maxTeamSize + ")");
        return;
    }
  
    
    if (creatureIndex < 0 || creatureIndex >= this.storage.length) return;
    
    const creature = this.storage.splice(creatureIndex, 1)[0];
    this.playerTeam.push(creature);
    
    logMessage(creature.name + " rejoint l'equipe principale !");
    this.stats.pensionCount = this.pension.length;
    this.calculateTeamStats();
    this.updateTeamDisplay();
    this.updateTeamPowerStat();
	this.checkSpecialQuests('pensionCount');
	 this.displayActiveTalents();
    this.updateStorageDisplay();
}  
                

            moveToStorage(creatureIndex) {
                if (this.playerTeam.length <= 1) {
                    logMessage("Impossible de retirer la derniere creature de l'equipe !");
                    return;
                }
                
                if (creatureIndex < 0 || creatureIndex >= this.playerTeam.length) return;
                
                if (creatureIndex === this.activeCreatureIndex) {
                    this.activeCreatureIndex = creatureIndex === 0 ? 1 : 0;
                } else if (creatureIndex < this.activeCreatureIndex) {
                    this.activeCreatureIndex--;
                }
                
                const creature = this.playerTeam.splice(creatureIndex, 1)[0];
                this.storage.push(creature);
                
                logMessage(creature.name + " va au stockage !");
                this.stats.pensionCount = this.pension.length;
                this.calculateTeamStats();
                this.updateTeamDisplay();
				this.checkSpecialQuests('pensionCount');
				 this.displayActiveTalents();
                this.updateStorageDisplay();
            }

            moveToPension(creatureIndex, fromTeam = false) {
                const maxSlots = this.getPensionSlots();
                
                if (maxSlots === 0) {
                    logMessage("La pension n'est pas encore debloquee ! Ameliorez-la d'abord.");
                    return;
                }
                
                if (this.pension.length >= maxSlots) {
                    logMessage("La pension est pleine ! (" + this.pension.length + "/" + maxSlots + ")");
                    return;
                }
                
                let creature;
                if (fromTeam) {
                    if (this.playerTeam.length <= 1) {
                        logMessage("Impossible de retirer la derniere creature de l'equipe !");
                        return;
                    }
                    
                    if (creatureIndex < 0 || creatureIndex >= this.playerTeam.length) return;
                    
                    if (creatureIndex === this.activeCreatureIndex) {
                        this.activeCreatureIndex = creatureIndex === 0 ? 1 : 0;
                    } else if (creatureIndex < this.activeCreatureIndex) {
                        this.activeCreatureIndex--;
                    }
                    
                    creature = this.playerTeam.splice(creatureIndex, 1)[0];
                } else {
                    if (creatureIndex < 0 || creatureIndex >= this.storage.length) return;
                    creature = this.storage.splice(creatureIndex, 1)[0];
                }
                
                this.pension.push(creature);
                logMessage(creature.name + " rejoint la pension !");
                this.stats.pensionCount = this.pension.length;
                this.checkAchievements('pensionCount'); 
    this.checkSpecialQuests('pensionCount');   
                this.calculateTeamStats();
				 this.displayActiveTalents();
                this.updateTeamDisplay();
                this.updateStorageDisplay();
                this.updatePensionDisplay();
            }

            moveFromPension(creatureIndex, toTeam = false) {
                if (creatureIndex < 0 || creatureIndex >= this.pension.length) return;
                
                const creature = this.pension.splice(creatureIndex, 1)[0];
                
                if (toTeam) {
                    if (this.playerTeam.length >= 6) {
                        logMessage("Equipe pleine ! Creature envoyee au stockage.");
                        this.storage.push(creature);
                    } else {
                        this.playerTeam.push(creature);
                        logMessage(creature.name + " quitte la pension et rejoint l'equipe !");
                    }
                } else {
                    this.storage.push(creature);
                    logMessage(creature.name + " quitte la pension et va au stockage !");
                }
                this.stats.pensionCount = this.pension.length;
               this.checkAchievements('pensionCount');
    this.checkSpecialQuests('pensionCount');
                this.calculateTeamStats();
                this.updateTeamDisplay();
                this.updateStorageDisplay();
				this.displayActiveTalents();
                this.updatePensionDisplay();
            }

            setActiveCreature(index) {
                if (index < 0 || index >= this.playerTeam.length) return;
                
                this.activeCreatureIndex = index;
                
                if (this.combatState === 'fighting' || this.combatState === 'starting') {
                    const newCreature = this.playerTeam[index];
                    
                    if (this.faintedThisCombat && this.faintedThisCombat.has(newCreature.name)) {
                        logMessage(newCreature.name + " est KO et ne peut pas rejoindre ce combat !");
                        return;
                    }
                    
                    if (newCreature.isAlive()) {
                        const currentMainHp = this.currentPlayerCreature ? this.currentPlayerCreature.mainAccountCurrentHp : this.playerMainStats.hp;
                        
                        this.currentPlayerCreature = newCreature;
                        this.currentPlayerCreature.mainAccountCurrentHp = currentMainHp;
						
                        
                        logMessage(newCreature.name + " entre en combat !");
                    } else {
                        logMessage(newCreature.name + " est KO et ne peut pas combattre !");
                        return;
                    }
                }
                
                this.updateTeamDisplay();
                this.updateCombatDisplay();
            }

            sortStorage(sortBy) {
    // 1. Gestion de l'ordre (Ascendant / Descendant)
    if (this.sortBy === sortBy) {
        this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc';
    } else {
        this.sortBy = sortBy;
        // Par d√©faut, on trie les stats du plus grand au plus petit (desc)
        // Mais pour le Pok√©dex ou le Type, on veut souvent l'ordre alphab√©tique (asc)
        const ascDefaults = ['pokedex', 'type']; 
        this.sortOrder = ascDefaults.includes(sortBy) ? 'asc' : 'desc';
    }

    // 2. Mise √† jour visuelle des boutons
    // N'oubliez pas d'ajouter 'type' dans cette liste !
    const sortButtons = ['pokedex', 'level', 'rarity', 'hp', 'attack', 'defense', 'speed', 'total', 'shards', 'type'];
    
    sortButtons.forEach(btnId => {
        const btn = document.getElementById('sort-' + btnId);
        if (btn) {
            btn.className = 'sort-btn'; // Reset classe
            if (this.sortBy === btnId) {
                btn.className += ' active';
                if (this.sortOrder === 'asc') btn.className += ' asc';
            }
        }
    });

    // 3. Le Tri
    this.storage.sort((a, b) => {
        let valueA, valueB;

        switch(sortBy) {
            case 'type': // ‚úÖ NOUVEAU CAS
                valueA = a.type;
                valueB = b.type;
                // Astuce : Si les types sont √©gaux, on trie par niveau ensuite pour que ce soit propre
                if (valueA === valueB) return b.level - a.level;
                break;
                
            case 'pokedex':
                const ids = (typeof POKEMON_SPRITE_IDS !== 'undefined') ? POKEMON_SPRITE_IDS : {};
                valueA = ids[a.name] || 9999;
                valueB = ids[b.name] || 9999;
                break;
                
            case 'level':
                valueA = a.level; valueB = b.level;
                break;
            case 'rarity':
                const rarityOrder = {'common': 1, 'rare': 2, 'epic': 3, 'legendary': 4};
                valueA = rarityOrder[a.rarity] || 0;
                valueB = rarityOrder[b.rarity] || 0;
                break;
            case 'hp':
                valueA = a.maxHp; valueB = b.maxHp;
                break;
            case 'attack':
                valueA = a.attack; valueB = b.attack;
                break;
            case 'defense':
                valueA = a.defense; valueB = b.defense;
                break;
            case 'speed':
                valueA = a.speed; valueB = b.speed;
                break;
            case 'total':
                valueA = a.maxHp + a.attack + a.defense + a.speed;
                valueB = b.maxHp + b.attack + b.defense + b.speed;
                break;
            case 'shards':   
                // Fonction utilitaire pour la cl√© de shard
                const getSKey = (c) => (typeof getShardKey === 'function') ? getShardKey(c.name, c.rarity) : c.name;
                valueA = this.shards[getSKey(a)] || 0;
                valueB = this.shards[getSKey(b)] || 0;
                break;
            default:
                return 0;
        }

        // ‚úÖ LOGIQUE DE COMPARAISON UNIFI√âE (Nombres & Textes)
        if (typeof valueA === 'string') {
            return this.sortOrder === 'asc' 
                ? valueA.localeCompare(valueB) 
                : valueB.localeCompare(valueA);
        } else {
            return this.sortOrder === 'asc' 
                ? valueA - valueB 
                : valueB - valueA;
        }
    });

    this.updateStorageDisplay();
}
          

            updateTeamDisplay() {
                const teamList = document.getElementById('teamList');
                const teamCount = document.getElementById('teamCount');
                
                const maxTeamSize = 6 + this.getAccountTalentBonus('team_slot');
                teamCount.textContent = this.playerTeam.length + "/" + maxTeamSize;
                teamList.innerHTML = ''; // Vider la liste
                
                for (let i = 0; i < maxTeamSize; i++) {
                    
                    if (i < this.playerTeam.length) {
                        const creature = this.playerTeam[i];
                        const card = document.createElement('div');
                        card.className = "creature-card rarity-" + creature.rarity;
                        
                        card.style.cursor = 'pointer';
                        card.setAttribute('onclick', `game.showCreatureModal(${i}, 'team')`);

                        if (creature.isShiny) {
                            card.className += " shiny";
                        }
                        if (i === this.activeCreatureIndex) {
                            card.classList.add('active');
                        }
                        if (!creature.isAlive()) {
                            card.classList.add('fainted');
                        }
                        
                        // --- ‚úÖ D√âCLARATIONS D√âPLAC√âES ICI ---
                        const maxLevel = 100 + (creature.prestige * 10);
                        const shardKey = getShardKey(creature.name, creature.rarity);
                        const currentShards = this.shards[shardKey] || 0;
                        const prestigeCost = this.getPrestigeCost(creature.prestige);
                        const expPercent = (creature.exp / creature.expToNext) * 100;
                        const spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, false);
                        // --- FIN DU D√âPLACEMENT ---

                        // Utilisation pour 'prestige-ready'
                        if (creature.level >= maxLevel && currentShards >= prestigeCost) {
                            card.classList.add('prestige-ready');
                        }
                        
                        // Utilisation pour 'innerHTML'
                        card.innerHTML = `
                            <img src="${spriteUrl}" alt="${creature.name}" class="team-slot-sprite">
                            <div class="team-slot-name">${creature.name} ${creature.prestige > 0 ? `‚òÖ${creature.prestige}` : ''}</div>
                            <div class="team-slot-level">Niv. ${creature.level}</div>
                            
                            <div class="exp-bar" style="height: 8px; margin-top: 5px;">
                                <div class="exp-fill" style="width: ${expPercent}%;"></div>
                            </div>

                            <div class="team-slot-info">
                                <span style="color: ${creature.passiveTalent === 'robustesse' ? '#007bff' : (creature.currentStamina === 0 ? '#ef4444' : '#22c55e')};">‚ö° ${creature.currentStamina}/${creature.maxStamina}</span>
                                <span style="color: #8a2be2;">üíé ${currentShards}/${prestigeCost}</span>
                            </div>
                        `;
                        
                        teamList.appendChild(card);

                    } else {
                        // ... (slot vide) ...
                        const emptySlot = document.createElement('div');
                        emptySlot.className = "team-slot-empty";
                        emptySlot.textContent = "+";
                        teamList.appendChild(emptySlot);
                    }
                } 
                this.updateSynergyDisplay();
                this.checkAchievements('team_changed');
				
				
            }
               
           

            updateStorageDisplay() {
    const storageList = document.getElementById('storageList');
    const storageCount = document.getElementById('storageCount');
    
    // 1. R√©cup√©rer les valeurs des filtres
    const searchInput = document.getElementById('storageSearchInput');
    const searchText = searchInput ? searchInput.value.toLowerCase() : '';
    
    const typeFilterInput = document.getElementById('storageTypeFilter');
    const selectedType = typeFilterInput ? typeFilterInput.value : 'all';

    // Mise √† jour visuelle des boutons de tri (inchang√©)
    const sortButtons = ['pokedex', 'level', 'rarity', 'hp', 'attack', 'defense', 'speed', 'total', 'shards', 'type'];
    sortButtons.forEach(btnId => {
        const btn = document.getElementById('sort-' + btnId);
        if (btn) {
            btn.className = 'sort-btn';
            if (this.sortBy === btnId) {
                btn.className += ' active';
                if (this.sortOrder === 'asc') btn.className += ' asc';
            }
        }
    });
    
    storageList.innerHTML = '';
    let displayedCount = 0; 

    for (let i = 0; i < this.storage.length; i++) {
        const creature = this.storage[i]; 
        
        // --- FILTRE 1 : PAR NOM ---
        if (searchText && !creature.name.toLowerCase().includes(searchText)) {
            continue;
        }

        // --- FILTRE 2 : PAR TYPE (Nouveau) ---
        // On v√©rifie le type primaire OU le type secondaire
        if (selectedType !== 'all') {
            const isPrimary = creature.type === selectedType;
            const isSecondary = creature.secondaryType === selectedType;
            
            if (!isPrimary && !isSecondary) {
                continue; // On passe au suivant si le type ne correspond pas
            }
        }

        displayedCount++;

        const card = document.createElement('div');
        card.className = "creature-card rarity-" + creature.rarity;
        if (creature.isShiny) card.className += " shiny"; 
        card.style.opacity = "0.8"; 
        card.style.cursor = 'pointer';
        card.setAttribute('onclick', `game.showCreatureModal(${i}, 'storage')`);
        
        // Donn√©es pour l'affichage
        const maxLevel = 100 + (creature.prestige * 10);
        const shardKey = getShardKey(creature.name, creature.rarity);
        const currentShards = this.shards[shardKey] || 0;
        const prestigeCost = this.getPrestigeCost(creature.prestige);
        const expPercent = (creature.exp / creature.expToNext) * 100;
        const spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, false);
        
        if (creature.level >= maxLevel && currentShards >= prestigeCost) {
                card.classList.add('prestige-ready');
        }
        
        card.innerHTML = `
            <img src="${spriteUrl}" alt="${creature.name}" class="team-slot-sprite">
            <div class="team-slot-name">${creature.name} ${creature.prestige > 0 ? `‚òÖ${creature.prestige}` : ''}</div>
            <div class="team-slot-level">Niv. ${creature.level}</div>
            
            <div class="exp-bar" style="height: 4px; margin-top: 2px;">
                <div class="exp-fill" style="width: ${expPercent}%;"></div>
            </div>

            <div class="team-slot-info" style="justify-content: center;">
                <span style="color: #8a2be2;">üíé ${currentShards}/${prestigeCost}</span>
            </div>
        `;
        
        storageList.appendChild(card);
    } 

    storageCount.textContent = `${displayedCount}/${this.storage.length}`;

    if (displayedCount === 0 && this.storage.length > 0) {
        storageList.innerHTML = `<div style="text-align: center; color: #666; padding: 20px; grid-column: 1 / -1;">Aucun Pok√©mon ne correspond √† vos filtres.</div>`;
    }
}

            updatePensionDisplay() {
                const pensionList = document.getElementById('pensionList');
                const pensionCount = document.getElementById('pensionCount');
                const maxSlots = this.getPensionSlots();
                const transferRate = (this.getPensionTransferRate() * 100).toFixed(0);
                
                if (!pensionList || !pensionCount) return;
                
                pensionCount.textContent = this.pension.length + "/" + maxSlots;
                pensionList.innerHTML = '';
                
                if (maxSlots === 0) {
                    // ... (message pension non d√©bloqu√©e) ...
                    return;
                }
                if (this.pension.length === 0) {
                    // ... (message pension vide) ...
                    return;
                }
                
                for (let i = 0; i < this.pension.length; i++) {
                    const creature = this.pension[i];
                    const card = document.createElement('div');
                    card.className = "creature-card rarity-" + creature.rarity;
                    if (creature.isShiny) {
                        card.className += " shiny";
                    }
                    card.style.border = "1px solid #ff69b4";
                    card.style.boxShadow = "0 0 5px rgba(255, 105, 180, 0.5)";
                    card.style.cursor = 'pointer';
                    card.setAttribute('onclick', `game.showCreatureModal(${i}, 'pension')`);
                    
                    // --- ‚úÖ D√âCLARATIONS D√âPLAC√âES ICI ---
                    const maxLevel = 100 + (creature.prestige * 10);
                    const shardKey = getShardKey(creature.name, creature.rarity);
                    const currentShards = this.shards[shardKey] || 0;
                    const prestigeCost = this.getPrestigeCost(creature.prestige);
                    const spriteUrl = getPokemonSpriteUrl(creature.name, creature.isShiny, false);
                    // --- FIN DU D√âPLACEMENT ---

                    if (creature.level >= maxLevel && currentShards >= prestigeCost) {
                         card.classList.add('prestige-ready');
                    }
                    
                    const contributedHP = Math.floor(creature.maxHp * this.getPensionTransferRate());
                    const contributedATK = Math.floor(creature.attack * this.getPensionTransferRate());
                    const contributedDEF = Math.floor(creature.defense * this.getPensionTransferRate());
                    const contributedSPD = Math.floor(creature.speed * this.getPensionTransferRate());

                    card.innerHTML = `
                        <img src="${spriteUrl}" alt="${creature.name}" class="team-slot-sprite">
                        <div class="team-slot-name">${creature.name} ${creature.prestige > 0 ? `‚òÖ${creature.prestige}` : ''}</div>
                        <div class="team-slot-level">Niv. ${creature.level}</div>
                        
                        <div class="team-slot-info" style="justify-content: center;">
                            <span style="color: #8a2be2;">üíé ${currentShards}/${prestigeCost}</span>
                        </div>

                        <div style="background: rgba(255,105,180,0.2); padding: 8px; border-radius: 5px; margin-top: 5px; width: 100%; font-size: 10px;">
                            <div style="font-weight: bold; color: #ff1493; margin-bottom: 3px;">Contribution (${transferRate}%) :</div>
                            <div style="color: #666;">
                                ‚ù§Ô∏è+${contributedHP} | ‚öîÔ∏è+${contributedATK}<br>
                                üõ°Ô∏è+${contributedDEF} | üëü+${contributedSPD}
                            </div>
                        </div>
                    `;
                    
                    pensionList.appendChild(card);
                } 
            }
			
			
updateEggsDisplay() {
    const eggsContainer = document.getElementById('ballsContainer');
    const eggCount = document.getElementById('ballCount');
    
    if (!eggsContainer || !eggCount) return;

    const totalEggs = Object.values(this.eggs).reduce((sum, count) => sum + count, 0);
    eggCount.textContent = totalEggs;
    
    eggsContainer.innerHTML = '';
    
    const baseEggUrl = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/lucky-egg.png";

    Object.entries(this.eggs).forEach(([rarity, count]) => {
        if (count > 0) {
            const eggElement = document.createElement('div');
            
            eggElement.className = `ball-item rarity-${rarity} egg-clickable`;
            eggElement.setAttribute('data-rarity', rarity);
            eggElement.style.cursor = 'pointer';
            
            let filterClass = "";
            if (rarity === 'rare') filterClass = "egg-filter-rare";
            else if (rarity === 'epic') filterClass = "egg-filter-epic";
            else if (rarity === 'legendary') filterClass = "egg-filter-legendary";

            eggElement.innerHTML = `
                <div class="rarity-label ${rarity}" style="pointer-events: none; margin-bottom:2px; font-size:9px; padding:1px 4px;">
                    ${rarity.toUpperCase()}
                </div>
                
                <img src="${baseEggUrl}" class="egg-sprite ${filterClass}" alt="Oeuf ${rarity}">
                
                <div style="font-size: 13px; font-weight: bold; color:#333; pointer-events: none; line-height:1; margin-bottom: 4px;">
                    x${count}
                </div>
                
                <div style="font-size: 10px; color: #555; line-height: 1.2; opacity:0.9;">
                    Clic : x1<br>
                    Shift : x5<br>
                    <strong>Ctrl : x100</strong>
                </div>
            `;
            
            eggsContainer.appendChild(eggElement);
        }
    });
    
    if (totalEggs === 0) {
        eggsContainer.innerHTML = `
            <div style="text-align: center; color: #94a3b8; padding: 15px; grid-column: 1 / -1; border: 2px dashed #e2e8f0; border-radius: 10px;">
                <img src="${baseEggUrl}" style="width:24px; opacity:0.4; filter:grayscale(1);">
                <div style="margin-top:5px; font-size:11px;">Vide</div>
            </div>`;
    }
}
}
               
        function formatNumber(num) {
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1) + 'B';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return Math.floor(num).toString();
        }

        // Fonction Globale : Logs silencieux (Uniquement dans le modal)
window.logMessage = function(msg) {
    // 1. PAS de console.log (Demande respect√©e)
    
    // 2. On cible le modal
    const container = document.getElementById('gameLog');
    if (!container) return; // Si pas charg√©, on ignore

    // 3. Cr√©ation ligne
    const div = document.createElement('div');
    div.className = 'log-entry';
    
    const time = new Date().toLocaleTimeString('fr-FR');
    div.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;

    container.appendChild(div);

    // 4. Nettoyage (Max 50 lignes pour perf)
    if (container.children.length > 50) {
        container.removeChild(container.firstChild);
    }

    // 5. Auto-scroll si ouvert
    if (document.getElementById('logModal').classList.contains('show')) {
        container.scrollTop = container.scrollHeight;
    }
};
		
		/**
 * Affiche un texte flottant (Style Clean + Positionnement √âparpill√©).
 * @param {string} text Le texte (ex: "150")
 * @param {HTMLElement} targetContainer Le conteneur
 * @param {string} type La classe CSS
 * @param {boolean} isCritical Si true, applique le style critique
 */
function showFloatingText(text, targetContainer, type = '', isCritical = false) {
    if (!targetContainer) return;

    const textElement = document.createElement('div');
    
    // Ajout de la classe critique pour le style
    const critClass = isCritical ? ' ft-crit' : '';
    textElement.className = `floating-text ${type}${critClass}`;
    
    // Contenu : Texte simple + petit indicateur
    let content = text;
    if (isCritical) content = `${text}`;
    else if (type.includes('heal')) content = `+${text}`;
    
    textElement.textContent = content;

    // POSITIONNEMENT RESSERR√â (Moins √©parpill√©)
    
    // On r√©duit la zone horizontale : entre -20% et +20% (au lieu de -40/+40)
    const randomOffset = (Math.random() * 40) - 20; 
    textElement.style.left = `calc(50% + ${randomOffset}%)`;
    
    // On r√©duit la variation verticale : entre 40px et 60px (au lieu de 40 √† 80)
    const randomBottom = 40 + (Math.random() * 20);
    textElement.style.bottom = `${randomBottom}px`;

    targetContainer.appendChild(textElement);

    // Nettoyage automatique
    setTimeout(() => {
        if (textElement.parentElement) {
            textElement.parentElement.removeChild(textElement);
        }
    }, 1000); // Dur√©e align√©e avec l'animation CSS float-fade
}


// Fichier : index.html (dans le <script> global)

const STATUS_ICONS = {
    [STATUS_EFFECTS.PARALYZED]: '‚ö°',
    [STATUS_EFFECTS.FROZEN]: '‚ùÑÔ∏è',
    [STATUS_EFFECTS.BURNED]: 'üî•',
    [STATUS_EFFECTS.POISONED]: '‚ò£Ô∏è',
    [STATUS_EFFECTS.STUNNED]: 'üòµ',
    [STATUS_EFFECTS.CONFUSED]: '‚ùì',
    [STATUS_EFFECTS.SCARED]: 'üò®',
    [STATUS_EFFECTS.REINFORCED]: 'üõ°Ô∏è',
    [STATUS_EFFECTS.AGILE]: 'üí®',
    [STATUS_EFFECTS.THORNY]: 'üåµ',
    [STATUS_EFFECTS.ENRAGED]: 'üò°',
    [STATUS_EFFECTS.PUNCHER]: 'ü•ä'
};


        

// UI : Mise √† jour des infos de zone (Version Dynamique / Accessibilit√©)
function updateZoneInfo() {
    const zoneSelectorDiv = document.querySelector('.zone-selector');
    const zoneInfoDiv = document.getElementById('zoneInfo');
    
    // --- MODE TOUR ---
    if (game && game.towerState.isActive) {
        zoneSelectorDiv.classList.add('tower-mode');
        const floor = game.towerState.currentFloor;
        let floorText = `üè∞ TOUR DE COMBAT - √âTAGE ${floor}`;
        if (floor % 10 === 0) floorText = `üíÄ BOSS MAJEUR - √âTAGE ${floor} üíÄ`;
        else if (floor % 5 === 0) floorText = `‚öîÔ∏è DRESSEUR D'√âLITE - √âTAGE ${floor}`;
        zoneInfoDiv.innerHTML = floorText;
        return; 
    }

    // --- MODE ZONE ---
    if (zoneSelectorDiv.classList.contains('tower-mode')) {
        zoneSelectorDiv.classList.remove('tower-mode');
    }

    const zone = ZONES[currentZone];
    if (!game || !game.zoneProgress || !game.zoneProgress[currentZone]) {
        if (zone) zoneInfoDiv.textContent = "Zone actuelle : " + zone.name;
        return;
    }

    const progress = game.zoneProgress[currentZone];
    const maxTier = zone.maxTier || 50;
    const tiersInZone = progress.pokemonTiers || {};

    // ‚úÖ LE FIX EST ICI : On ne compte que ce qu'on peut attraper !
    // Si pas de canne, pas de Magicarpe dans le total.
    const pokemonInZone = game.getReachablePokemonInZone(currentZone);

    // Calculs
    const totalPokemon = pokemonInZone.length;
    const pokemonAtMaxTier = pokemonInZone.filter(name => (tiersInZone[name] || 0) >= maxTier).length;

    let bossScore = 0, bossMax = 0;
    if (zone.requiredBosses > 0) {
        bossMax = 1;
        if ((progress.bossesDefeated || 0) >= zone.requiredBosses) bossScore = 1;
    }

    let epicScore = 0, epicMax = 0;
    if (zone.requiredEpics > 0) {
        epicMax = 1;
        if ((progress.epicsDefeated || 0) >= zone.requiredEpics) epicScore = 1;
    }

    const currentTotal = pokemonAtMaxTier + bossScore + epicScore;
    const maxTotal = totalPokemon + bossMax + epicMax;
    const masteryComplete = currentTotal >= maxTotal && maxTotal > 0; // S√©curit√© div/0

    let html = `
        <div class="zone-objective">
            <div>
                <span class="zone-objective-label">Ma√Ætrise</span>
                <button class="zone-details-btn" onclick="showZoneTierModal()">D√©tails</button>
            </div>
            <span class="zone-objective-progress ${masteryComplete ? '' : 'incomplete'}">
                ${currentTotal}/${maxTotal}
            </span>
        </div>
    `;
    
    zoneInfoDiv.innerHTML = html;
}
/**
 * Affiche le modal de progression (Version Filtr√©e par √âquipement)
 */
function showZoneTierModal() {
    if (!game) return;

    const zone = ZONES[currentZone];
    
    // ‚úÖ UTILISATION DU NOUVEAU FILTRE
    const pokemonInZone = game.getReachablePokemonInZone(currentZone);
    
    const progress = game.zoneProgress[currentZone];
    const tiersInZone = progress.pokemonTiers || {};
    const maxTier = zone.maxTier || 50;

    const modal = document.getElementById('zoneTierModal');
    const title = document.getElementById('zoneTierModalTitle');
    const grid = document.getElementById('zoneTierModalGrid');

    if (!modal || !title || !grid) return;

    title.textContent = `Progression - ${zone.name}`;
    grid.innerHTML = '';

    // --- Blocs Boss et Epics (Inchang√©) ---
    let bossHTML = '';
    let epicHTML = '';

    if (zone.requiredBosses > 0) {
        const currentBosses = progress.bossesDefeated || 0;
        const bossComplete = currentBosses >= zone.requiredBosses;
        bossHTML = `
            <div class="zone-objective" style="flex: 1; min-width: 150px;">
                <span class="zone-objective-label">Boss</span>
                <span class="zone-objective-progress ${bossComplete ? '' : 'incomplete'}">
                    ${currentBosses}/${zone.requiredBosses}
                </span>
            </div>`;
    }

    if (zone.requiredEpics > 0) {
        const currentEpics = progress.epicsDefeated || 0;
        const epicComplete = currentEpics >= zone.requiredEpics;
        epicHTML = `
            <div class="zone-objective" style="flex: 1; min-width: 150px;">
                <span class="zone-objective-label">Epics</span>
                <span class="zone-objective-progress ${epicComplete ? '' : 'incomplete'}">
                    ${currentEpics}/${zone.requiredEpics}
                </span>
            </div>`;
    }

    if (bossHTML || epicHTML) {
        grid.innerHTML = `<div style="grid-column: 1 / -1; display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">${bossHTML}${epicHTML}</div>`;
    }

    // --- Liste des Pok√©mon ---
    if (!pokemonInZone || pokemonInZone.length === 0) {
        if (!bossHTML && !epicHTML) grid.innerHTML = "<p>Aucun Pok√©mon accessible.</p>";
        modal.classList.add('show');
        return;
    }

    pokemonInZone.forEach(pokemonName => {
        const currentTier = tiersInZone[pokemonName] || 0;
        const percent = Math.min(100, (currentTier / maxTier) * 100);
        const spriteUrl = getPokemonSpriteUrl(pokemonName, false, false);
        const isMaxed = currentTier >= maxTier;

        const card = document.createElement('div');
        card.className = 'creature-card';
        if (isMaxed) {
            card.style.borderColor = "#22c55e";
            card.style.background = "#f0fdf4";
        }

        card.innerHTML = `
            <img src="${spriteUrl}" alt="${pokemonName}" class="team-slot-sprite">
            <div class="team-slot-name">${pokemonName}</div>
            <div style="font-size: 11px; color: ${isMaxed ? '#16a34a' : '#666'}; font-weight:bold;">
                Tier ${currentTier}/${maxTier}
            </div>
            <div class="tier-progress-bar">
                <div class="tier-progress-fill" style="width: ${percent}%; background: ${isMaxed ? '#16a34a' : ''}"></div>
            </div>
        `;
        grid.appendChild(card);
    });

    modal.classList.add('show');
}

/**
 * Ferme le modal de progression des tiers
 */
function closeZoneTierModal() {
    const modal = document.getElementById('zoneTierModal');
    modal.classList.remove('show');
}


function saveGame() {
    if (window.game) {
        return game.saveGame();
    }
}

function loadGame() {
    if (window.game) {
        return game.loadGame();
    }
}
     
        function resetGame() {
            if (confirm('Etes-vous sur de vouloir recommencer ? Toute progression sera perdue !')) {
                localStorage.removeItem('creatureGameSave');
                location.reload();
            }
        }

       

function closeSynergyModal() {
    const modal = document.getElementById('synergyModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

function closeSynergyListModal() {
    const modal = document.getElementById('synergyListModal');
    if (modal) {
        modal.classList.remove('show');
    }
}

function togglePension() {
    if (!game) return;

    // Inverse l'√©tat
    game.isPensionCollapsed = !game.isPensionCollapsed;

    const pensionContainer = document.getElementById('pensionContainer');
    const pensionIcon = document.getElementById('pensionToggleIcon');

    if (game.isPensionCollapsed) {
        pensionContainer.style.display = 'none';
        pensionIcon.textContent = '‚ñ∂'; // Fl√®che vers la droite (ferm√©e)
    } else {
        pensionContainer.style.display = 'block';
        pensionIcon.textContent = '‚ñº'; // Fl√®che vers le bas (ouverte)
    }
}
       // ... (dans votre <script> global)

function switchTab(tabName) {
    const tabs = document.querySelectorAll('.tab-content');
    tabs.forEach(tab => tab.classList.remove('active'));

    const buttons = document.querySelectorAll('.tab-btn');
    buttons.forEach(btn => btn.classList.remove('active'));

    const selectedTab = document.getElementById(tabName + 'Tab');
    if (selectedTab) {
        selectedTab.classList.add('active');
    }

    if (event && event.target) {
        event.target.classList.add('active');
    }
   
}

// ==========================================
// ANIMATION CAPTURE (Version Standard Nettoy√©e)
// ==========================================
async function playCaptureSequence(ballImage, spriteElement, success, shakesCount = 3) {
    return new Promise(resolve => {
        const container = spriteElement.parentElement;
        if (!container) { resolve(); return; }

        const ball = document.createElement('img');
        ball.src = ballImage;
        ball.className = 'flying-ball'; 
        
        // Position
        ball.style.bottom = '10px';
        ball.style.left = '50%';
        ball.style.marginLeft = '-32px';
        ball.style.opacity = '0';
        
        container.appendChild(ball);

        // Force Reflow
        void ball.offsetWidth; 

        // --- PHASE 1 : LANCER (0.75s) ---
        ball.style.opacity = '1';
        ball.classList.add('anim-throw');

        // --- PHASE 2 : IMPACT (√† 750ms) ---
        setTimeout(() => {
            if(spriteElement) spriteElement.classList.add('absorbed');
            ball.classList.add('grounded'); 
            ball.classList.remove('anim-throw');
            ball.classList.add('anim-bounce');
        }, 750); 

        // --- PHASE 3 : SECOUSSES (√† 1350ms) ---
        setTimeout(async () => {
            const shake = (cls) => new Promise(r => {
                ball.classList.remove('anim-bounce', 'anim-shake-1', 'anim-shake-2', 'anim-shake-3');
                void ball.offsetWidth;
                ball.classList.add(cls);
                setTimeout(r, 900); 
            });

            // On joue simplement le nombre de shakes calcul√©s
            if (shakesCount >= 1) await shake('anim-shake-1');
            if (shakesCount >= 2) await shake('anim-shake-2');
            if (shakesCount >= 3) await shake('anim-shake-3');

            // --- PHASE 4 : R√âSULTAT ---
            if (success) {
                ball.classList.add('anim-lock');
                const star = document.createElement('div');
                star.textContent = '‚ú®';
                star.style.position = 'absolute';
                star.style.bottom = '60px'; 
                star.style.left = '50%';
                star.style.fontSize = '40px'; 
                star.style.transform = 'translateX(-50%)';
                star.style.animation = 'catch-stars 0.5s ease-out forwards';
                container.appendChild(star);
                
                setTimeout(() => { resolve(); }, 800);
            } else {
                ball.classList.add('anim-break');
                setTimeout(() => {
                    if(spriteElement) {
                        spriteElement.classList.remove('absorbed');
                        spriteElement.style.filter = "sepia(1) hue-rotate(-50deg) saturate(3)";
                        setTimeout(() => spriteElement.style.filter = "", 500);
                    }
                    ball.remove();
                    resolve();
                }, 300);
            }

        }, 1350); 
    });
}
// ‚úÖ NOUVELLE FONCTION pour les sous-onglets de la Boutique
function switchShopSubTab(tabName) {
    // Cacher tous les contenus de sous-onglets
    const subContents = document.querySelectorAll('#boutiqueTab .sub-tab-content');
    subContents.forEach(tab => tab.classList.remove('active'));
    
    // D√©sactiver tous les boutons de sous-onglets
    const subButtons = document.querySelectorAll('#boutiqueTab .sub-tab-btn');
    subButtons.forEach(btn => btn.classList.remove('active'));
    
    // Afficher le contenu s√©lectionn√©
    const selectedTab = document.getElementById('shop-' + tabName);
    if (selectedTab) {
        selectedTab.classList.add('active');
    }
    
    // Activer le bouton s√©lectionn√©
    if (event && event.target) {
        event.target.classList.add('active');
    }

    // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è AJOUTEZ CE BLOC LOGIQUE ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
    if (game) {
        if (tabName === 'epicerie') {
            game.updatePokeMartDisplay();
        } 
        else if (tabName === 'pokedollars') {
            game.updateUpgradesDisplay();
        } 
        else if (tabName === 'jetons') {
            game.updateShopDisplay();
        } 
        else if (tabName === 'marques') {
            game.updateTowerShopDisplay();
        } 
        else if (tabName === 'recycleur') {
            game.updateRecyclerDisplay();
        }
    }
}

function closeOfflineModal() {
    const modal = document.getElementById('offlineModal');
    if (modal) modal.style.display = 'none';
}

/**
 * R√©cup√®re le chemin de l'image d'un objet.
 * @param {string} itemKey - L'identifiant de l'objet
 */
function getItemIconPath(itemKey) {
    // 1. On regarde dans votre constante ALL_ITEMS
    if (typeof ALL_ITEMS !== 'undefined' && ALL_ITEMS[itemKey]) {
        const item = ALL_ITEMS[itemKey];
        
        // ‚úÖ PRIORIT√â 1 : La propri√©t√© 'img' que vous utilisez (PokeAPI)
        if (item.img) return item.img;
        
        // Compatibilit√© : Si jamais certains objets utilisent d'autres noms
        if (item.image) return item.image;
        if (item.sprite) return item.sprite;
    }
    
    // 2. Gestion des ≈íufs (Si pas d√©finis dans ALL_ITEMS)
    if (itemKey.startsWith('egg_')) {
        return "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/lucky-egg.png";
    }
    
    // 3. Fallback : Si aucune image n'est d√©finie
    return `assets/items/${itemKey}.png`; 
}

function getPokemonSpritePath(name, isShiny) {
    // 1. La "Source de V√©rit√©" : Tes stats locales
    if (typeof POKEMON_BASE_STATS !== 'undefined' && POKEMON_BASE_STATS[name]) {
        const stats = POKEMON_BASE_STATS[name];

        // Si c'est Shiny, on regarde s'il y a un sprite shiny d√©fini
        if (isShiny && stats.shinySprite) return stats.shinySprite;
        // Sinon sprite normal
        if (!isShiny && stats.sprite) return stats.sprite;
        
        // Parfois on met juste "image" pour le normal
        if (!isShiny && stats.image) return stats.image;
    }

    // 2. Fallback : Si rien n'est d√©fini localement, on utilise ta fonction API complexe
    // (C'est la roue de secours si tu n'as pas t√©l√©charg√© les images)
    return getPokemonSpriteUrl(name, isShiny); 
}

/**
 * R√©cup√®re la classe CSS de raret√© pour un objet.
 * @param {string} itemKey - L'ID de l'objet (ex: 'super_potion')
 * @returns {string} La classe CSS (ex: 'rarity-rare')
 */
function getRarityClass(itemKey) {
    // 1. Gestion des ≈ìufs (qui n'ont pas forc√©ment d'entr√©e dans ALL_ITEMS)
    if (itemKey.startsWith('egg_')) {
        // egg_common, egg_rare, etc.
        const rarity = itemKey.replace('egg_', '');
        return `rarity-${rarity}`;
    }

    // 2. Recherche dans la base de donn√©es items
    if (typeof ALL_ITEMS !== 'undefined' && ALL_ITEMS[itemKey]) {
        return `rarity-${ALL_ITEMS[itemKey].rarity || 'common'}`;
    }
    
    // 3. Par d√©faut
    return 'rarity-common';
}
// Wrapper global pour le HTML onclick/onchange
window.changeZone = function(zoneId) {
    if (window.game) {
        window.game.changeZone(zoneId);
    }
};
// ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è AJOUTEZ CES LIGNES DE TEST ICI ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
    console.log("--- V√âRIFICATION DES CONSTANTES ---");
    console.log("ZONES (depuis constants.js) :", typeof ZONES);
    console.log("POKEMON_BASE_STATS (depuis pokemonStats.js) :", typeof POKEMON_BASE_STATS);
    console.log("-----------------------------------");
    // ‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è FIN DE L'AJOUT ‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è
        window.addEventListener('load', () => {
            game = new Game();
            updateZoneInfo();
        });
		
    </script>
	<div id="statsModal" class="stats-modal"> <div class="stats-content">           <div class="stats-header">
            <h2>üìä Statistiques</h2>
            <button class="stats-close" onclick="game.closeStatsModal()">Fermer</button>
        </div>
        
        <div id="statsDisplay"></div>

    </div>
</div>
<div id="bonusModal" class="stats-modal">
    <div class="stats-content" onclick="event.stopPropagation()">
        
        <div class="stats-header" style="border-bottom-color: #8b5cf6;">
            <h2 style="color: #8b5cf6;">üéÅ Bonus & Boutique</h2>
            <button class="stats-close" onclick="game.closeBonusModal()">Fermer</button>
        </div>
        
        <div id="bonusDisplay"></div>

    </div>
</div>
<div id="toastContainer" class="toastContainer"></div>
<div class="quest-completion-modal" id="eggHatchModal" onclick="game.closeEggHatchModal()">
    <div class="quest-completion-content" id="eggHatchContent" onclick="event.stopPropagation()">
        </div>
</div>

<div class="stats-modal" id="creatureModal" onclick="game.closeCreatureModal()">
    <div class="stats-content" id="creatureModalContent" ... onclick="event.stopPropagation()">
        </div>
</div>

<div class="stats-modal" id="zoneTierModal" onclick="closeZoneTierModal()">
    <div class="stats-content" id="zoneTierModalContent" onclick="event.stopPropagation()">
        <div class="stats-header">
            <h2 id="zoneTierModalTitle">Progression de la Zone</h2>
            <button class="stats-close" onclick="closeZoneTierModal()">Fermer</button>
        </div>
        <div class="team-list" id="zoneTierModalGrid">
            </div>
    </div>
</div>

<div class="stats-modal" id="synergyListModal" onclick="closeSynergyListModal()">
    <div class="stats-content" onclick="event.stopPropagation()" style="max-width: 700px;">
        <div class="stats-header">
            <h2>Guide des Synergies</h2>
            <button class="stats-close" onclick="closeSynergyListModal()">Fermer</button>
        </div>
        <div id="synergyListContent" class="synergy-list-grid">
            </div>
    </div>
</div>

<div class="stats-modal" id="relicModal">
    <div class="stats-content" style="text-align: center;">
        <div class="stats-header">
            <h2>üéÅ R√©compense d'√âtage</h2>
        </div>
        <p style="margin-bottom: 20px;">Choisissez une relique pour la suite de l'ascension :</p>
        <div id="relicOptionsGrid" class="items-grid">
            </div>
    </div>
</div>

<div class="quest-completion-modal" id="captureModal">
    <div class="quest-completion-content" style="max-width: 500px;">
        <div class="quest-completion-title" style="color: #ff6b6b;">Ennemi Vaincu !</div>
        
        <div style="margin: 20px 0;">
            <img id="captureSprite" src="" style="width: 96px; height: 96px;">
            <h3 id="captureName" style="margin-top: 10px;"></h3>
            <p id="captureChanceText" style="color: #666; font-size: 14px;"></p>
        </div>

        <div id="captureButtons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
            </div>

        <button class="btn" style="background: #ef4444; color: white; width: 100%;" onclick="game.skipCapture()">
            Ne pas capturer (Partir)
        </button>
    </div>
</div>

<div class="stats-modal" id="starterModal" style="background: rgba(0,0,0,0.95); z-index: 20000;">
    <div class="stats-content" style="max-width: 900px; text-align: center; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);">
        <h1 style="color: #333; margin-bottom: 10px; font-size: 32px;">Bienvenue, Dresseur !</h1>
        <p style="color: #666; margin-bottom: 30px; font-size: 18px;">Le monde des cr√©atures vous attend. Choisissez votre premier compagnon pour d√©buter l'aventure.</p>
        
        <div class="starter-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
            
            <div class="starter-card" onclick="game.selectStarter('grass')">
                <div class="starter-bg grass"></div>
                <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png" class="starter-sprite">
                <h2 style="color: #2e7d32;">Bulbasaur</h2>
                <div class="type-badge type-grass">Plante</div>
                <div class="type-badge type-poison">Poison</div>
                <p>Un Pok√©mon √©quilibr√©, id√©al pour les d√©butants.</p>
            </div>

            <div class="starter-card" onclick="game.selectStarter('fire')">
                <div class="starter-bg fire"></div>
                <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/4.png" class="starter-sprite">
                <h2 style="color: #c62828;">Charmander</h2>
                <div class="type-badge type-fire">Feu</div>
                <p>Une puissance offensive redoutable une fois √©volu√©.</p>
            </div>

            <div class="starter-card" onclick="game.selectStarter('water')">
                <div class="starter-bg water"></div>
                <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/7.png" class="starter-sprite">
                <h2 style="color: #1565c0;">Squirtle</h2>
                <div class="type-badge type-water">Eau</div>
                <p>Une d√©fense solide pour r√©sister aux assauts.</p>
            </div>

        </div>
    </div>
</div>

<div class="stats-modal" id="saveManagerModal" onclick="game.closeSaveManager()">
    <div class="stats-content" onclick="event.stopPropagation()" style="max-width: 500px; text-align: center;">
        
        <div class="stats-header">
            <h2>‚ò∞ Menu Principal</h2>
            <button class="stats-close" onclick="game.closeSaveManager()">Fermer</button>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 25px;">
            
            <button class="btn" onclick="game.openStatsModal(); game.closeSaveManager();" style="background: #3b82f6; color: white; padding: 15px 5px; font-size: 13px; display:flex; flex-direction:column; align-items:center; gap:5px;">
                <span style="font-size: 20px;">üìä</span>
                Stats
            </button>
            
            <button class="btn" onclick="game.openBonusModal(); game.closeSaveManager();" style="background: #8b5cf6; color: white; padding: 15px 5px; font-size: 13px; display:flex; flex-direction:column; align-items:center; gap:5px;">
                <span style="font-size: 20px;">üéÅ</span>
                Bonus
            </button>
            
            <button class="btn" onclick="game.openLogModal(); game.closeSaveManager();" style="background: #10b981; color: white; padding: 15px 5px; font-size: 13px; display:flex; flex-direction:column; align-items:center; gap:5px;">
                <span style="font-size: 20px;">üìú</span>
                Journal
            </button>
        
        </div>

        <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

        <h3 style="margin: 0 0 10px 0; font-size: 12px; color: #94a3b8; text-transform: uppercase; text-align: left;">
            üíæ Donn√©es
        </h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
            <button class="btn btn-save" onclick="game.saveGame(); game.closeSaveManager();" style="grid-column: 1 / -1; padding: 12px;">
                Sauvegarder
            </button>
            <button class="btn" onclick="game.exportSaveFile()" style="background: #0dcaf0; color: white; padding: 10px; font-size: 11px;">
                ‚¨áÔ∏è Exporter
            </button>
            <button class="btn" onclick="game.importSaveFile()" style="background: #ffc107; color: #333; padding: 10px; font-size: 11px;">
                ‚¨ÜÔ∏è Importer
            </button>
        </div>

        <div style="text-align: left; background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; font-size: 12px; color: #94a3b8; text-transform: uppercase;">
                ‚öôÔ∏è Options
            </h3>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 13px; color: #334155; font-weight:bold;">üß¨ Smart Fusion</span>
                <button id="optSmartFusion" onclick="game.toggleSmartFusion()" class="btn" style="padding: 4px 10px; font-size: 11px; border-radius: 20px; min-width: 50px;">?</button>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 13px; color: #334155; font-weight:bold;">üõë Pause Rare</span>
                <button id="optPauseRare" onclick="game.toggleRarePause()" class="btn" style="padding: 4px 10px; font-size: 11px; border-radius: 20px; min-width: 50px;">?</button>
            </div>
        </div>

        <div style="background: #fff5f5; border: 1px solid #fecaca; border-radius: 10px; padding: 10px;">
            <button class="btn btn-reset" onclick="resetGame()" style="width: 100%; font-size: 11px; padding: 8px;">
                üóëÔ∏è R√©initialiser le jeu
            </button>
        </div>
        
        <div style="margin-top: 15px; font-size: 10px; color: #cbd5e1;">v1.0.3</div>
    </div>
</div>

<div class="stats-modal" id="masteryModal" onclick="document.getElementById('masteryModal').classList.remove('show')">
    <div class="stats-content" style="max-width: 600px;" onclick="event.stopPropagation()">
        <div class="stats-header">
            <h2>üìú Ma√Ætrise des Biomes</h2>
            <button class="stats-close" onclick="document.getElementById('masteryModal').classList.remove('show')">Fermer</button>
        </div>
        <p style="color:#666; font-size:13px; margin-bottom:20px;">
            Effectuez des exp√©ditions pour monter de niveau dans chaque biome et r√©duire la dur√©e des trajets !
        </p>
        <div id="masteryListGrid" class="team-list" style="grid-template-columns: 1fr;">
            </div>
    </div>
</div>

<div id="customTooltip" class="custom-tooltip"></div>

<div id="logModal" class="modal">
    <div class="modal-content log-modal-content">
        
        <div class="modal-header-logs">
            <h2>üìú Journal d'Aventure</h2>
            <button class="close-btn" onclick="game.closeLogModal()" style="background:none; border:none; color:#e2e8f0; font-size:28px; cursor:pointer; line-height:1;">&times;</button>
        </div>
        
        <div id="gameLog" class="log-console-scroll">
            <div class="log-entry" style="color:#94a3b8; font-style:italic; text-align:center; padding-top:20px;">
                Le journal enregistre les √©v√©nements importants...
            </div>
        </div>

        <div class="modal-footer-logs">
            <button class="btn" onclick="game.clearLogs()" style="background: #ef4444; color: white; border:none; padding: 8px 16px; border-radius:6px; cursor:pointer; font-size:12px; font-weight:600; transition: background 0.2s;">
                üóëÔ∏è Effacer l'historique
            </button>
        </div>

    </div>
</div>

<div id="offlineModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h2>üí§ Rapport de Veille</h2>
            <span class="close-modal" onclick="closeOfflineModal()">&times;</span>
        </div>
        
        <div class="modal-body">
            <p class="offline-time-text">Vous avez √©t√© absent pendant <span id="offlineTimeDisplay" class="highlight">00h 00m</span></p>

            <div class="offline-stats-grid">
                <div class="stat-box">
                    <span class="stat-icon">‚öîÔ∏è</span>
                    <span id="offlineCombats" class="stat-value">0</span>
                    <span class="stat-label">Combats</span>
                </div>
                <div class="stat-box">
                    <span class="stat-icon">üèÜ</span>
                    <span id="offlineWins" class="stat-value">0</span>
                    <span class="stat-label">Victoires</span>
                </div>
                <div class="stat-box">
                    <span class="stat-icon">üì¶</span>
                    <span id="offlineDrops" class="stat-value">0</span>
                    <span class="stat-label">Objets</span>
                </div>
                <div class="stat-box">
                    <span class="stat-icon">üï∏Ô∏è</span>
                    <span id="offlineCaptured" class="stat-value">0</span>
                    <span class="stat-label">Captur√©s</span>
                </div>
            </div>
<div class="offline-loot-section">
    <div class="loot-header">D√©tails du Butin </div>
    <div id="offlineLootList" class="loot-list">
        </div>
</div>
            <div class="offline-rewards">
                <div class="reward-row">
                    <span class="reward-label">‚ú® Exp√©rience :</span>
                    <span id="offlineXp" class="reward-value xp-color">+0 XP</span>
                </div>
                <div class="reward-row">
                    <span class="reward-label">üí∞ Pok√©dollars :</span>
                    <span id="offlineGold" class="reward-value gold-color">+0 $</span>
                </div>
            </div>

            <button class="modal-btn" onclick="closeOfflineModal()">R√©cup√©rer les gains</button>
        </div>
    </div>
</div>

</body>
</html>